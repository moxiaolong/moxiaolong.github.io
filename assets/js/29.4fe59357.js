(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{346:function(n,o,t){"use strict";t.r(o);var l=t(8),s=Object(l.a)({},(function(){var n=this,o=n._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("ul",[o("li",[n._v("用于"),o("strong",[n._v("原子、互斥量或通道")]),n._v("操作导致goroutine阻塞，调度器将把当前阻塞的goroutine从本地运行队列"),o("strong",[n._v("LRQ换出")]),n._v("，并重新调度其它goroutine；")]),n._v(" "),o("li",[n._v("由于"),o("strong",[n._v("网络请求")]),n._v("和"),o("strong",[n._v("IO")]),n._v("导致的阻塞，Go提供了网络轮询器（Netpoller）来处理，后台用epoll等技术实现IO多路复用。")])]),n._v(" "),o("p",[n._v("其它回答：")]),n._v(" "),o("ul",[o("li",[o("strong",[n._v("channel阻塞")]),n._v("：当goroutine读写channel发生阻塞时，会调用gopark函数，该G脱离当前的M和P，调度器将新的G放入当前M。")]),n._v(" "),o("li",[o("strong",[n._v("系统调用")]),n._v("：当某个G由于系统调用陷入内核态，该P就会脱离当前M，此时P会更新自己的状态为Psyscall，M与G相互绑定，进行系统调用。结束以后，若该P状态还是Psyscall，则直接关联该M和G，否则使用闲置的处理器处理该G。")]),n._v(" "),o("li",[o("strong",[n._v("系统监控")]),n._v("：当某个G在P上运行的时间超过10ms时候，或者P处于Psyscall状态过长等情况就会调用retake函数，触发新的调度。")]),n._v(" "),o("li",[o("strong",[n._v("主动让出")]),n._v("：由于是协作式调度，该G会主动让出当前的P（通过GoSched），更新状态为Grunnable，该P会调度队列中的G运行。")])])])}),[],!1,null,null,null);o.default=s.exports}}]);