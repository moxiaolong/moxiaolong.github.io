(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{362:function(a,t,s){"use strict";s.r(t);var r=s(8),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("设计模式是对面向对象设计中反复出现的问题的解决方案。\n")]),a._v(" "),t("h2",{attrs:{id:"创建型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[a._v("#")]),a._v(" 创建型模式")]),a._v(" "),t("h3",{attrs:{id:"工厂方法模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式"}},[a._v("#")]),a._v(" 工厂方法模式")]),a._v(" "),t("p",[a._v("通过工厂接口去创建对象，而不是直接new对象。")]),a._v(" "),t("h3",{attrs:{id:"抽象工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[a._v("#")]),a._v(" 抽象工厂模式")]),a._v(" "),t("p",[a._v("和工厂方法模式类似，但是工厂方法模式只有一个工厂接口，而抽象工厂模式有多个工厂接口。")]),a._v(" "),t("h3",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[a._v("#")]),a._v(" 单例模式")]),a._v(" "),t("p",[a._v("虚拟机里只有一个实例。")]),a._v(" "),t("h3",{attrs:{id:"建造者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式"}},[a._v("#")]),a._v(" 建造者模式")]),a._v(" "),t("p",[a._v("复杂对象分步骤创建。")]),a._v(" "),t("h3",{attrs:{id:"原型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[a._v("#")]),a._v(" 原型模式")]),a._v(" "),t("p",[a._v("通过复制已有对象来创建新对象。")]),a._v(" "),t("h2",{attrs:{id:"结构型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[a._v("#")]),a._v(" 结构型模式")]),a._v(" "),t("h3",{attrs:{id:"适配器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[a._v("#")]),a._v(" 适配器模式")]),a._v(" "),t("p",[a._v("将一个接口实现转换为另一个接口实现。")]),a._v(" "),t("h3",{attrs:{id:"装饰器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式"}},[a._v("#")]),a._v(" 装饰器模式")]),a._v(" "),t("p",[a._v("在不改变原有对象的基础上，通过对其进行包装拓展，支持新的功能。")]),a._v(" "),t("h3",{attrs:{id:"代理模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[a._v("#")]),a._v(" 代理模式")]),a._v(" "),t("p",[a._v("通过代理对象控制原有对象的访问。")]),a._v(" "),t("h3",{attrs:{id:"外观模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外观模式"}},[a._v("#")]),a._v(" 外观模式")]),a._v(" "),t("p",[a._v("通过一个外观类，将多个子系统的功能聚合在一起，对外提供统一的接口。")]),a._v(" "),t("h3",{attrs:{id:"桥接模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式"}},[a._v("#")]),a._v(" 桥接模式")]),a._v(" "),t("p",[a._v("将抽象部分和实现部分分离，使它们都可以独立地变化。桥接模式是为了解决多个维度发生变化时带来的类爆炸问题。")]),a._v(" "),t("h3",{attrs:{id:"组合模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合模式"}},[a._v("#")]),a._v(" 组合模式")]),a._v(" "),t("p",[a._v("将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。")]),a._v(" "),t("h3",{attrs:{id:"享元模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#享元模式"}},[a._v("#")]),a._v(" 享元模式")]),a._v(" "),t("p",[a._v("通过共享对象来减少内存使用。")]),a._v(" "),t("h2",{attrs:{id:"行为型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[a._v("#")]),a._v(" 行为型模式，")]),a._v(" "),t("h3",{attrs:{id:"策略模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[a._v("#")]),a._v(" 策略模式")]),a._v(" "),t("p",[a._v("定义一系列算法，将每个算法都封装起来，并且使它们之间可以互换。")]),a._v(" "),t("h3",{attrs:{id:"模板方法模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式"}},[a._v("#")]),a._v(" 模板方法模式")]),a._v(" "),t("p",[a._v("定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。")]),a._v(" "),t("h3",{attrs:{id:"观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[a._v("#")]),a._v(" 观察者模式")]),a._v(" "),t("p",[a._v("定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。")]),a._v(" "),t("h3",{attrs:{id:"迭代器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[a._v("#")]),a._v(" 迭代器模式")]),a._v(" "),t("p",[a._v("提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。")]),a._v(" "),t("h3",{attrs:{id:"责任链模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式"}},[a._v("#")]),a._v(" 责任链模式")]),a._v(" "),t("p",[a._v("很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。")]),a._v(" "),t("h3",{attrs:{id:"命令模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令模式"}},[a._v("#")]),a._v(" 命令模式")]),a._v(" "),t("p",[a._v("将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。")]),a._v(" "),t("h3",{attrs:{id:"备忘录模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#备忘录模式"}},[a._v("#")]),a._v(" 备忘录模式")]),a._v(" "),t("p",[a._v("在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。")]),a._v(" "),t("h3",{attrs:{id:"状态模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态模式"}},[a._v("#")]),a._v(" 状态模式")]),a._v(" "),t("p",[a._v("允许一个对象在其内部状态改变时改变它的行为。")]),a._v(" "),t("h3",{attrs:{id:"访问者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问者模式"}},[a._v("#")]),a._v(" 访问者模式")]),a._v(" "),t("p",[a._v("数据结构与数据操作分离。")]),a._v(" "),t("h3",{attrs:{id:"中介者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中介者模式"}},[a._v("#")]),a._v(" 中介者模式")]),a._v(" "),t("p",[a._v("代理模式是一对一，一个代理只能代表一个对象。中介者模式则是多对多，中介者的功能多样，客户也可以多个。")]),a._v(" "),t("h3",{attrs:{id:"解释器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释器模式"}},[a._v("#")]),a._v(" 解释器模式")]),a._v(" "),t("p",[a._v("给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。")])])}),[],!1,null,null,null);t.default=v.exports}}]);