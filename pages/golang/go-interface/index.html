<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>go interface 设计与实现 | Dra-M</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/logo.webp">
    <link rel="manifest" href="/manifest.json">
    <script data-ad-client="ca-pub-8621788234752924" defer="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924" crossorigin="anonymous"></script>
    <meta name="description" content="一些技术(前端、后端、运维)相关的经验、随想、资源收藏，和一些哲学随想。">
    <meta name="keywords" content="开发技术,哲学,DragonMo,Dra-M,莫小龙">
    <meta name="theme-color" content="#7b074b">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <link rel="preload" href="/assets/css/0.styles.8ee39092.css" as="style"><link rel="preload" href="/assets/js/app.bc3c2a75.js" as="script"><link rel="preload" href="/assets/js/2.472001a0.js" as="script"><link rel="preload" href="/assets/js/35.bb95ae18.js" as="script"><link rel="prefetch" href="/assets/js/10.da818c35.js"><link rel="prefetch" href="/assets/js/100.c9dc513a.js"><link rel="prefetch" href="/assets/js/101.f3685f69.js"><link rel="prefetch" href="/assets/js/102.98577fde.js"><link rel="prefetch" href="/assets/js/103.401885da.js"><link rel="prefetch" href="/assets/js/104.5ca2a2ba.js"><link rel="prefetch" href="/assets/js/105.896bd937.js"><link rel="prefetch" href="/assets/js/106.199efe2c.js"><link rel="prefetch" href="/assets/js/107.206ba497.js"><link rel="prefetch" href="/assets/js/108.c1eb4655.js"><link rel="prefetch" href="/assets/js/109.221866e5.js"><link rel="prefetch" href="/assets/js/11.a6aff4f5.js"><link rel="prefetch" href="/assets/js/110.e3239981.js"><link rel="prefetch" href="/assets/js/111.ef06b5a1.js"><link rel="prefetch" href="/assets/js/112.ccf225d6.js"><link rel="prefetch" href="/assets/js/113.8d8640b2.js"><link rel="prefetch" href="/assets/js/114.056f749a.js"><link rel="prefetch" href="/assets/js/115.ed35567d.js"><link rel="prefetch" href="/assets/js/116.29426a1f.js"><link rel="prefetch" href="/assets/js/117.86847b2b.js"><link rel="prefetch" href="/assets/js/118.885246c5.js"><link rel="prefetch" href="/assets/js/119.6b04ff26.js"><link rel="prefetch" href="/assets/js/12.dd3a474e.js"><link rel="prefetch" href="/assets/js/120.99542ea6.js"><link rel="prefetch" href="/assets/js/121.c89b2199.js"><link rel="prefetch" href="/assets/js/122.b4c96f13.js"><link rel="prefetch" href="/assets/js/123.e74abe64.js"><link rel="prefetch" href="/assets/js/124.5479e5ef.js"><link rel="prefetch" href="/assets/js/125.47f5d91e.js"><link rel="prefetch" href="/assets/js/126.2eda5054.js"><link rel="prefetch" href="/assets/js/127.fbf8b987.js"><link rel="prefetch" href="/assets/js/128.3bb898fe.js"><link rel="prefetch" href="/assets/js/129.59014c61.js"><link rel="prefetch" href="/assets/js/13.2d318d3d.js"><link rel="prefetch" href="/assets/js/130.b5701dcd.js"><link rel="prefetch" href="/assets/js/131.af42802d.js"><link rel="prefetch" href="/assets/js/132.a0a52815.js"><link rel="prefetch" href="/assets/js/133.c7f6fcd9.js"><link rel="prefetch" href="/assets/js/134.1fa00d40.js"><link rel="prefetch" href="/assets/js/135.1c93b5ec.js"><link rel="prefetch" href="/assets/js/136.ce22005d.js"><link rel="prefetch" href="/assets/js/137.d689e32c.js"><link rel="prefetch" href="/assets/js/138.52557618.js"><link rel="prefetch" href="/assets/js/139.5576ce4a.js"><link rel="prefetch" href="/assets/js/14.41100292.js"><link rel="prefetch" href="/assets/js/140.3becc2ed.js"><link rel="prefetch" href="/assets/js/141.60103e1a.js"><link rel="prefetch" href="/assets/js/142.f44d458d.js"><link rel="prefetch" href="/assets/js/143.5a60f54e.js"><link rel="prefetch" href="/assets/js/144.ce362fab.js"><link rel="prefetch" href="/assets/js/145.f4d3209c.js"><link rel="prefetch" href="/assets/js/146.f90aee50.js"><link rel="prefetch" href="/assets/js/15.daabeb64.js"><link rel="prefetch" href="/assets/js/16.a4a3b21c.js"><link rel="prefetch" href="/assets/js/17.8b6cce9b.js"><link rel="prefetch" href="/assets/js/18.60b289d4.js"><link rel="prefetch" href="/assets/js/19.0c18504f.js"><link rel="prefetch" href="/assets/js/20.7a975e23.js"><link rel="prefetch" href="/assets/js/21.3329c224.js"><link rel="prefetch" href="/assets/js/22.5df3725f.js"><link rel="prefetch" href="/assets/js/23.1e2b6c8a.js"><link rel="prefetch" href="/assets/js/24.aac0154b.js"><link rel="prefetch" href="/assets/js/25.b26ee63b.js"><link rel="prefetch" href="/assets/js/26.6b63d3fb.js"><link rel="prefetch" href="/assets/js/27.8b487354.js"><link rel="prefetch" href="/assets/js/28.731619d6.js"><link rel="prefetch" href="/assets/js/29.4fe59357.js"><link rel="prefetch" href="/assets/js/3.6dd7c6e7.js"><link rel="prefetch" href="/assets/js/30.a93d8117.js"><link rel="prefetch" href="/assets/js/31.42cc0c6c.js"><link rel="prefetch" href="/assets/js/32.67d8d455.js"><link rel="prefetch" href="/assets/js/33.da390ef3.js"><link rel="prefetch" href="/assets/js/34.47f5bc34.js"><link rel="prefetch" href="/assets/js/36.79ce5ff9.js"><link rel="prefetch" href="/assets/js/37.e48e5b35.js"><link rel="prefetch" href="/assets/js/38.05c111ca.js"><link rel="prefetch" href="/assets/js/39.a9c4a557.js"><link rel="prefetch" href="/assets/js/4.76079b7d.js"><link rel="prefetch" href="/assets/js/40.45a45204.js"><link rel="prefetch" href="/assets/js/41.978ccffc.js"><link rel="prefetch" href="/assets/js/42.895064c8.js"><link rel="prefetch" href="/assets/js/43.c9b2330d.js"><link rel="prefetch" href="/assets/js/44.114f4169.js"><link rel="prefetch" href="/assets/js/45.5a1432cf.js"><link rel="prefetch" href="/assets/js/46.cce4db9a.js"><link rel="prefetch" href="/assets/js/47.b9ba2714.js"><link rel="prefetch" href="/assets/js/48.2e84c7f6.js"><link rel="prefetch" href="/assets/js/49.77f31886.js"><link rel="prefetch" href="/assets/js/5.13679220.js"><link rel="prefetch" href="/assets/js/50.70b8a00f.js"><link rel="prefetch" href="/assets/js/51.8f3d4e26.js"><link rel="prefetch" href="/assets/js/52.a0dff1b5.js"><link rel="prefetch" href="/assets/js/53.1a5d0aa9.js"><link rel="prefetch" href="/assets/js/54.d9b622f7.js"><link rel="prefetch" href="/assets/js/55.a078dc68.js"><link rel="prefetch" href="/assets/js/56.5a331510.js"><link rel="prefetch" href="/assets/js/57.5bec8258.js"><link rel="prefetch" href="/assets/js/58.21fe4b06.js"><link rel="prefetch" href="/assets/js/59.53211a94.js"><link rel="prefetch" href="/assets/js/6.738f6e32.js"><link rel="prefetch" href="/assets/js/60.1d1893dd.js"><link rel="prefetch" href="/assets/js/61.2dd0ba1c.js"><link rel="prefetch" href="/assets/js/62.4df81247.js"><link rel="prefetch" href="/assets/js/63.e7645407.js"><link rel="prefetch" href="/assets/js/64.c1510d68.js"><link rel="prefetch" href="/assets/js/65.e80f3f86.js"><link rel="prefetch" href="/assets/js/66.705d839b.js"><link rel="prefetch" href="/assets/js/67.852e9ce9.js"><link rel="prefetch" href="/assets/js/68.67fbda7f.js"><link rel="prefetch" href="/assets/js/69.7a78efb2.js"><link rel="prefetch" href="/assets/js/7.48b86259.js"><link rel="prefetch" href="/assets/js/70.9fc82048.js"><link rel="prefetch" href="/assets/js/71.ab52b5cf.js"><link rel="prefetch" href="/assets/js/72.e7c7a340.js"><link rel="prefetch" href="/assets/js/73.539e40a1.js"><link rel="prefetch" href="/assets/js/74.598221c8.js"><link rel="prefetch" href="/assets/js/75.876e901b.js"><link rel="prefetch" href="/assets/js/76.42349440.js"><link rel="prefetch" href="/assets/js/77.5834f7c5.js"><link rel="prefetch" href="/assets/js/78.78c797f4.js"><link rel="prefetch" href="/assets/js/79.5d0d35ae.js"><link rel="prefetch" href="/assets/js/8.10c02f71.js"><link rel="prefetch" href="/assets/js/80.e7bc8390.js"><link rel="prefetch" href="/assets/js/81.e4e4f6a8.js"><link rel="prefetch" href="/assets/js/82.98057949.js"><link rel="prefetch" href="/assets/js/83.ad7dd690.js"><link rel="prefetch" href="/assets/js/84.0f7a664d.js"><link rel="prefetch" href="/assets/js/85.378369eb.js"><link rel="prefetch" href="/assets/js/86.01ead6d0.js"><link rel="prefetch" href="/assets/js/87.70598ba5.js"><link rel="prefetch" href="/assets/js/88.600910d8.js"><link rel="prefetch" href="/assets/js/89.c783c1e2.js"><link rel="prefetch" href="/assets/js/9.4b59881c.js"><link rel="prefetch" href="/assets/js/90.85995a12.js"><link rel="prefetch" href="/assets/js/91.21e9dbf9.js"><link rel="prefetch" href="/assets/js/92.8fc80426.js"><link rel="prefetch" href="/assets/js/93.6d7adcc8.js"><link rel="prefetch" href="/assets/js/94.6147d1d9.js"><link rel="prefetch" href="/assets/js/95.61c3d1ab.js"><link rel="prefetch" href="/assets/js/96.1dc4b4c8.js"><link rel="prefetch" href="/assets/js/97.c4c52395.js"><link rel="prefetch" href="/assets/js/98.b78d3e0f.js"><link rel="prefetch" href="/assets/js/99.f1c7ba9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ee39092.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.webp" alt="Dra-M" class="logo"> <span class="site-name can-hide">Dra-M</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=975425198&amp;s=640"> <div class="blogger-info"><h3>莫小龙</h3> <span>保持理智，相信未来。</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Golang</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/golang-gitlab-ssh/" class="sidebar-link">GitLab私服+Go Modules踩坑经验（SSH自定义端口）</a></li><li><a href="/pages/gin/middle/" class="sidebar-link">【代码片段】我使用的Gin中间处理器（自定义异常处理、日志打印、traceId、跨域配置）</a></li><li><a href="/pages/java-to-golang/value-and-reference/" class="sidebar-link">【Java转Go】如何理解Go中的值类型、引用类型、nil</a></li><li><a href="/pages/java-to-golang/oop/" class="sidebar-link">【Java转Go】如何理解面向对象，怎么把Golang用成面向对象的样子</a></li><li><a href="/pages/golang/gmp/" class="sidebar-link">Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="/pages/golang/go-gmp-status/" class="sidebar-link">Go中GMP有哪些状态？</a></li><li><a href="/pages/golang/go-gc/" class="sidebar-link">一文搞懂go gc垃圾回收原理</a></li><li><a href="/pages/golang/go-block/" class="sidebar-link">Go什么时候发生阻塞？阻塞时，调度器会怎么做？</a></li><li><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/" class="sidebar-link">Go netpoller 原生网络模型之源码全面揭秘</a></li><li><a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="sidebar-link">Goroutine 泄露 - 被遗忘的发送者</a></li><li><a href="/pages/golang/go-map/" class="sidebar-link">go map 设计与实现</a></li><li><a href="/pages/golang/go-slice/" class="sidebar-link">go slice 设计与实现</a></li><li><a href="/pages/golang/go-context/" class="sidebar-link">小白也能看懂的context包详解：从入门到精通</a></li><li><a href="/pages/golang/go-interface/" aria-current="page" class="active sidebar-link">go interface 设计与实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#接口是什么" class="sidebar-link">接口是什么？</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#iface-和-eface-结构体" class="sidebar-link">iface 和 eface 结构体</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#type-是什么" class="sidebar-link">_type 是什么？</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#itab-是什么" class="sidebar-link">itab 是什么？</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#生成的-itab-是怎么被使用的" class="sidebar-link">生成的 itab 是怎么被使用的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#itab-关键方法的实现" class="sidebar-link">itab 关键方法的实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#根据-interfacetype-和-type-初始化-itab" class="sidebar-link">根据 interfacetype 和 _type 初始化 itab</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#接口断言过程总览-类型转换的关键" class="sidebar-link">接口断言过程总览（类型转换的关键）</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#panicdottypei-与-panicdottypee" class="sidebar-link">panicdottypeI 与 panicdottypeE</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#iface-和-eface-里面的-data-是怎么来的" class="sidebar-link">iface 和 eface 里面的 data 是怎么来的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#convt-方法" class="sidebar-link">convT* 方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-interface/#java-里面的小整数享元模式" class="sidebar-link">Java 里面的小整数享元模式</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-interface/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/pages/golang/go-chan/" class="sidebar-link">深入理解 go chan</a></li><li><a href="/pages/golang/go-chan-design-and-implementation/" class="sidebar-link">go chan 设计与实现</a></li><li><a href="/pages/golang/go-mutex/" class="sidebar-link">深入理解 go Mutex</a></li><li><a href="/pages/golang/go-sync-map-1/" class="sidebar-link">深入理解 go sync.Map - 基本原理</a></li><li><a href="/pages/golang/go-sync-map-2/" class="sidebar-link">go sync.Map 设计与实现</a></li><li><a href="/pages/golang/go-sync-once/" class="sidebar-link">深入理解 go sync.Once</a></li><li><a href="/pages/golang/go-reflect-1/" class="sidebar-link">深入理解 go reflect - 反射基本原理</a></li><li><a href="/pages/golang/go-reflect-2/" class="sidebar-link">深入理解 go reflect - 要不要传指针</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程思想</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运维</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script><ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="8498052873"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/code/#技术" data-v-06225672>技术</a></li><li data-v-06225672><a href="/code/#Golang" data-v-06225672>Golang</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://juejin.cn/post/7173965896656879630" target="_blank" title="作者" class="beLink" data-v-06225672>eleven26</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-13</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="/img/dragon/13.webp">go interface 设计与实现<!----></h1>  <div class="theme-vdoing-content content__default"><p>在了解 go <code>interface</code> 的设计过程中，看了不少资料，但是大多数资料都有生成汇编的操作，但是在我的电脑上指向生成汇编的操作的时候， 生成的汇编代码却不太一样，所以有很多的东西无法验证正确性，这部分内容不会出现在本文中。本文只写那些经过本机验证正确的内容，但也不用担心，因为涵盖了 go <code>interface</code> 设计与实现的核心部分内容，但由于水平有限，所以只能尽可能地传达我所知道的关于 <code>interface</code> 的一切东西。对于有疑问的部分，有兴趣的读者可以自行探索。</p> <p>如果想详细地了解，建议还是去看看 <code>iface.go</code>，里面有接口实现的一些关键的细节。但是还是有一些东西被隐藏了起来， 导致我们无法知道我们 go 代码会是 <code>iface.go</code> 里面的哪一段代码实现的。</p> <blockquote><p>本文使用的源码版本： go 1.19。另外本文中提到的 <code>interface</code> 和 <code>接口</code> 是同一个东西。</p></blockquote> <h2 id="接口是什么"><a href="#接口是什么" class="header-anchor">#</a> 接口是什么？</h2> <blockquote><p>接口（<code>interface</code>）本质上是一种结构体。</p></blockquote> <p>我们先来看看下面的代码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// main.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">type</span> Flyable <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// go tool compile -N -S -l main.go</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> f1 <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token function">println</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token comment">// CALL    runtime.printeface(SB)</span>

   <span class="token keyword">var</span> f2 Flyable
   <span class="token function">println</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token comment">// CALL    runtime.printiface(SB)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>我们可以通过 <code>go tool compile -N -S -l main.go</code> 命令来生成 <code>main.go</code> 的伪汇编代码，生成的代码会很长，下面省略所有跟本文主题无关的代码：</p> <div class="language-asm line-numbers-mode"><pre class="language-text"><code>// main.go:10 =&gt; println(f1)
0x0029 00041 (main.go:10)  CALL  runtime.printeface(SB)
// main.go:13 =&gt; println(f2)
0x004f 00079 (main.go:13)  CALL  runtime.printiface(SB)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们从这段汇编代码中可以看到，我们 <code>println(f1)</code> 实际上是对 <code>runtime.printeface</code> 的调用，我们看看这个 <code>printeface</code> 方法：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">printeface</span><span class="token punctuation">(</span>e eface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>_type<span class="token punctuation">,</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们看到了，这个 <code>printeface</code> 接收的参数实际上是 <code>eface</code> 类型，而不是 <code>interface{}</code> 类型，我们再来看看 <code>println(f2)</code> 实际调用的 <code>runtime.printiface</code> 方法：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">printiface</span><span class="token punctuation">(</span>i iface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;(&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">.</span>tab<span class="token punctuation">,</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>也就是说 <code>interface{}</code> 类型在底层实际上是 <code>eface</code> 类型，而 <code>Flyable</code> 类型在底层实际上是 <code>iface</code> 类型。</strong></p> <p>这就是本文要讲述的内容，go 中的接口变量其实是用 <code>iface</code> 和 <code>eface</code> 这两个结构体来表示的：</p> <ul><li><code>iface</code> 表示某一个具体的接口（含有方法的接口）。</li> <li><code>eface</code> 表示一个空接口（<code>interface{}</code>）</li></ul> <p><img src="/images/go/interface/1.webp" alt="interface_5.png"></p> <h2 id="iface-和-eface-结构体"><a href="#iface-和-eface-结构体" class="header-anchor">#</a> iface 和 eface 结构体</h2> <p><code>iface</code> 和 <code>eface</code> 的结构体定义（<code>runtime/iface.go</code>）：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 非空接口（如：io.Reader）</span>
<span class="token keyword">type</span> iface <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   tab  <span class="token operator">*</span>itab          <span class="token comment">// 方法表</span>
   data unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 指向变量本身的指针</span>
<span class="token punctuation">}</span>

<span class="token comment">// 空接口（interface{}）</span>
<span class="token keyword">type</span> eface <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   _type <span class="token operator">*</span>_type         <span class="token comment">// 接口变量的类型</span>
   data  unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 指向变量本身的指针</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>go 底层的类型信息是使用 <code>_type</code> 结构体来存储的。</p></blockquote> <p>比如，我们有下面的代码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> Bird <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b Bird<span class="token punctuation">)</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Flyable <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   bird <span class="token operator">:=</span> Bird<span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">&quot;b1&quot;</span><span class="token punctuation">}</span>
   <span class="token keyword">var</span> efc <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> bird <span class="token comment">// efc 是 eface</span>
   <span class="token keyword">var</span> ifc Flyable <span class="token operator">=</span> bird <span class="token comment">// ifc 是 iface</span>

   <span class="token function">println</span><span class="token punctuation">(</span>efc<span class="token punctuation">)</span> <span class="token comment">// runtime.printeface</span>
   <span class="token function">println</span><span class="token punctuation">(</span>ifc<span class="token punctuation">)</span> <span class="token comment">// runtime.printiface</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在上面代码中，<code>efc</code> 是 <code>eface</code> 类型的变量，对应到 <code>eface</code> 结构体的话，<code>_type</code> 就是 <code>Bird</code> 这个类型本身，而 <code>data</code> 就是 <code>&amp;bird</code> 这个指针：</p> <p><img src="/images/go/interface/2.webp" alt="interface_6.png"></p> <p>类似的，<code>ifc</code> 是 <code>iface</code> 类型的变量，对应到 <code>iface</code> 结构体的话，<code>data</code> 也是 <code>&amp;bird</code> 这个指针：</p> <p><img src="/images/go/interface/3.webp" alt="interface_7.png"></p> <h2 id="type-是什么"><a href="#type-是什么" class="header-anchor">#</a> _type 是什么？</h2> <p>在 go 中，<code>_type</code> 是保存了变量类型的元数据的结构体，定义如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// _type 是 go 里面所有类型的一个抽象，里面包含 GC、反射、大小等需要的细节，</span>
<span class="token comment">// 它也决定了 data 如何解释和操作。</span>
<span class="token comment">// 里面包含了非常多信息：类型的大小、哈希、对齐及 kind 等信息</span>
<span class="token keyword">type</span> _type <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    size       <span class="token builtin">uintptr</span> <span class="token comment">// 数据类型共占用空间的大小</span>
    ptrdata    <span class="token builtin">uintptr</span> <span class="token comment">// 含有所有指针类型前缀大小</span>
    hash       <span class="token builtin">uint32</span>  <span class="token comment">// 类型 hash 值；避免在哈希表中计算</span>
    tflag      tflag   <span class="token comment">// 额外类型信息标志</span>
    align      <span class="token builtin">uint8</span>   <span class="token comment">// 该类型变量对齐方式</span>
    fieldAlign <span class="token builtin">uint8</span>   <span class="token comment">// 该类型结构体字段对齐方式</span>
    kind       <span class="token builtin">uint8</span>   <span class="token comment">// 类型编号</span>
    <span class="token comment">// 用于比较此类型对象的函数</span>
    equal <span class="token keyword">func</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span>
    <span class="token comment">// gc 相关数据</span>
    gcdata    <span class="token operator">*</span><span class="token builtin">byte</span>
    str       nameOff <span class="token comment">// 类型名字的偏移</span>
    ptrToThis typeOff
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这个 <code>_type</code> 结构体定义大家随便看看就好了，实际上，go 底层的类型表示也不是上面这个结构体这么简单。</p> <p><strong>但是，我们需要知道的一点是（与本文有关的信息），通过 <code>_type</code> 我们可以得到结构体里面所包含的方法这些信息。</strong> 具体我们可以看 <code>itab</code> 的 <code>init</code> 方法（<code>runtime/iface.go</code>），我们会看到如下几行：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>typ <span class="token operator">:=</span> m<span class="token punctuation">.</span>_type
x <span class="token operator">:=</span> typ<span class="token punctuation">.</span><span class="token function">uncommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 结构体类型</span>

nt <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>mcount<span class="token punctuation">)</span>   <span class="token comment">// 实际类型的方法数量</span>
<span class="token comment">// 实际类型的方法数组，数组元素为 method</span>
xmhdr <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">]</span>method<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>moff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>nt<span class="token punctuation">:</span>nt<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在底层，go 是通过 <code>_type</code> 里面 <code>uncommon</code> 返回的地址，加上一个偏移量（<code>x.moff</code>）来得到实际结构体类型的方法列表的。</p> <p>我们可以参考一下下图想象一下：</p> <p><img src="/images/go/interface/4.webp" alt="interface_8.png"></p> <h2 id="itab-是什么"><a href="#itab-是什么" class="header-anchor">#</a> itab 是什么？</h2> <p>我们从 <code>iface</code> 中可以看到，它包含了一个 <code>*itab</code> 类型的字段，我们看看这个 <code>itab</code> 的定义：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 编译器已知的 itab 布局</span>
<span class="token keyword">type</span> itab <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   inter <span class="token operator">*</span>interfacetype <span class="token comment">// 接口类型</span>
   _type <span class="token operator">*</span>_type
   hash  <span class="token builtin">uint32</span>
   <span class="token boolean">_</span>     <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
   fun   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span> <span class="token comment">// 变长数组. fun[0]==0 意味着 _type 没有实现 inter 这个接口</span>
<span class="token punctuation">}</span>

<span class="token comment">// 接口类型</span>
<span class="token comment">// 对应源代码：type xx interface {}</span>
<span class="token keyword">type</span> interfacetype <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    typ     _type     <span class="token comment">// 类型信息</span>
    pkgpath name      <span class="token comment">// 包路径</span>
    mhdr    <span class="token punctuation">[</span><span class="token punctuation">]</span>imethod <span class="token comment">// 接口的方法列表</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><blockquote><p>根据 <code>interfacetype</code> 我们可以得到关于接口所有方法的信息。同样的，通过 <code>_type</code> 也可以获取结构体类型的所有方法信息。</p></blockquote> <p>从定义上，我们可以看到 <code>itab</code> 跟 <code>*interfacetype</code> 和 <code>*_type</code> 有关，但实际上有什么关系从定义上其实不太能看得出来， 但是我们可以看它是怎么被使用的，现在，假设我们有如下代码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// i 在底层是一个 interfacetype 类型</span>
<span class="token keyword">type</span> i <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// t 底层会用 _type 来表示</span>
<span class="token comment">// t 里面有 A、B、C、D 方法</span>
<span class="token comment">// 因为实现了 i 中的所有方法，所以 t 实现了接口 i</span>
<span class="token keyword">type</span> t <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>下图描述了上面代码对应的 <code>itab</code> 生成的过程：</p> <p><img src="/images/go/interface/5.webp" alt="interface_9.png"></p> <p>说明：</p> <ul><li><code>itab</code> 里面的 <code>inter</code> 是接口类型的指针（比如通过 <code>type Reader interface{}</code> 这种形式定义的接口，记录的是这个类型本身的信息），这个接口类型本身定义了一系列的方法，如图中的 <code>i</code> 包含了 <code>A</code>、<code>C</code> 两个方法。</li> <li><code>_type</code> 是实际类型的指针，记录的是这个实际类型本身的信息，比如这个类型包含哪些方法。图中的 <code>i</code> 实现了 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code> 四个方法，因为实现了 <code>i</code> 的所有方法，所以说 <code>t</code> 实现了 <code>i</code> 接口。</li> <li>在底层做类型转换的时候，比如 <code>t</code> 转换为 <code>i</code> 的时候（<code>var v i = t{}</code>），会生成一个 <code>itab</code>，如果 <code>t</code> 没有实现 <code>i</code> 中的所有方法，那么生成的 <code>itab</code> 中不包含任何方法。</li> <li>如果 <code>t</code> 实现了 <code>i</code> 中的所有方法，那么生成的 <code>itab</code> 中包含了 <code>i</code> 中的所有方法指针，但是实际指向的方法是实际类型的方法（也就是指向的是 <code>t</code> 中的方法地址）</li> <li><code>mhdr</code> 就是 <code>itab</code> 中的方法表，里面的方法名就是接口的所有方法名，这个方法表中保存了实际类型（<code>t</code>）中同名方法的函数地址，通过这个地址就可以调用实际类型的方法了。</li></ul> <p>所以，我们有如下结论：</p> <ul><li><code>itab</code> 实际上定义了 <code>interfacetype</code> 和 <code>_type</code> 之间方法的交集。作用是什么呢？就是用来判断一个结构体是否实现某个接口的。</li> <li><code>itab</code> 包含了接口的所有方法，这里面的方法是实际类型的子集。</li> <li><code>itab</code> 里面的方法列表包含了实际类型的方法指针（也就是实际类型的方法的地址），通过这个地址可以对实际类型进行方法的调用。</li> <li><code>itab</code> 在实际类型没有实现接口的所有方法的时候，生成失败（失败的意思是，生成的 <code>itab</code> 里面的方法列表是空的，在底层实现上是用 <code>fun[0] = 0</code> 来表示）。</li></ul> <h2 id="生成的-itab-是怎么被使用的"><a href="#生成的-itab-是怎么被使用的" class="header-anchor">#</a> 生成的 itab 是怎么被使用的？</h2> <p>go 里面定义了一个全局变量 <code>itabTable</code>，用来缓存 <code>itab</code>，因为在判断某一个结构体是否实现了某一个接口的时候， 需要比较两者的方法集，如果结构体实现了接口的所有方法，那么就表明结构体实现了接口（这也就是生成 <code>itab</code> 的过程）。 如果在每一次做接口断言的时候都要做一遍这个比较，性能无疑会大大地降低，因此 go 就把这个比较得出的结果缓存起来，也就是 <code>itab</code>。 这样在下一次判断结构体是否实现了某一个接口的时候，就可以直接使用之前的 <code>itab</code>，性能也就得到提升了。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 表里面缓存了 itab</span>
itabTable     <span class="token operator">=</span> <span class="token operator">&amp;</span>itabTableInit
itabTableInit <span class="token operator">=</span> itabTableType<span class="token punctuation">{</span>size<span class="token punctuation">:</span> itabInitSize<span class="token punctuation">}</span>

<span class="token comment">// 全局的 itab 表</span>
<span class="token keyword">type</span> itabTableType <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    size    <span class="token builtin">uintptr</span>             <span class="token comment">// entries 的长度，2 的次方</span>
    count   <span class="token builtin">uintptr</span>             <span class="token comment">// 当前 entries 的数量</span>
    entries <span class="token punctuation">[</span>itabInitSize<span class="token punctuation">]</span><span class="token operator">*</span>itab <span class="token comment">// 保存 itab 的哈希表</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>itabTableType</code> 里面的 <code>entries</code> 是一个哈希表，在实际保存的时候，会用 <code>interfacetype</code> 和 <code>_type</code> 这两个生成一个哈希表的键。 也就是说，这个保存 <code>itab</code> 的缓存哈希表中，只要我们有 <code>interfacetype</code> 和 <code>_type</code> 这两个信息，就可以获取一个 <code>itab</code>。</p> <p>具体怎么使用，我们可以看看下面的例子：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> Flyable <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Runnable <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token boolean">_</span> Flyable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>Bird<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> Runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>Bird<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> Bird <span class="token keyword">struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b Bird<span class="token punctuation">)</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b Bird<span class="token punctuation">)</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">// GOOS=linux GOARCH=amd64 go tool compile -N -S -l main.go &gt; main.s</span>
<span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// f 的类型是 iface</span>
   <span class="token keyword">var</span> f Flyable <span class="token operator">=</span> Bird<span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token comment">// Flyable 转 Runnable 本质上是 iface 到 iface 的转换</span>
   f<span class="token punctuation">.</span><span class="token punctuation">(</span>Runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// CALL runtime.assertI2I(SB)</span>
   <span class="token comment">// 这个 switch 里面的类型断言本质上也是 iface 到 iface 的转换</span>
   <span class="token comment">// 但是 switch 里面的类型断言失败不会引发 panic</span>
   <span class="token keyword">switch</span> f<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> Flyable<span class="token punctuation">:</span> <span class="token comment">// CALL  runtime.assertI2I2(SB)</span>
   <span class="token keyword">case</span> Runnable<span class="token punctuation">:</span> <span class="token comment">// CALL runtime.assertI2I2(SB)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token punctuation">(</span>Runnable<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span> <span class="token comment">// CALL runtime.assertI2I2(SB)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// i 的类型是 eface</span>
   <span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> Bird<span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token comment">// i 转 Flyable 本质上是 eface 到 iface 的转换</span>
   i<span class="token punctuation">.</span><span class="token punctuation">(</span>Flyable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// CALL  runtime.assertE2I(SB)</span>
   <span class="token comment">// 这个 switch 里面的类型断言本质上也是 eface 到 iface 的转换</span>
   <span class="token comment">// 但是 switch 里面的类型断言失败不会引发 panic</span>
   <span class="token keyword">switch</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> Flyable<span class="token punctuation">:</span> <span class="token comment">// CALL  runtime.assertE2I2(SB)</span>
   <span class="token keyword">case</span> Runnable<span class="token punctuation">:</span> <span class="token comment">// CALL runtime.assertE2I2(SB)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span>Runnable<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span> <span class="token comment">// CALL runtime.assertE2I2(SB)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><p>我们对上面的代码生成伪汇编代码：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 go tool compile <span class="token parameter variable">-N</span> <span class="token parameter variable">-S</span> <span class="token parameter variable">-l</span> main.go <span class="token operator">&gt;</span> main.s
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后我们去查看 <code>main.s</code>，就会发现类型断言的代码，本质上是对 <code>runtime.assert*</code> 方法的调用（<code>assertI2I</code>、<code>assertI2I2</code>、<code>assertE2I</code>、<code>assertE2I2</code>）， 这几个方法名都是以 <code>assert</code> 开头的，<code>assert</code> 在编程语言中的含义是，判断后面的条件是否为 <code>true</code>，如果 <code>false</code> 则抛出异常或者其他中断程序执行的操作，为 <code>true</code> 则接着执行。 这里的用处就是，<strong>判断一个接口是否能够转换为另一个接口或者另一个类型</strong>。</p> <p>但在这里有点不太一样，这里有两个函数最后有个数字 <code>2</code> 的，表明了我们对接口的类型转换会有两种情况，我们上面的代码生成的汇编其实已经很清楚了， <strong>一种情况是直接断言，使用 <code>i.(T)</code> 这种形式，另外一种是在 <code>switch...case</code> 里面使用，</strong>。</p> <p>我们可以看看它们的源码，看看有什么不一样：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 直接根据 interfacetype/_type 获取 itab</span>
<span class="token keyword">func</span> <span class="token function">assertE2I</span><span class="token punctuation">(</span>inter <span class="token operator">*</span>interfacetype<span class="token punctuation">,</span> t <span class="token operator">*</span>_type<span class="token punctuation">)</span> <span class="token operator">*</span>itab <span class="token punctuation">{</span>
   <span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token comment">// 显式转换需要非nil接口值。</span>
      <span class="token function">panic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TypeAssertionError<span class="token punctuation">{</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>typ<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// getitab 的第三个参数是 false</span>
   <span class="token comment">// 表示 getiab 获取不到 itab 的时候需要 panic</span>
   <span class="token keyword">return</span> <span class="token function">getitab</span><span class="token punctuation">(</span>inter<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将 eface 转换为 iface</span>
<span class="token comment">// 因为 e 包含了 *_type</span>
<span class="token keyword">func</span> <span class="token function">assertE2I2</span><span class="token punctuation">(</span>inter <span class="token operator">*</span>interfacetype<span class="token punctuation">,</span> e eface<span class="token punctuation">)</span> <span class="token punctuation">(</span>r iface<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   t <span class="token operator">:=</span> e<span class="token punctuation">.</span>_type
   <span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// getitab 的第三个参数是 true</span>
   <span class="token comment">// 表示 getitab 获取不到 itab 的时候不需要 panic</span>
   tab <span class="token operator">:=</span> <span class="token function">getitab</span><span class="token punctuation">(</span>inter<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span> tab <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
   <span class="token punctuation">}</span>
   r<span class="token punctuation">.</span>tab <span class="token operator">=</span> tab
   r<span class="token punctuation">.</span>data <span class="token operator">=</span> e<span class="token punctuation">.</span>data
   <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p><code>getitab</code> 的源码后面会有。</p></blockquote> <p>从上面的代码可以看到，其实带 <code>2</code> 和不带 <code>2</code> 后缀的关键区别在于：<code>getitab</code> 的调用允不允许失败。 这有点类似于 <code>chan</code> 里面的 <code>select</code>，<code>chan</code> 的 <code>select</code> 语句中读写 <code>chan</code> 不会阻塞，而其他地方会阻塞。</p> <p><code>assertE2I2</code> 是用在 <code>switch...case</code> 中的，这个调用是允许失败的，因为我们还需要判断能否转换为其他类型； 又或者 <code>v, ok := i.(T)</code> 的时候，也是允许失败的，但是这种情况会返回第二个值给用户判断是否转换成功。 而直接使用类型断言的时候，如 <code>i.(T)</code> 这种，如果 <code>i</code> 不能转换为 <code>T</code> 类型，则直接 <code>panic</code>。</p> <p>对于 go 中的接口断言可以总结如下：</p> <ul><li><code>assertI2I</code> 用于将一个 <code>iface</code> 转换为另一个 <code>iface</code>，转换失败的时候<strong>会</strong> <code>panic</code></li> <li><code>assertI2I2</code> 用于将一个 <code>iface</code> 转换为另一个 <code>iface</code>，转换失败的时候<strong>不会</strong> <code>panic</code></li> <li><code>assertE2I</code> 用于将一个 <code>eface</code> 转换为另一个 <code>iface</code>，转换失败的时候<strong>会</strong> <code>panic</code></li> <li><code>assertE2I2</code> 用于将一个 <code>eface</code> 转换为另一个 <code>iface</code>，转换失败的时候<strong>不会</strong> <code>panic</code></li> <li><code>assert</code> 相关的方法后缀的 <code>I2I</code>、<code>E2E</code> 里面的 <code>I</code> 表示的是 <code>iface</code>，<code>E</code> 表示的是 <code>eface</code></li> <li>带 <code>2</code> 后缀的允许失败，用于 <code>v, ok := i.(T)</code> 或者 <code>switch x.(type) ... case</code> 中</li> <li>不带 <code>2</code> 后缀的不允许失败，用于 <code>i.(T)</code> 这种形式中</li></ul> <blockquote><p>当然，这里说的转换不是说直接转换，只是说，在转换的过程中会用到 assert* 方法。</p></blockquote> <p>如果我们足够细心，然后也去看了 <code>assertI2I</code> 和 <code>assertI2I2</code> 的源码，就会发现，这几个方法本质上都是， 通过 <code>interfacetype</code> 和 <code>_type</code> 来获取一个 <code>itab</code> 然后转换为另外一个 <code>itab</code> 或者 `iface。</p> <blockquote><p>同时，我们也应该注意到，上面的转换都是转换到 iface 而没有转换到 eface 的操作，这是因为，所有类型都可以转换为空接口（interface{}，也就是 eface）。根本就不需要断言。</p></blockquote> <p>上面的内容可以结合下图理解一下：</p> <p><img src="/images/go/interface/6.webp" alt="interface_10.png"></p> <h2 id="itab-关键方法的实现"><a href="#itab-关键方法的实现" class="header-anchor">#</a> itab 关键方法的实现</h2> <p>下面，让我们再来深入了解一下 <code>itab</code> 是怎么被创建出来的，以及是怎么保存到全局的哈希表中的。我们先来看看下图：</p> <p><img src="/images/go/interface/7.webp" alt="interface_11.png"></p> <p>这个图描述了 go 底层存储 <code>itab</code> 的方式：</p> <ul><li>通过一个 <code>itabTableType</code> 类型来存储所有的 <code>itab</code>。</li> <li>在调用 <code>getitab</code> 的时候，会先根据 <code>inter</code> 和 <code>_type</code> 计算出哈希值，然后从 <code>entries</code> 中查找是否存在，存在就返回对应的 <code>itab</code>，不存在则新建一个 <code>itab</code>。</li> <li>在调用 <code>itabAdd</code> 的时候，会将 <code>itab</code> 加入到 <code>itabTableType</code> 类型变量里面的 <code>entries</code> 中，其中 <code>entries</code> 里面的键是根据 <code>inter</code> 和 <code>_type</code> 做哈希运算得出的。</li></ul> <p><code>itab</code> 两个比较关键的方法：</p> <ul><li><code>getitab</code> 让我们可以通过 <code>interfacetype</code> 和 <code>_type</code> 获取一个 <code>itab</code>，会现在缓存中找，找不到会新建一个。</li> <li><code>itabAdd</code> 是在我们缓存找不到 <code>itab</code>，然后新建之后，将这个新建的 <code>itab</code> 加入到缓存的方法。</li></ul> <p><code>getitab</code> 方法的第三个参数 <code>canfail</code> 表示当前操作是否允许失败，上面说了，如果是用在 <code>switch...case</code> 或者 <code>v, ok := i.(T)</code> 这种是允许失败的。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 获取某一个类型的 itab（从 itabTable 中查找，键是 inter 和 _type 的哈希值）</span>
<span class="token comment">// 查找 interfacetype + _type 对应的 itab</span>
<span class="token comment">// 找不到就新增。</span>
<span class="token keyword">func</span> <span class="token function">getitab</span><span class="token punctuation">(</span>inter <span class="token operator">*</span>interfacetype<span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> canfail <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token operator">*</span>itab <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>mhdr<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;internal error - misuse of itab&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 不包含 Uncommon 信息的类型直接报错</span>
   <span class="token keyword">if</span> typ<span class="token punctuation">.</span>tflag<span class="token operator">&amp;</span>tflagUncommon <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> canfail <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token boolean">nil</span>
      <span class="token punctuation">}</span>
      name <span class="token operator">:=</span> inter<span class="token punctuation">.</span>typ<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>mhdr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
      <span class="token function">panic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TypeAssertionError<span class="token punctuation">{</span><span class="token boolean">nil</span><span class="token punctuation">,</span> typ<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>typ<span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 保存返回的 itab</span>
   <span class="token keyword">var</span> m <span class="token operator">*</span>itab

   <span class="token comment">// t 指向了 itabTable（全局的 itab 表）</span>
   t <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>itabTableType<span class="token punctuation">)</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Loadp</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabTable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 会先从全局 itab 表中查找，找到就直接返回</span>
   <span class="token keyword">if</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>inter<span class="token punctuation">,</span> typ<span class="token punctuation">)</span><span class="token punctuation">;</span> m <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token keyword">goto</span> finish
   <span class="token punctuation">}</span>

   <span class="token comment">// 没有找到，获取锁，再次查找。</span>
   <span class="token comment">// 找到则返回</span>
   <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
   <span class="token keyword">if</span> m <span class="token operator">=</span> itabTable<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>inter<span class="token punctuation">,</span> typ<span class="token punctuation">)</span><span class="token punctuation">;</span> m <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> finish
   <span class="token punctuation">}</span>

   <span class="token comment">// 没有在缓存中找到，新建一个 itab</span>
   m <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>itab<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">persistentalloc</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>itab<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>mhdr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>other_sys<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// itab 的</span>
   m<span class="token punctuation">.</span>inter <span class="token operator">=</span> inter
   m<span class="token punctuation">.</span>_type <span class="token operator">=</span> typ
   m<span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token comment">// itab 初始化</span>
   m<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 将新创建的 itab 加入到全局的 itabTable 中</span>
   <span class="token function">itabAdd</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
   <span class="token comment">// 释放锁</span>
   <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabLock<span class="token punctuation">)</span>
finish<span class="token punctuation">:</span>
   <span class="token comment">// == 0 表示没有任何方法</span>
   <span class="token comment">// 下面 != 0 表示有 inter 和 typ 有方法的交集</span>
   <span class="token keyword">if</span> m<span class="token punctuation">.</span>fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> m
   <span class="token punctuation">}</span>
   <span class="token comment">// 用在 switch x.(type) 中的时候，允许失败而不是直接 panic</span>
   <span class="token comment">// 但在 x.(Flyable).Fly() 这种场景会直接 panic</span>
   <span class="token keyword">if</span> canfail <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">nil</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 没有找到有方法的交集，panic</span>
   <span class="token function">panic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TypeAssertionError<span class="token punctuation">{</span>concrete<span class="token punctuation">:</span> typ<span class="token punctuation">,</span> asserted<span class="token punctuation">:</span> <span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>typ<span class="token punctuation">,</span> missingMethod<span class="token punctuation">:</span> m<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br></div></div><p><code>itabAdd</code> 将给定的 <code>itab</code> 添加到 <code>itab</code> 哈希表中（<code>itabTable</code>）。</p> <blockquote><p>注意：<code>itabAdd</code> 中在判断到哈希表的使用量超过 <code>75%</code> 的时候，会进行扩容，新的容量为旧容量的 2 倍。</p></blockquote> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 必须保持 itabLock。</span>
<span class="token keyword">func</span> <span class="token function">itabAdd</span><span class="token punctuation">(</span>m <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 正在分配内存的时候调用的话报错</span>
   <span class="token keyword">if</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>mallocing <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;malloc deadlock&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   t <span class="token operator">:=</span> itabTable
   <span class="token comment">// 容量已经超过 75% 的负载了，hash 表扩容</span>
   <span class="token keyword">if</span> t<span class="token punctuation">.</span>count <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token operator">*</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>size<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 75% load factor（实际上是：t.size *0.75）</span>
      <span class="token comment">// 扩展哈希表。原来 2 倍大小。</span>
      <span class="token comment">// 我们撒谎告诉 malloc 我们需要无指针内存，因为所有指向的值都不在堆中。</span>
      <span class="token comment">// 2 是 size 和 count 这两个字段需要的空间</span>
      t2 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>itabTableType<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">mallocgc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>t<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token operator">*</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      t2<span class="token punctuation">.</span>size <span class="token operator">=</span> t<span class="token punctuation">.</span>size <span class="token operator">*</span> <span class="token number">2</span>

      <span class="token comment">// 复制条目。</span>
      <span class="token comment">// 注意：在复制时，其他线程可能会查找itab，但找不到它。</span>
      <span class="token comment">// 没关系，然后它们会尝试获取itab锁，因此等待复制完成。</span>
      <span class="token function">iterate_itabs</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>add<span class="token punctuation">)</span>    <span class="token comment">// 遍历旧的 hash 表，复制函数指针到 t2 中</span>
      <span class="token keyword">if</span> t2<span class="token punctuation">.</span>count <span class="token operator">!=</span> t<span class="token punctuation">.</span>count <span class="token punctuation">{</span> <span class="token comment">// 复制出错</span>
         <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;mismatched count during itab table copy&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 发布新哈希表。使用原子写入：请参见 getitab 中的注释。</span>
      <span class="token comment">// 使用 t2 覆盖 itabTable</span>
      <span class="token function">atomicstorep</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>itabTable<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 使用新的 hash 表</span>
      <span class="token comment">// 因为 t 是局部变量，指向旧的地址，</span>
      <span class="token comment">// 但是扩容之后是新的地址了，所以现在需要将新的地址赋给 t</span>
      t <span class="token operator">=</span> itabTable
      <span class="token comment">// 注：旧的哈希表可以在此处进行GC。</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 将 itab 加入到全局哈希表</span>
   t<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>其实 <code>itabAdd</code> 的关键路径比较清晰，只是因为它是一个哈希表，所以里面在判断到当前 <code>itab</code> 的数量超过 <code>itabTable</code> 容量的 <code>75%</code> 的时候，会对 <code>itabTable</code> 进行 2 倍扩容。</p> <h2 id="根据-interfacetype-和-type-初始化-itab"><a href="#根据-interfacetype-和-type-初始化-itab" class="header-anchor">#</a> 根据 interfacetype 和 _type 初始化 itab</h2> <p>上面那个图我们说过，<code>itab</code> 本质上是 <code>interfacetype</code> 和 <code>_type</code> 方法的交集，这一节我们就来看看，<code>itab</code> 是怎么根据这两个类型来进行初始化的。</p> <p><code>itab</code> 的 <code>init</code> 方法实现：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// init 用 m.inter/m._type 对的所有代码指针填充 m.fun 数组。</span>
<span class="token comment">// 如果该类型不实现接口，它将 m.fun[0] 设置为 0 ，并返回缺少的接口函数的名称。</span>
<span class="token comment">// 可以在同一个m上多次调用，甚至同时调用。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>itab<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
   inter <span class="token operator">:=</span> m<span class="token punctuation">.</span>inter    <span class="token comment">// 接口</span>
   typ <span class="token operator">:=</span> m<span class="token punctuation">.</span>_type      <span class="token comment">// 实际的类型</span>
   x <span class="token operator">:=</span> typ<span class="token punctuation">.</span><span class="token function">uncommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token comment">// inter 和 typ 都具有按名称排序的方法，并且接口名称是唯一的，因此可以在锁定步骤中迭代这两个；</span>
   <span class="token comment">// 循环时间复杂度是 O(ni+nt)，不是 O(ni*nt)</span>
   ni <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>inter<span class="token punctuation">.</span>mhdr<span class="token punctuation">)</span> <span class="token comment">// 接口的方法数量</span>
   nt <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>mcount<span class="token punctuation">)</span>   <span class="token comment">// 实际类型的方法数量</span>
   <span class="token comment">// 实际类型的方法数组，数组元素为 method</span>
   xmhdr <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">]</span>method<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>moff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>nt<span class="token punctuation">:</span>nt<span class="token punctuation">]</span> <span class="token comment">// 大小无关紧要，因为下面的指针访问不会超出范围</span>
   j <span class="token operator">:=</span> <span class="token number">0</span>
   <span class="token comment">// 用来保存 inter/_type 对方法列表的数组，数组元素为 unsafe.Pointer（是实际类型方法的指针）</span>
   methods <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">]</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>ni<span class="token punctuation">:</span>ni<span class="token punctuation">]</span> <span class="token comment">// 保存 itab 方法的数组</span>
   <span class="token comment">// 第一个方法的指针</span>
   <span class="token keyword">var</span> fun0 unsafe<span class="token punctuation">.</span>Pointer
imethods<span class="token punctuation">:</span>
   <span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> ni<span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">{</span> <span class="token comment">// 接口方法遍历</span>
      i <span class="token operator">:=</span> <span class="token operator">&amp;</span>inter<span class="token punctuation">.</span>mhdr<span class="token punctuation">[</span>k<span class="token punctuation">]</span>                <span class="token comment">// i 是接口方法， imethod 类型</span>
      itype <span class="token operator">:=</span> inter<span class="token punctuation">.</span>typ<span class="token punctuation">.</span><span class="token function">typeOff</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>ityp<span class="token punctuation">)</span> <span class="token comment">// 接口的方法类型</span>
      name <span class="token operator">:=</span> inter<span class="token punctuation">.</span>typ<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment">// 接口的方法名称</span>
      iname <span class="token operator">:=</span> name<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment">// 接口的方法名</span>
      ipkg <span class="token operator">:=</span> name<span class="token punctuation">.</span><span class="token function">pkgPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment">// 接口的包路径</span>
      <span class="token keyword">if</span> ipkg <span class="token operator">==</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">{</span>
         ipkg <span class="token operator">=</span> inter<span class="token punctuation">.</span>pkgpath<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 根据接口方法查找实际类型的方法</span>
      <span class="token keyword">for</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nt<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span> <span class="token comment">// 实际类型的方法遍历</span>
         t <span class="token operator">:=</span> <span class="token operator">&amp;</span>xmhdr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>               <span class="token comment">// t 是实际类型的方法，method 类型</span>
         tname <span class="token operator">:=</span> typ<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 实际类型的方法名</span>
         <span class="token comment">// 比较接口的方法跟实际类型的方法是否一致</span>
         <span class="token keyword">if</span> typ<span class="token punctuation">.</span><span class="token function">typeOff</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>mtyp<span class="token punctuation">)</span> <span class="token operator">==</span> itype <span class="token operator">&amp;&amp;</span> tname<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> iname <span class="token punctuation">{</span>
            <span class="token comment">// 实际类型的包路径</span>
            pkgPath <span class="token operator">:=</span> tname<span class="token punctuation">.</span><span class="token function">pkgPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> pkgPath <span class="token operator">==</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">{</span>
               pkgPath <span class="token operator">=</span> typ<span class="token punctuation">.</span><span class="token function">nameOff</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>pkgpath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 如果是导出的方法</span>
            <span class="token comment">// 则保存到 itab 中</span>
            <span class="token keyword">if</span> tname<span class="token punctuation">.</span><span class="token function">isExported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> pkgPath <span class="token operator">==</span> ipkg <span class="token punctuation">{</span>
               <span class="token keyword">if</span> m <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                  ifn <span class="token operator">:=</span> typ<span class="token punctuation">.</span><span class="token function">textOff</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>ifn<span class="token punctuation">)</span> <span class="token comment">// 实际类型的方法指针（通过这个指针可以调用实际类型的方法）</span>
                  <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
                     <span class="token comment">// 第一个方法</span>
                     fun0 <span class="token operator">=</span> ifn <span class="token comment">// we'll set m.fun[0] at the end</span>
                  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                     methods<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> ifn
                  <span class="token punctuation">}</span>
               <span class="token punctuation">}</span>
               <span class="token comment">// 比较下一个方法</span>
               <span class="token keyword">continue</span> imethods
            <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 没有实现接口（实际类型没有实现 interface 中的任何一个方法）</span>
      m<span class="token punctuation">.</span>fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token keyword">return</span> iname <span class="token comment">// 返回缺失的方法名，返回值在类型断言失败的时候会需要提示用户</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 实现了接口</span>
   m<span class="token punctuation">.</span>fun<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>fun0<span class="token punctuation">)</span>
   <span class="token keyword">return</span> <span class="token string">&quot;&quot;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><h2 id="接口断言过程总览-类型转换的关键"><a href="#接口断言过程总览-类型转换的关键" class="header-anchor">#</a> 接口断言过程总览（类型转换的关键）</h2> <p>具体来说有四种情况，对应上面提到的 <code>runtime.assert*</code> 方法：</p> <ul><li>实际类型转换到 <code>iface</code></li> <li><code>iface</code> 转换到另一个 <code>iface</code></li> <li>实际类型转换到 <code>eface</code></li> <li><code>eface</code> 转换到 <code>iface</code></li></ul> <blockquote><p>这其中的关键是 <code>interfacetype</code> + <code>_type</code> 可以生成一个 <code>itab</code>。</p></blockquote> <p>上面的内容可能有点混乱，让人摸不着头脑，但是我们通过上面的讲述，相信已经了解了 go 接口中底层的一些实现细节，现在，就让我们重新来捋一下，看看 go 接口到底是怎么实现的：</p> <p>首先，希望我们可以达成的一个共识就是，<strong>go 的接口断言本质上是类型转换，<code>switch...case</code> 里面或 <code>v, ok := i.(T)</code> 允许转换失败，而 <code>i.(T).xx()</code> 这种不允许转换失败，转换失败的时候会 <code>panic</code></strong>。</p> <p>接着，我们就可以通过下图来了解 go 里面的接口整体的实现原理了（还是以上面的代码作为例子）：</p> <ol><li>将结构体赋值给接口类型：<code>var f Flyable = Bird{}</code></li></ol> <p><img src="/images/go/interface/8.webp" alt="interface_12.png"></p> <p>在这个赋值过程中，创建了一个 <code>iface</code> 类型的变量，这个变量中的 <code>itab</code> 的方法表只包含了 <code>Flyable</code> 定义的方法。</p> <ol><li><code>iface</code> 转另一个 <code>iface</code>:</li></ol> <ul><li><code>f.(Runnable)</code></li> <li><code>_, ok := f.(Runnable)</code></li> <li><code>switch f.(type)</code> 里面的 <code>case</code> 是 <code>Runnable</code></li></ul> <p><img src="/images/go/interface/9.webp" alt="interface_13.png"></p> <p>在这个断言过程中，会将 <code>Flyable</code> 转换为 <code>Runnable</code>，本质上是一个 <code>iface</code> 转换到另一个 <code>iface</code>。但是有个不同之处在于， 两个 <code>iface</code> 里面的方法列表是不一样的，只包含了当前 <code>interfacetype</code> 里面定义的方法。</p> <ol><li>将结构体赋值给空接口：<code>var i interface{} = Bird{}</code></li></ol> <p>在这个过程中，创建了一个 <code>eface</code> 类型的变量，这个 <code>eface</code> 里面只包含了类型信息以及实际的 <code>Bird</code> 结构体实例。</p> <p><img src="/images/go/interface/10.webp" alt="interface_14.png"></p> <ol><li><code>eface</code> 转换到 <code>iface</code></li></ol> <ul><li><code>i.(Flyable)</code></li> <li><code>_, ok := i.(Runnable)</code></li> <li><code>switch i.(type)</code> 里面的 <code>case</code> 是 <code>Flyable</code></li></ul> <p>因为 <code>_type</code> 包含了 <code>Bird</code> 类型的所有信息，而 <code>data</code> 包含了 <code>Bird</code> 实例的值，所以这个转换是可行的。</p> <p><img src="/images/go/interface/11.webp" alt="interface_15.png"></p> <h2 id="panicdottypei-与-panicdottypee"><a href="#panicdottypei-与-panicdottypee" class="header-anchor">#</a> panicdottypeI 与 panicdottypeE</h2> <p>从前面的几个小节，我们知道，go 的 <code>iface</code> 类型转换使用的是 <code>runtime.assert*</code> 几个方法，还有另外一种情况就是， 在编译期间编译器就已经知道了无法转换成功的情况，比如下面的代码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> Flyable <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Cat <span class="token keyword">struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Cat<span class="token punctuation">)</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Cat<span class="token punctuation">)</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">// GOOS=linux GOARCH=amd64 go tool compile -N -S -l main.go &gt; main.s</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> b <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// CALL    runtime.panicdottypeE(SB)</span>

   <span class="token keyword">var</span> c Flyable <span class="token operator">=</span> <span class="token operator">&amp;</span>Cat<span class="token punctuation">{</span><span class="token punctuation">}</span>
   c<span class="token punctuation">.</span><span class="token punctuation">(</span>Cat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// CALL runtime.panicdottypeI(SB)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>上面的两个转换都是错误的，第一个 <code>b.(int)</code> 尝试将 <code>nil</code> 转换为 <code>int</code> 类型，第二个尝试将 <code>*Cat</code> 类型转换为 <code>Cat</code> 类型， 这两个错误的类型转换都在编译期可以发现，因此它们生成的汇编代码调用的是 <code>runtime.panicdottypeE</code> 和 <code>runtime.panicdottypeI</code> 方法：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 在执行 e.(T) 转换时如果转换失败，则调用 panicdottypeE</span>
<span class="token comment">// have：我们的动态类型。</span>
<span class="token comment">// want：我们试图转换为的静态类型。</span>
<span class="token comment">// iface：我们正在转换的静态类型。</span>
<span class="token comment">// 转换的过程：尝试将 iface 的 have 转换为 want 失败了。</span>
<span class="token comment">// 不是调用方法的时候的失败。</span>
<span class="token keyword">func</span> <span class="token function">panicdottypeE</span><span class="token punctuation">(</span>have<span class="token punctuation">,</span> want<span class="token punctuation">,</span> iface <span class="token operator">*</span>_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">panic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TypeAssertionError<span class="token punctuation">{</span>iface<span class="token punctuation">,</span> have<span class="token punctuation">,</span> want<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 当执行 i.(T) 转换并且转换失败时，调用 panicdottypeI</span>
<span class="token comment">// 跟 panicdottypeE 参数相同，但是 hava 是动态的 itab 类型</span>
<span class="token keyword">func</span> <span class="token function">panicdottypeI</span><span class="token punctuation">(</span>have <span class="token operator">*</span>itab<span class="token punctuation">,</span> want<span class="token punctuation">,</span> iface <span class="token operator">*</span>_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> t <span class="token operator">*</span>_type
   <span class="token keyword">if</span> have <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      t <span class="token operator">=</span> have<span class="token punctuation">.</span>_type
   <span class="token punctuation">}</span>
   <span class="token function">panicdottypeE</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> want<span class="token punctuation">,</span> iface<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这两个方法都是引发一个 <code>panic</code>，因为我们的类型转换失败了：</p> <p><img src="/images/go/interface/12.webp" alt="interface_16.png"></p> <h2 id="iface-和-eface-里面的-data-是怎么来的"><a href="#iface-和-eface-里面的-data-是怎么来的" class="header-anchor">#</a> iface 和 eface 里面的 data 是怎么来的？</h2> <p>我们先看看下面的代码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> Bird <span class="token keyword">struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b Bird<span class="token punctuation">)</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Flyable <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// GOOS=linux GOARCH=amd64 go tool compile -N -S -l main.go &gt; main.s</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   bird <span class="token operator">:=</span> Bird<span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">var</span> efc <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> bird <span class="token comment">// CALL runtime.convT(SB)</span>
   <span class="token keyword">var</span> ifc Flyable <span class="token operator">=</span> bird     <span class="token comment">// CALL runtime.convT(SB)</span>
   <span class="token function">println</span><span class="token punctuation">(</span>efc<span class="token punctuation">,</span> ifc<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>我们生成伪汇编代码发现，里面将结构体变量赋值给接口类型变量的时候，实际上是调用了 <code>convT</code> 方法。</p> <h2 id="convt-方法"><a href="#convt-方法" class="header-anchor">#</a> convT* 方法</h2> <p><code>iface</code> 里面还包含了几个 <code>conv*</code> 前缀的函数，在我们将某一具体类型的值赋值给接口类型的时候，go 底层会将具体类型的值通过 <code>conv*</code> 函数转换为 <code>iface</code> 里面的 <code>data</code> 指针：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// convT 将 v 指向的 t 类型的值转换为可以用作接口值的第二个字的指针（接口的第二个字是指向 data 的指针）。</span>
<span class="token comment">// data(Pointer) =&gt; 指向 interface 第 2 个字的 Pointer</span>
<span class="token keyword">func</span> <span class="token function">convT</span><span class="token punctuation">(</span>t <span class="token operator">*</span>_type<span class="token punctuation">,</span> v unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
   <span class="token comment">// ... 其他代码</span>
   <span class="token comment">// 分配 _type 类型所需要的内存</span>
   x <span class="token operator">:=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>size<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
   <span class="token comment">// 将 v 指向的值复制到刚刚分配的内存上</span>
   <span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> x<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
   <span class="token keyword">return</span> x
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们发现，在这个过程，实际上是将值复制了一份：</p> <p><img src="/images/go/interface/13.webp" alt="interface_17.png"></p> <p><code>iface.go</code> 里面还有将无符号值转换为 <code>data</code> 指针的函数，但是还不知道在什么地方会用到这些方法，如：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 转换 uint16 类型值为 interface 里面 data 的指针。</span>
<span class="token comment">// 如果是 0～255 的整数，返回指向 staticuint64s 数组里面对应下标的指针。</span>
<span class="token comment">// 否则，分配新的内存地址。</span>
<span class="token keyword">func</span> <span class="token function">convT16</span><span class="token punctuation">(</span>val <span class="token builtin">uint16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果小于 256，则使用共享的内存地址</span>
   <span class="token keyword">if</span> val <span class="token operator">&lt;</span> <span class="token function">uint16</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>staticuint64s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      x <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>staticuint64s<span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> goarch<span class="token punctuation">.</span>BigEndian <span class="token punctuation">{</span>
         x <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 否则，分配新的内存</span>
      x <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> uint16Type<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
      <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uint16</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> val
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>个人猜测，仅仅代表个人猜测，在整数赋值给 <code>iface</code> 或者 <code>eface</code> 的时候会调用这类方法。不管调不调用，我们依然可以看看它的设计，因为有些值得学习的地方：</p> <p><code>staticuint64s</code> 是一个全局整型数组，里面存储的是 <code>0~255</code> 的整数。上面的代码可以表示为下图：</p> <p><img src="/images/go/interface/14.webp" alt="interface_18.png"></p> <p>这个函数跟上面的 <code>convT</code> 的不同之处在于，它在判断整数如果小于 <code>256</code> 的时候，则使用的是 <code>staticuint64s</code> 数组里面对应下标的地址。 为什么这样做呢？本质上是为了节省内存，因为对于数字来说，其实除了值本身，没有包含其他的信息了，所以如果对于每一个整数都分配新的内存来保存， 无疑会造成浪费。按 <code>convT16</code> 里面的实现方式，对于 <code>0~255</code> 之间的整数，如果需要给它们分配内存，就可以使用同一个指针（指向 <code>staticuint64s[]</code> 数组中元素的地址）。</p> <blockquote><p>这实际上是享元模式。</p></blockquote> <h3 id="java-里面的小整数享元模式"><a href="#java-里面的小整数享元模式" class="header-anchor">#</a> Java 里面的小整数享元模式</h3> <p>go 里使用 <code>staticuint64s</code> 的方式，其实在 Java 里面也有类似的实现，Java 中对于小整数也是使用了享元模式， 这样在装箱的时候，就不用分配新的内存了，就可以使用共享的一块内存了，当然，某一个整数能节省的内存非常有限，如果需要分配内存的小整数非常大，那么节省下来的内存就非常客观了。 当然，也不只是能节省内存这唯一的优点，从另一方面说，它也节省了垃圾回收器回收内存的开销，因为不需要管理那么多内存。</p> <p>我们来看看 Java 中的例子：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> k1 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> k2 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k1 <span class="token operator">==</span> k2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

        <span class="token class-name">Integer</span> k10 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> k20 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k10 <span class="token operator">==</span> k20<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k10<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k20<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Java 里面有点不一样，它是对 <code>-128~127</code> 范围内的整数做了享元模式的处理，而 go 里面是 <code>0~255</code>。</p> <p>上面的代码中，当我们使用 <code>==</code> 来比较 <code>Integer</code> 的时候，值相等的两个数，在 <code>-128~127</code> 的范围的时候，返回的是 <code>true</code>，超出这个范围的时候比较返回的是 <code>false</code>。 这是因为在 <code>-128~127</code> 的时候，值相等的两个数字指向了相同的内存地址，超出这个范围的时候，值相等的两个数指向了不同的地址。</p> <p>Java 的详细实现可以看 <code>java.lang.Integer.IntegerCache</code>。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>go 的的接口（<code>interface</code>）本质上是一种结构体，底册实现是 <code>iface</code> 和 <code>eface</code>，<code>iface</code> 表示我们通过 <code>type i interface{}</code> 定义的接口，而 <code>eface</code> 表示 <code>interface{}/any</code>，也就是空接口。</li> <li><code>iface</code> 里面保存的 <code>itab</code> 中保存了具体类型的方法指针列表，<code>data</code> 保存了具体类型值的内存地址。</li> <li><code>eface</code> 里面保存的 <code>_type</code> 包含了具体类型的所有信息，<code>data</code> 保存了具体类型值的内存地址。</li> <li><code>itab</code> 是底层保存接口类型跟具体类型方法交集的结构体，如果具体类型实现了接口的所有方法，那么这个 <code>itab</code> 里面的保存有指向具体类型方法的指针。如果具体类型没有实现接口的全部方法，那么 <code>itab</code> 中的不会保存任何方法的指针（从 <code>itab</code> 的作用上看，我们可以看作是一个空的 <code>itab</code>）。</li> <li>不管 <code>itab</code> 的方法列表是否为空，<code>interfacetype</code> 和 <code>_type</code> 比较之后生成的 <code>itab</code> 会缓存下来，在后续比较的时候可以直接使用缓存。</li> <li><code>_type</code> 是 go 底层用来表示某一个类型的结构体，包含了类型所需空间大小等信息。</li> <li>类型断言 <code>i.(T)</code> 本质上是 <code>iface</code> 到 <code>iface</code> 的转换，或者是 <code>eface</code> 到 <code>iface</code> 的转换，如果没有第二个返回值，那么转换失败的时候会引发 <code>panic</code>。</li> <li><code>switch i.(type) { case ...}</code> 本质上也是 <code>iface</code> 或 <code>eface</code> 到 <code>iface</code> 的转换，但是转换失败的时候不会引发 <code>panic</code>。</li> <li>全局的保存 <code>itab</code> 的缓存结构体，底层是使用了一个哈希表来保存 <code>itab</code> 的，在哈希表使用超过 <code>75%</code> 的时候，会触发扩容，新的哈希表容量为旧的 <code>2</code> 倍。</li> <li><code>staticuint64s</code> 使用了享元模式，Java 中也有类似的实现。</li></ul></div></div> <div class="page-slot page-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script></br><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="auto"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="7043271566"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Golang" title="标签">#Golang</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/17/2023</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/golang/go-context/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">小白也能看懂的context包详解：从入门到精通</div></a> <a href="/pages/golang/go-chan/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">深入理解 go chan</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/golang/go-context/" class="prev">小白也能看懂的context包详解：从入门到精通</a></span> <span class="next"><a href="/pages/golang/go-chan/">深入理解 go chan</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/mosquito-config-ws/"><div>
            mosquito配置ws协议
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/pip-download-offline/"><div>
            Pip包的离线下载和安装
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/favorites/sd/"><div>
            stable diffusion 相关收藏
            <!----></div></a> <span class="date">02-24</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/moxiaolong" title="Star我" target="_blank" class="iconfont icon-github"></a><a href="http://music.163.com/playlist?id=8444337" title="有品位的歌单" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2024
    <span>Dra-M</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bc3c2a75.js" defer></script><script src="/assets/js/2.472001a0.js" defer></script><script src="/assets/js/35.bb95ae18.js" defer></script>
  </body>
</html>
