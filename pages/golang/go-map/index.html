<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>go map 设计与实现 | Dra-M</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/logo.webp">
    <link rel="manifest" href="/manifest.json">
    <script data-ad-client="ca-pub-8621788234752924" defer="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924" crossorigin="anonymous"></script>
    <meta name="description" content="一些技术(前端、后端、运维)相关的经验、随想、资源收藏，和一些哲学随想。">
    <meta name="keywords" content="开发技术,哲学,DragonMo,Dra-M,莫小龙">
    <meta name="theme-color" content="#7b074b">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <link rel="preload" href="/assets/css/0.styles.8ee39092.css" as="style"><link rel="preload" href="/assets/js/app.bc3c2a75.js" as="script"><link rel="preload" href="/assets/js/2.472001a0.js" as="script"><link rel="preload" href="/assets/js/32.67d8d455.js" as="script"><link rel="prefetch" href="/assets/js/10.da818c35.js"><link rel="prefetch" href="/assets/js/100.c9dc513a.js"><link rel="prefetch" href="/assets/js/101.f3685f69.js"><link rel="prefetch" href="/assets/js/102.98577fde.js"><link rel="prefetch" href="/assets/js/103.401885da.js"><link rel="prefetch" href="/assets/js/104.5ca2a2ba.js"><link rel="prefetch" href="/assets/js/105.896bd937.js"><link rel="prefetch" href="/assets/js/106.199efe2c.js"><link rel="prefetch" href="/assets/js/107.206ba497.js"><link rel="prefetch" href="/assets/js/108.c1eb4655.js"><link rel="prefetch" href="/assets/js/109.221866e5.js"><link rel="prefetch" href="/assets/js/11.a6aff4f5.js"><link rel="prefetch" href="/assets/js/110.e3239981.js"><link rel="prefetch" href="/assets/js/111.ef06b5a1.js"><link rel="prefetch" href="/assets/js/112.ccf225d6.js"><link rel="prefetch" href="/assets/js/113.8d8640b2.js"><link rel="prefetch" href="/assets/js/114.056f749a.js"><link rel="prefetch" href="/assets/js/115.ed35567d.js"><link rel="prefetch" href="/assets/js/116.29426a1f.js"><link rel="prefetch" href="/assets/js/117.86847b2b.js"><link rel="prefetch" href="/assets/js/118.885246c5.js"><link rel="prefetch" href="/assets/js/119.6b04ff26.js"><link rel="prefetch" href="/assets/js/12.dd3a474e.js"><link rel="prefetch" href="/assets/js/120.99542ea6.js"><link rel="prefetch" href="/assets/js/121.c89b2199.js"><link rel="prefetch" href="/assets/js/122.b4c96f13.js"><link rel="prefetch" href="/assets/js/123.e74abe64.js"><link rel="prefetch" href="/assets/js/124.5479e5ef.js"><link rel="prefetch" href="/assets/js/125.47f5d91e.js"><link rel="prefetch" href="/assets/js/126.2eda5054.js"><link rel="prefetch" href="/assets/js/127.fbf8b987.js"><link rel="prefetch" href="/assets/js/128.3bb898fe.js"><link rel="prefetch" href="/assets/js/129.59014c61.js"><link rel="prefetch" href="/assets/js/13.2d318d3d.js"><link rel="prefetch" href="/assets/js/130.b5701dcd.js"><link rel="prefetch" href="/assets/js/131.af42802d.js"><link rel="prefetch" href="/assets/js/132.a0a52815.js"><link rel="prefetch" href="/assets/js/133.c7f6fcd9.js"><link rel="prefetch" href="/assets/js/134.1fa00d40.js"><link rel="prefetch" href="/assets/js/135.1c93b5ec.js"><link rel="prefetch" href="/assets/js/136.ce22005d.js"><link rel="prefetch" href="/assets/js/137.d689e32c.js"><link rel="prefetch" href="/assets/js/138.52557618.js"><link rel="prefetch" href="/assets/js/139.5576ce4a.js"><link rel="prefetch" href="/assets/js/14.41100292.js"><link rel="prefetch" href="/assets/js/140.3becc2ed.js"><link rel="prefetch" href="/assets/js/141.60103e1a.js"><link rel="prefetch" href="/assets/js/142.f44d458d.js"><link rel="prefetch" href="/assets/js/143.5a60f54e.js"><link rel="prefetch" href="/assets/js/144.ce362fab.js"><link rel="prefetch" href="/assets/js/145.f4d3209c.js"><link rel="prefetch" href="/assets/js/146.f90aee50.js"><link rel="prefetch" href="/assets/js/15.daabeb64.js"><link rel="prefetch" href="/assets/js/16.a4a3b21c.js"><link rel="prefetch" href="/assets/js/17.8b6cce9b.js"><link rel="prefetch" href="/assets/js/18.60b289d4.js"><link rel="prefetch" href="/assets/js/19.0c18504f.js"><link rel="prefetch" href="/assets/js/20.7a975e23.js"><link rel="prefetch" href="/assets/js/21.3329c224.js"><link rel="prefetch" href="/assets/js/22.5df3725f.js"><link rel="prefetch" href="/assets/js/23.1e2b6c8a.js"><link rel="prefetch" href="/assets/js/24.aac0154b.js"><link rel="prefetch" href="/assets/js/25.b26ee63b.js"><link rel="prefetch" href="/assets/js/26.6b63d3fb.js"><link rel="prefetch" href="/assets/js/27.8b487354.js"><link rel="prefetch" href="/assets/js/28.731619d6.js"><link rel="prefetch" href="/assets/js/29.4fe59357.js"><link rel="prefetch" href="/assets/js/3.6dd7c6e7.js"><link rel="prefetch" href="/assets/js/30.a93d8117.js"><link rel="prefetch" href="/assets/js/31.42cc0c6c.js"><link rel="prefetch" href="/assets/js/33.da390ef3.js"><link rel="prefetch" href="/assets/js/34.47f5bc34.js"><link rel="prefetch" href="/assets/js/35.bb95ae18.js"><link rel="prefetch" href="/assets/js/36.79ce5ff9.js"><link rel="prefetch" href="/assets/js/37.e48e5b35.js"><link rel="prefetch" href="/assets/js/38.05c111ca.js"><link rel="prefetch" href="/assets/js/39.a9c4a557.js"><link rel="prefetch" href="/assets/js/4.76079b7d.js"><link rel="prefetch" href="/assets/js/40.45a45204.js"><link rel="prefetch" href="/assets/js/41.978ccffc.js"><link rel="prefetch" href="/assets/js/42.895064c8.js"><link rel="prefetch" href="/assets/js/43.c9b2330d.js"><link rel="prefetch" href="/assets/js/44.114f4169.js"><link rel="prefetch" href="/assets/js/45.5a1432cf.js"><link rel="prefetch" href="/assets/js/46.cce4db9a.js"><link rel="prefetch" href="/assets/js/47.b9ba2714.js"><link rel="prefetch" href="/assets/js/48.2e84c7f6.js"><link rel="prefetch" href="/assets/js/49.77f31886.js"><link rel="prefetch" href="/assets/js/5.13679220.js"><link rel="prefetch" href="/assets/js/50.70b8a00f.js"><link rel="prefetch" href="/assets/js/51.8f3d4e26.js"><link rel="prefetch" href="/assets/js/52.a0dff1b5.js"><link rel="prefetch" href="/assets/js/53.1a5d0aa9.js"><link rel="prefetch" href="/assets/js/54.d9b622f7.js"><link rel="prefetch" href="/assets/js/55.a078dc68.js"><link rel="prefetch" href="/assets/js/56.5a331510.js"><link rel="prefetch" href="/assets/js/57.5bec8258.js"><link rel="prefetch" href="/assets/js/58.21fe4b06.js"><link rel="prefetch" href="/assets/js/59.53211a94.js"><link rel="prefetch" href="/assets/js/6.738f6e32.js"><link rel="prefetch" href="/assets/js/60.1d1893dd.js"><link rel="prefetch" href="/assets/js/61.2dd0ba1c.js"><link rel="prefetch" href="/assets/js/62.4df81247.js"><link rel="prefetch" href="/assets/js/63.e7645407.js"><link rel="prefetch" href="/assets/js/64.c1510d68.js"><link rel="prefetch" href="/assets/js/65.e80f3f86.js"><link rel="prefetch" href="/assets/js/66.705d839b.js"><link rel="prefetch" href="/assets/js/67.852e9ce9.js"><link rel="prefetch" href="/assets/js/68.67fbda7f.js"><link rel="prefetch" href="/assets/js/69.7a78efb2.js"><link rel="prefetch" href="/assets/js/7.48b86259.js"><link rel="prefetch" href="/assets/js/70.9fc82048.js"><link rel="prefetch" href="/assets/js/71.ab52b5cf.js"><link rel="prefetch" href="/assets/js/72.e7c7a340.js"><link rel="prefetch" href="/assets/js/73.539e40a1.js"><link rel="prefetch" href="/assets/js/74.598221c8.js"><link rel="prefetch" href="/assets/js/75.876e901b.js"><link rel="prefetch" href="/assets/js/76.42349440.js"><link rel="prefetch" href="/assets/js/77.5834f7c5.js"><link rel="prefetch" href="/assets/js/78.78c797f4.js"><link rel="prefetch" href="/assets/js/79.5d0d35ae.js"><link rel="prefetch" href="/assets/js/8.10c02f71.js"><link rel="prefetch" href="/assets/js/80.e7bc8390.js"><link rel="prefetch" href="/assets/js/81.e4e4f6a8.js"><link rel="prefetch" href="/assets/js/82.98057949.js"><link rel="prefetch" href="/assets/js/83.ad7dd690.js"><link rel="prefetch" href="/assets/js/84.0f7a664d.js"><link rel="prefetch" href="/assets/js/85.378369eb.js"><link rel="prefetch" href="/assets/js/86.01ead6d0.js"><link rel="prefetch" href="/assets/js/87.70598ba5.js"><link rel="prefetch" href="/assets/js/88.600910d8.js"><link rel="prefetch" href="/assets/js/89.c783c1e2.js"><link rel="prefetch" href="/assets/js/9.4b59881c.js"><link rel="prefetch" href="/assets/js/90.85995a12.js"><link rel="prefetch" href="/assets/js/91.21e9dbf9.js"><link rel="prefetch" href="/assets/js/92.8fc80426.js"><link rel="prefetch" href="/assets/js/93.6d7adcc8.js"><link rel="prefetch" href="/assets/js/94.6147d1d9.js"><link rel="prefetch" href="/assets/js/95.61c3d1ab.js"><link rel="prefetch" href="/assets/js/96.1dc4b4c8.js"><link rel="prefetch" href="/assets/js/97.c4c52395.js"><link rel="prefetch" href="/assets/js/98.b78d3e0f.js"><link rel="prefetch" href="/assets/js/99.f1c7ba9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ee39092.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.webp" alt="Dra-M" class="logo"> <span class="site-name can-hide">Dra-M</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=975425198&amp;s=640"> <div class="blogger-info"><h3>莫小龙</h3> <span>保持理智，相信未来。</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Golang</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/golang-gitlab-ssh/" class="sidebar-link">GitLab私服+Go Modules踩坑经验（SSH自定义端口）</a></li><li><a href="/pages/gin/middle/" class="sidebar-link">【代码片段】我使用的Gin中间处理器（自定义异常处理、日志打印、traceId、跨域配置）</a></li><li><a href="/pages/java-to-golang/value-and-reference/" class="sidebar-link">【Java转Go】如何理解Go中的值类型、引用类型、nil</a></li><li><a href="/pages/java-to-golang/oop/" class="sidebar-link">【Java转Go】如何理解面向对象，怎么把Golang用成面向对象的样子</a></li><li><a href="/pages/golang/gmp/" class="sidebar-link">Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="/pages/golang/go-gmp-status/" class="sidebar-link">Go中GMP有哪些状态？</a></li><li><a href="/pages/golang/go-gc/" class="sidebar-link">一文搞懂go gc垃圾回收原理</a></li><li><a href="/pages/golang/go-block/" class="sidebar-link">Go什么时候发生阻塞？阻塞时，调度器会怎么做？</a></li><li><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/" class="sidebar-link">Go netpoller 原生网络模型之源码全面揭秘</a></li><li><a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="sidebar-link">Goroutine 泄露 - 被遗忘的发送者</a></li><li><a href="/pages/golang/go-map/" aria-current="page" class="active sidebar-link">go map 设计与实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#哈希表基本操作" class="sidebar-link">哈希表基本操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#哈希表的写入" class="sidebar-link">哈希表的写入</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#哈希表的读取" class="sidebar-link">哈希表的读取</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#哈希表的修改" class="sidebar-link">哈希表的修改</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#哈希表的删除" class="sidebar-link">哈希表的删除</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#哈希表的高效之处" class="sidebar-link">哈希表的高效之处</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#哈希冲突解决方法" class="sidebar-link">哈希冲突解决方法</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#哈希扩容" class="sidebar-link">哈希扩容</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#哈希表总元素个数过多导致的扩容" class="sidebar-link">哈希表总元素个数过多导致的扩容</a></li><li class="sidebar-sub-header level4"><a href="/pages/golang/go-map/#go-map-的负载因子" class="sidebar-link">go map 的负载因子</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#哈希冲突链上元素太少导致的扩容" class="sidebar-link">哈希冲突链上元素太少导致的扩容</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#go-map-概述" class="sidebar-link">go map 概述</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#go-map-的整体模型" class="sidebar-link">go map 的整体模型</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#go-map-相关数据结构" class="sidebar-link">go map 相关数据结构</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#bmap-桶-源码剖析" class="sidebar-link">bmap（桶）源码剖析</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#map-的创建的实现" class="sidebar-link">map 的创建的实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#makemap-实现" class="sidebar-link">makemap 实现</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#overloadfactor-实现" class="sidebar-link">overLoadFactor 实现</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#makebucketarray-实现" class="sidebar-link">makeBucketArray 实现</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#map-定位-key-的实现" class="sidebar-link">map 定位 key 的实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#map-读取数据的实现" class="sidebar-link">map 读取数据的实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#mapaccessk-的查找步骤" class="sidebar-link">mapaccessK 的查找步骤</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#mapaccessk-的实现" class="sidebar-link">mapaccessK 的实现</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#mapaccessk-关键代码" class="sidebar-link">mapaccessK 关键代码</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#map-写入和修改的设计与实现" class="sidebar-link">map 写入和修改的设计与实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#mapassign-的实现步骤" class="sidebar-link">mapassign 的实现步骤</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#mapassign-图解" class="sidebar-link">mapassign 图解</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#mapassign-源码剖析" class="sidebar-link">mapassign 源码剖析</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#map-删除-key-的实现" class="sidebar-link">map 删除 key 的实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#map-删除-key-的步骤" class="sidebar-link">map 删除 key 的步骤</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#map-删除过程图解" class="sidebar-link">map 删除过程图解</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#map-删除源码剖析" class="sidebar-link">map 删除源码剖析</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#map-的扩容实现" class="sidebar-link">map 的扩容实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#map-扩容的条件" class="sidebar-link">map 扩容的条件</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#hashgrow-实现" class="sidebar-link">hashGrow 实现</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#数据迁移的两条线" class="sidebar-link">数据迁移的两条线</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#什么时候-bucket-迁移之后下标会改变" class="sidebar-link">什么时候 bucket 迁移之后下标会改变？</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#bucket-迁移图解" class="sidebar-link">bucket 迁移图解</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#bucket-迁移源码剖析" class="sidebar-link">bucket 迁移源码剖析</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#等量扩容的效果" class="sidebar-link">等量扩容的效果</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#map-的迭代实现" class="sidebar-link">map 的迭代实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#map-迭代器数据结构" class="sidebar-link">map 迭代器数据结构</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#迭代器的初始化实现" class="sidebar-link">迭代器的初始化实现</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#map-遍历图解" class="sidebar-link">map 遍历图解</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#发生在扩容期间的遍历" class="sidebar-link">发生在扩容期间的遍历</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-map/#键值对遍历源码剖析" class="sidebar-link">键值对遍历源码剖析</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-map/#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/pages/golang/go-slice/" class="sidebar-link">go slice 设计与实现</a></li><li><a href="/pages/golang/go-context/" class="sidebar-link">小白也能看懂的context包详解：从入门到精通</a></li><li><a href="/pages/golang/go-interface/" class="sidebar-link">go interface 设计与实现</a></li><li><a href="/pages/golang/go-chan/" class="sidebar-link">深入理解 go chan</a></li><li><a href="/pages/golang/go-chan-design-and-implementation/" class="sidebar-link">go chan 设计与实现</a></li><li><a href="/pages/golang/go-mutex/" class="sidebar-link">深入理解 go Mutex</a></li><li><a href="/pages/golang/go-sync-map-1/" class="sidebar-link">深入理解 go sync.Map - 基本原理</a></li><li><a href="/pages/golang/go-sync-map-2/" class="sidebar-link">go sync.Map 设计与实现</a></li><li><a href="/pages/golang/go-sync-once/" class="sidebar-link">深入理解 go sync.Once</a></li><li><a href="/pages/golang/go-reflect-1/" class="sidebar-link">深入理解 go reflect - 反射基本原理</a></li><li><a href="/pages/golang/go-reflect-2/" class="sidebar-link">深入理解 go reflect - 要不要传指针</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程思想</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运维</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script><ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="8498052873"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/code/#技术" data-v-06225672>技术</a></li><li data-v-06225672><a href="/code/#Golang" data-v-06225672>Golang</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://juejin.cn/post/7177582930313609273" target="_blank" title="作者" class="beLink" data-v-06225672>eleven26</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-08-09</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="/img/dragon/9.webp">go map 设计与实现<!----></h1>  <div class="theme-vdoing-content content__default"><p>哈希表作为一种非常常用的数据结构，存在于各种编程语言中，它可以让我们保存<strong>键值对</strong>数据，而且有着非常高的查找效率。 本文就以 go 语言中的 <code>map</code> 为例子，讲述一下哈希表在 go 中的实现。
</p> <blockquote><p>本文基于 go 1.19</p></blockquote> <h2 id="哈希表基本操作"><a href="#哈希表基本操作" class="header-anchor">#</a> 哈希表基本操作</h2> <p>在开始之前，需要大概讲解一下哈希表这种数据结构，哈希表会预先在内存中分配一段比较大的内存，这段内存用在将来往里面写入数据的时候使用。 哈希表有点类似数组，都是一段连续的内存，但是我们往哈希表读写数据的时候不同于数组，数组的时候是<strong>直接通过下标访问</strong>的， 而哈希表的读写需要先计算 <code>key</code> 的哈希值，根据这个哈希值对哈希表长度取模得到 <code>key</code> 对应的哈希表的下标，然后对哈希表这个下标进行读写操作。</p> <p>对于哈希表有以下几种常见的操作：</p> <ol><li>写入：根据 <code>key</code> 计算 <code>hash</code> 值，对哈希表长度取模得到 <code>key</code> 在内存中的地址，然后往这个地址写入数据。</li> <li>读取：根据 <code>key</code> 计算 <code>hash</code> 值，对哈希表长度取模得到 <code>key</code> 在内存中的地址，然后读取这个地址中的数据。</li> <li>修改：根据 <code>key</code> 计算 <code>hash</code> 值，对哈希表长度取模得到 <code>key</code> 在内存中的地址，然后修改这个内存地址里面的数据。</li> <li>删除：根据 <code>key</code> 计算 <code>hash</code> 值，对哈希表长度取模得到 <code>key</code> 在内存中的地址，然后清空保存这个 <code>key</code> 的那一小块内存。</li></ol> <p>注意：计算出的 <code>hash</code> 值可能比分配的内存大小要大，所以才需要对其取模（<code>hash</code> 值 / 哈希表长度 =&gt; <code>key</code> 在哈希表的索引）， 保证计算出的 <code>hash</code> 最终落到哈希表的内存范围之内。比如，<code>keyn</code> 计算出来的哈希值为 <code>100</code>，但是我们的哈希表长度只有 <code>8</code>， 那么 <code>keyn</code> 最终会落在哈希表中下标为 <code>2</code> 的地方（<code>100 % 7 = 2</code>，下标是从 <code>0</code> 开始的，所以这里是 <code>7</code>）</p> <h3 id="哈希表的写入"><a href="#哈希表的写入" class="header-anchor">#</a> 哈希表的写入</h3> <p>假设我们现在要有一个长度为 8 的哈希表（下图左），我们有数据 <code>{&quot;a&quot;: 1, &quot;b&quot;: 2}</code> 需要存入这个哈希表，存入之后的哈希表为下图右：</p> <p><img src="/images/go/map/1.webp" alt="map_1_1.png"></p> <p>说明：<code>hash(a) = 5</code>，计算 <code>a</code> 的哈希值得到 <code>5</code>，所以将 <code>a:1</code> 存入了哈希表中下标为 <code>5</code> 的地址处。<code>b</code> 同理。</p> <blockquote><p>注意：键值都会存储。</p></blockquote> <h3 id="哈希表的读取"><a href="#哈希表的读取" class="header-anchor">#</a> 哈希表的读取</h3> <p>从哈希表中读取 <code>key</code> 为 <code>b</code> 的键值对：</p> <p><img src="/images/go/map/2.webp" alt="map_1_2.png"></p> <h3 id="哈希表的修改"><a href="#哈希表的修改" class="header-anchor">#</a> 哈希表的修改</h3> <p>现在，我们需要将 <code>a</code> 的值修改为 <code>3</code>，同样的，计算其 <code>hash</code> 值，得到 <code>5</code>，然后将哈希表中 <code>5</code> 这个下标的内存修改成 <code>3</code>：</p> <p><img src="/images/go/map/3.webp" alt="map_1_3.png"></p> <h3 id="哈希表的删除"><a href="#哈希表的删除" class="header-anchor">#</a> 哈希表的删除</h3> <p>假设要将哈希表中 <code>b</code> 这个键删除，会先计算其 <code>hash</code> 值，得到 <code>0</code>，然后将哈希表中 <code>0</code> 这个下标的内存清空：</p> <p><img src="/images/go/map/4.webp" alt="map_1_4.png"></p> <h3 id="哈希表的高效之处"><a href="#哈希表的高效之处" class="header-anchor">#</a> 哈希表的高效之处</h3> <p>通过上面的分析，我们可以知道，哈希表的内存布局跟数组类似，但是哈希表的存储要通过计算 <code>key</code> 的哈希值来得到其在哈希表中的索引，最后对这个索引的内存进行 CRUD 操作。这样一来，如果我们需要频繁的根据键查找其对应值的话，使用哈希表无疑会大大提高效率。相比之下，如果使用数组来存储，那么每次搜索都需要将整个数组遍历一次，效率非常低下。</p> <p>比如下图，假设我们一个数组内存布局如下，那么在我们查找 <code>a:1</code> 的时候，需要从数组的第一个元素开始遍历，每一个元素读取出来看看它的键是不是 <code>a</code>， 取到第 <code>6</code> 个元素（下标 <code>5</code>）的时候，发现它的键是 <code>a</code>，然后取出对应的值 <code>1</code>。</p> <p><img src="/images/go/map/5.webp" alt="map_1_5.png"></p> <p>在数组的元素个数少的时候，这种查找效率其实影响不大，但如果我们有上万个元素的时候，每次查找都要从第一个元素开始遍历，效率无疑会非常低。 相比之下，不管数据再怎么多，使用哈希表的方式，我们直接通过哈希算法计算一下就可以知道键保存到了哪个槽中。</p> <h2 id="哈希冲突解决方法"><a href="#哈希冲突解决方法" class="header-anchor">#</a> 哈希冲突解决方法</h2> <p>在上一节中，我们的图将哈希表的每一个槽（<code>slot</code>，又或者叫 <code>cell</code>，都是同一个东西）都表示成只有一个元素了。 但在实际中，往往会出现计算出来的哈希值对哈希表长度取模后是相等的，也就是不同的 <code>key</code> 会落到同一个槽中（这就是 <strong>哈希冲突</strong>），</p> <p>这种情况下，一个槽存放不下的话，有两种办法可以处理：<strong>开放地址法</strong>和<strong>链表法</strong>。go 里面的 <code>map</code> 使用的是<strong>链表法</strong>， 具体来说，就是在 <code>hash</code> 冲突的地方，建立一个链表来保存相同 <code>hash</code> 值的 <code>key</code>。</p> <p>这样一来，我们通过 <code>hash</code> 算法计算出哈希值的时候，并不能唯一确定对应的值了，因为有可能两个 <code>key</code> 经过哈希算法计算之后，得到的哈希值是一样的。 这种情况怎么办呢？很简单，因为虽然哈希值是一样的，但是它们的 <code>key</code> 是不一样的，再比较一下 <code>key</code> 就可以确定了。具体可以参考下图：</p> <p><img src="/images/go/map/6.webp" alt="map_1_6.png"></p> <p>有哈希冲突的情况下，读取哈希表数据的过程：</p> <ul><li>计算 <code>c</code> 的 <code>hash</code> 值，得到 <code>0</code>，就是哈希表的索引</li> <li>获取哈希表中地址 <code>0</code> 上的数据，这会遍历冲突产生的链表</li> <li>比较 <code>c</code> 跟 <code>b</code>，不相等，继续比较链表下一个元素</li> <li>比较 <code>c</code> 跟 <code>c</code>，相等，返回 <code>3</code></li></ul> <h2 id="哈希扩容"><a href="#哈希扩容" class="header-anchor">#</a> 哈希扩容</h2> <p>go 里面 <code>map</code> 扩容有两种方式：<strong>增量扩容</strong>和<strong>等量扩容</strong>。</p> <h3 id="哈希表总元素个数过多导致的扩容"><a href="#哈希表总元素个数过多导致的扩容" class="header-anchor">#</a> 哈希表总元素个数过多导致的扩容</h3> <p>这种扩容方式也叫<strong>增量扩容</strong>。</p> <p>我们在上面说过了，其实哈希表的内存布局跟数组类似，都是先分配一段连续的内存。然后在哈希冲突的时候，对于冲突的 <code>key</code> 建立一个链表来保存。 这样就会出现一种情况，在链表中存在很多冲突的键，这样一来，在查找冲突 <code>key</code> 的时候，需要在这一堆冲突的 <code>key</code> 中进行查找，这个查找类似数组的查找，效率较低。</p> <p>为了避免这种情况的出现，一般的哈希表设计会在元素个数总数超过一定数量的时候，对哈希表进行扩容， 这样一来，那些哈希冲突的键就可以相对均匀地分布在哈希表中，从而避免了很多哈希冲突情况下导致的查找效率低下的问题。</p> <blockquote><p>扩容之后的容量为原来容量的 2 倍。</p></blockquote> <p><img src="/images/go/map/7.webp" alt="map_1_7.png"></p> <h4 id="go-map-的负载因子"><a href="#go-map-的负载因子" class="header-anchor">#</a> go map 的负载因子</h4> <p>在 go 中，<code>map</code> 在实际存储的元素数量超过 <code>map</code> 里 <code>bucket</code> 总数量的 <code>6.5</code> 倍的时候（也就是平均每个 <code>bucket</code> 中的元素个数大于 <code>6.5</code> 的时候），会进行扩容， 这个 <code>6.5</code> 是实现 <code>map</code> 的那个开发者经过实验计算出来的比较合适的数，这个 <code>6.5</code> 被称为负载因子。</p> <p>为什么负载因子是 <code>6.5</code> 呢，在 go 的 <code>map</code> 源码中有相关的说明：</p> <p><strong>选择负载因子，如果太大，会有很多溢出桶，太小，则会浪费很多空间</strong>。 我编写了一个简单的程序来检查不同负载的一些统计数据:（64位、8字节 key 和元素）</p> <table><thead><tr><th>loadFactor</th> <th>%overflow</th> <th>bytes/entry</th> <th>hitprobe</th> <th>missprobe</th></tr></thead> <tbody><tr><td>4.00</td> <td>2.13</td> <td>20.77</td> <td>3.00</td> <td>4.00</td></tr> <tr><td>4.50</td> <td>4.05</td> <td>17.30</td> <td>3.25</td> <td>4.50</td></tr> <tr><td>5.00</td> <td>6.85</td> <td>14.77</td> <td>3.50</td> <td>5.00</td></tr> <tr><td>5.50</td> <td>10.55</td> <td>12.94</td> <td>3.75</td> <td>5.50</td></tr> <tr><td>6.00</td> <td>15.27</td> <td>11.67</td> <td>4.00</td> <td>6.00</td></tr> <tr><td>6.50</td> <td>20.90</td> <td>10.79</td> <td>4.25</td> <td>6.50</td></tr> <tr><td>7.00</td> <td>27.14</td> <td>10.15</td> <td>4.50</td> <td>7.00</td></tr> <tr><td>7.50</td> <td>34.03</td> <td>9.73</td> <td>4.75</td> <td>7.50</td></tr> <tr><td>8.00</td> <td>41.10</td> <td>9.40</td> <td>5.00</td> <td>8.00</td></tr></tbody></table> <p>列说明：</p> <ul><li><code>%overflow</code>: 具有溢出桶的桶的百分比</li> <li><code>bytes/entry</code>: 每个 key/elem 对使用的开销字节</li> <li><code>hitprobe</code>: 查找当前 key 时要检查的条目数</li> <li><code>missprobe</code>: 查找缺少的 key 时要检查的条目数</li></ul> <h3 id="哈希冲突链上元素太少导致的扩容"><a href="#哈希冲突链上元素太少导致的扩容" class="header-anchor">#</a> 哈希冲突链上元素太少导致的扩容</h3> <p>这种扩容方式也叫<strong>等量扩容</strong>。</p> <p>我们知道，在哈希冲突的时候，会建立链表来保存键冲突的元素，但是我们删除那些哈希冲突的键的时候，并不会对删除元素的内存进行释放， 如果每次删除都释放的话，在我们频繁插入跟删除的时候，效率就非常低下了。 因为插入一个元素就分配内存，删除一个元素就释放内存（分配内存和释放内存都是相对耗时的操作）。 而这样的结果是，保存冲突键的链表上，有很多空的元素，这样就会导致冲突的时候，查找键的效率降低，因为要遍历很多空的键。</p> <p>删除的时候不释放，那什么时候会释放呢？哈希冲突的元素很多都被删除的时候，在 go 里面，<code>map</code> 会判断就算没有超过负载因子的情况下， 如果冲突链表占用的空间过大的话，也会进行扩容。但这里说的扩容其实并不是真正意义上的扩容，只是 <code>map</code> 的实现里面，使用的函数是同一个函数。</p> <p>具体实现方式是，分配跟原哈希表相同大小的空间，然后将旧哈希表的数据迁移到新的哈希表。 这样迁移之后，对于哈希冲突链表上的那些元素，只会迁移非空的元素，最终结果就是，扩容之后，哈希冲突链表上的元素更加紧凑，在查找冲突的键的时候会更加高效。</p> <blockquote><p>虽然哈希表的总容量没变，但是数据分布更加紧凑了，省去了遍历空元素的时间。</p></blockquote> <p><img src="/images/go/map/8.webp" alt="map_1_8.png"></p> <h2 id="go-map-概述"><a href="#go-map-概述" class="header-anchor">#</a> go map 概述</h2> <ul><li><code>map</code> 只是一个哈希表。数据被排列成一组 <code>bucket</code>。</li> <li>每个 <code>bucket</code> 最多包含 <code>8</code> 个 <code>键/值</code> 对。</li> <li>哈希值的低位字节位用于选择 <code>bucket</code>。</li> <li>每个 <code>bucket</code> 包含每个哈希的几个高位字节位(<code>tophash</code>)，以区分单个桶中的条目。</li> <li>如果超过 <code>8</code> 个 <code>key</code> 哈希到同一个桶，我们将额外的桶以链表的方式起来。（解决哈希冲突，链表法）</li> <li>当哈希表扩容时，我们会分配一个两倍大的新 <code>bucket</code> 数组。然后 <code>bucket</code> 从旧 <code>bucket</code> 数组增量复制到新 <code>bucket</code> 数组。</li> <li><code>map</code> 迭代器遍历 <code>bucket</code> 数组，并按遍历顺序返回键（遍历完普通桶之后，遍历溢出桶）。</li> <li>为了保持迭代语义，我们永远不会在它们的桶中移动键（<code>bucket</code> 内键的顺序在扩容的时候不变。如果改变了桶内键的相对顺序，键可能会返回 0 或 2 次）。</li> <li>在扩容哈希表时，迭代器仍在旧的桶中迭代，并且必须检查新桶，检查正在迭代的 <code>bucket</code> 是否已经被迁移到新桶。</li></ul> <h2 id="go-map-的整体模型"><a href="#go-map-的整体模型" class="header-anchor">#</a> go map 的整体模型</h2> <p>上面讲了哈希表的基本设计思路，接下来就要开始讲 go 里面 <code>map</code> 的设计与实现了。大体上其实就是上面说的样子，但是有下面几个不一样的地方：</p> <blockquote><p>下文的 <code>bucket</code> 和 <code>bmap</code> 都是指的 &quot;桶&quot;。</p></blockquote> <ul><li>go <code>map</code> 里面存储数据的地方是 <code>bucket</code>（桶），一个 <code>bucket</code> 可以存储 <code>8</code> 个元素，也就是说哈希冲突的时候还是会在同一个 <code>bucket</code> 中先存储。</li> <li>如果 <code>bucket</code> 也存放不下冲突的元素了，那么会新建另外一个桶（叫做溢出桶），旧的 <code>bucket</code> 记录这个新桶的指针，旧的 <code>bucket</code> 存放不下的元素，会存放到这个溢出桶中。</li> <li>如果溢出桶还是存放不下，那么再新建一个溢出桶，链接到上一个溢出桶中。</li></ul> <p>也就是说，在 go 的 <code>map</code> 实现中，哈希计算出来的值决定了 <code>key</code> 应该存放在哪一个 <code>bucket</code> 中。</p> <p>go <code>map</code> 的整体结构如下图：</p> <p><img src="/images/go/map/9.webp" alt="map_2_1.png"></p> <ul><li><code>buckets</code> 记录了保存 <code>map</code> 数据的所有 <code>bucket</code>（这种下文统一称为<strong>普通桶</strong>），go 中使用 <code>bmap</code> 这个结构体来表示 <code>bucket</code>，溢出桶也是使用 <code>bmap</code> 结构体表示。</li> <li>如果 <code>bucket</code>（普通桶）哈希冲突太多导致存放不下，会新建一个 <code>bucket</code>，在原来的 <code>bucket</code> 上会有一个指针记录新建 <code>bucket</code> 的地址，这个新 <code>bucket</code> 下文统一称为<strong>溢出桶</strong>。</li> <li>在创建 <code>map</code> 的时候，如果我们指定的容量比较大（<code>B &gt;= 4</code> 的时候），那么会预创建一个溢出桶。</li></ul> <p>也就是说，go 中解决哈希冲突的链表法，链表上的每一个元素是一个 <code>bucket</code>。go <code>map</code> 的实现里面，<strong>一个 <code>bucket</code> 可以存放 <code>8</code> 个键值对</strong>。</p> <p>上面的 <code>bmap</code> 的数据结构如下图：</p> <p><img src="/images/go/map/10.webp" alt="map_2_2.png"></p> <ul><li><code>bmap</code> 就是 <code>bucket</code>（桶），不管是普通的桶还是溢出的桶，都是使用 <code>bmap</code> 结构体表示。</li> <li><code>bmap</code> 中存储数据的方式有点特别，它先存储了 <code>8</code> 个 <code>tophash</code> 值，一个 <code>tophash</code> 的大小为 1 个字节，每一个 <code>tophash</code> 记录的是 <code>bmap</code> 中每一个元素的哈希值的最高的 8 bit。</li> <li>接下来是 <code>bmap</code> 存储的 8 个元素的 <code>key</code>，在 8 个 <code>key</code> 之后是 8 个 <code>bmap</code> 存储的值。我们会发现 <code>key</code> 和 <code>value</code> 的存储是分开的，而不是 <code>key/value</code>、<code>key/value</code> 这种方式。go 中这种分开存储的方式有一个好处是可以减少内存对齐的开销，从而更省内存。</li> <li>最后是 <code>overflow</code>（溢出桶），如果 <code>bmap</code> 存满了，那就会新建一个溢出桶来保存新的数据，通过在旧的 <code>bmap</code> 上记录指针来记录溢出桶。</li></ul> <p><code>tophash</code> 的作用是，在哈希冲突的时候，在 <code>bucket</code> 内进行查找的时候，是需要在 <code>bucket</code> 内从第一个元素遍历到最后一个元素来查找的。 如果 <code>key</code> 太大，直接比较 <code>key</code> 的话效率会比较低下，通过记录哈希值的高 8 位，我们就可以在 <code>buckeet</code> 内查找的时候，先比较哈希值的 前 8 位，这样一来，<code>map</code> 的效率受到 <code>key</code> 大小的影响就会比较小。当然哈希值的高 8 位有可能相同，在这种情况下，我们再比较一下 <code>key</code> 本身 就可以确定 <code>bucket</code> 的那个槽（<code>slot</code>/<code>cell</code>）是否是我们正在查找的那一个 <code>key</code>。</p> <h2 id="go-map-相关数据结构"><a href="#go-map-相关数据结构" class="header-anchor">#</a> go map 相关数据结构</h2> <p>我们大部分内容是跟下面两个结构体打交道：</p> <ul><li><code>hmap</code>: <code>map</code> 的数据结构，包含了 <code>bucket</code> 的指针、<code>bucket</code> 的数量、键值对的数量等信息。</li> <li><code>bmap</code>: 桶，存储 <code>key/value</code> 的地方</li></ul> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// go map 数据结构</span>
<span class="token keyword">type</span> hmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   count     <span class="token builtin">int</span>            <span class="token comment">// map 的元素数量。调用 len(map) 的时候返回此值</span>
   flags     <span class="token builtin">uint8</span>          <span class="token comment">// map 标记：iterator/oldIterator/hashWriting/sameSizeGrow</span>
   B         <span class="token builtin">uint8</span>          <span class="token comment">// 指示了当前哈希表持有的 buckets 的数量（2^B 是 bucket 的数量）</span>
   noverflow <span class="token builtin">uint16</span>         <span class="token comment">// 溢出桶的数量</span>
   hash0     <span class="token builtin">uint32</span>         <span class="token comment">// 哈希种子，计算 key 的哈希的时候会传入哈希函数</span>
   buckets   unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 指向 buckets 的数组，大小为 2^B。 如果元素个数为 0 则为 nil。</span>

   <span class="token comment">// 哈希表扩容的时候记录 buckets 字段。</span>
   <span class="token comment">// 增量扩容时，oldbuckets 的长度是 buckets 的一半。</span>
   oldbuckets unsafe<span class="token punctuation">.</span>Pointer

   nevacuate <span class="token builtin">uintptr</span>   <span class="token comment">// 指示扩容进度，小于此地址的 buckets 完成迁移</span>
   extra     <span class="token operator">*</span>mapextra <span class="token comment">// 可选字段</span>
<span class="token punctuation">}</span>

<span class="token comment">// mapextra 包含并非在所有 map 上都存在的字段。</span>
<span class="token comment">// 下面 mapextra 注释是原文的翻译（看完了 map 的全部源码也还不是很懂这个结构体的作用，除了 nextOverflow 字段）。</span>
<span class="token keyword">type</span> mapextra <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果 key 和 elem 都不包含指针并且是内联的，那么我们将 bucket type 标记为不包含指针。这避免了扫描此类 map。</span>
   <span class="token comment">// 但是，bmap.overflow 是一个指针。 为了让溢出桶保持活动状态，</span>
   <span class="token comment">// 我们将指向所有溢出桶的指针存储在 hmap.extra.overflow 和 hmap.extra.oldoverflow 中。</span>
   <span class="token comment">// overflow 和 oldoverflow 仅在 key 和 elem 不包含指针时使用。</span>
   <span class="token comment">// overflow 包含 hmap.buckets 的溢出桶。</span>
   <span class="token comment">// oldoverflow 包含 hmap.oldbuckets 的溢出桶。</span>
   <span class="token comment">// 间接允许在 hiter 中存储指向切片的指针。</span>
   overflow    <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap
   oldoverflow <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap

   <span class="token comment">// nextOverflow 持有指向空闲溢出桶的指针。</span>
   nextOverflow <span class="token operator">*</span>bmap
<span class="token punctuation">}</span>

<span class="token comment">// go map 中的 bucket 结构体（实际保存 key/value 的地方）</span>
<span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   <span class="token comment">// tophash 通常包含此 bucket 中每个键的哈希值的最高的 8 位（1 字节）。</span>
   <span class="token comment">// 如果 tophash[0] ＜ minTopHash，则 tophash[0] 为桶已迁移状态。</span>
   <span class="token comment">// 这是一个长度为 8 的数组，因为一个 bucket 只能存储 8 个元素。</span>
   <span class="token comment">// tophash 存储的是每一个元素的键的哈希的高 8 位。</span>
   <span class="token comment">//（通过比较不同键的哈希的高 8 位可以提高 bucket 内的查找性能，因为键可能很大）</span>
   tophash <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span><span class="token builtin">uint8</span>
   
   <span class="token comment">// 然后是 8 个键，然后是 8 个值。（这里的 8 是代码写死的）</span>
   <span class="token comment">// 注意：将所有键放在在一起，然后将所有值放在一起使代码比交替的 key/elem/key/elem/… 复杂一些，</span>
   <span class="token comment">// 但它允许我们消除填充（减少内存对齐导致的内存浪费），例如 map[int64]int8，</span>
   <span class="token comment">// 这种如果使用 key/elem 的方式存储则需要浪费几个字节用来对齐。</span>
   keys <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span>keytype <span class="token comment">// 8 个键</span>
   values <span class="token punctuation">[</span>bucketCnt<span class="token punctuation">]</span>valuetype <span class="token comment">// 8 个值</span>
   overflow <span class="token operator">*</span>bmap <span class="token comment">// 指向溢出桶的指针</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>对于 <code>map</code> 的数据结构，需要特别说明的是，<code>bmap</code> 的源码中实际只包含了 <code>tophash</code> 字段，而后面的三个字段 <code>keys/values/overflow</code> 都是在编译期间动态添加的。这是因为 <code>map</code> 中可能存储不同类型的键值对，所以键值对占据的内存空间大小只能在编译时进行推导。 这样一来，最终的结果是，我们在 <code>map</code> 的源码中，访问 <code>key</code> 和 <code>value</code> 的时候都需要通过 <code>bmap</code> 的首地址加上偏移量来进行访问的。</p> <p>比如获取 <code>bucket</code> 中第 <code>i</code> 个 <code>key</code> 的方式：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这行代码中，<code>add</code> 是做指针加法运算的函数，具体来说就是第一个参数的地址加上第二个参数（偏移量），得到一个我们想要的指针。 <code>dataOffset</code> 代表了 <code>bmap</code> 的 <code>keys</code> 第一个元素的偏移量，<code>i</code> 代表了我们想要获取的 <code>key</code> 在 <code>keys</code> 中的索引：</p> <p><img src="/images/go/map/11.webp" alt="map_2_3.png"></p> <p>这样一来，我们就可以通过 <code>k</code> 这个指针来访问 <code>bucket</code> 中的 <code>key</code> 了。同样的，要访问 <code>value</code> 的方式也是类似的， 只要将 <code>dataOffset + i * uintptr(t.keysize)</code> 替换成 <code>dataOffset + bucketCnt * uintptr(t.keysize)</code> 即可。</p> <blockquote><p>这种方式虽然不太优雅，但是在性能上可以达到最优。</p></blockquote> <h2 id="bmap-桶-源码剖析"><a href="#bmap-桶-源码剖析" class="header-anchor">#</a> bmap（桶）源码剖析</h2> <p><code>bmap</code> 就是保存键值对的地方，但是它本身的方法并不多：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// bucket 是否已经完成迁移</span>
<span class="token comment">// b 是 bucket 的指针</span>
<span class="token keyword">func</span> <span class="token function">evacuated</span><span class="token punctuation">(</span>b <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
   h <span class="token operator">:=</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
   <span class="token keyword">return</span> h <span class="token operator">&gt;</span> emptyOne <span class="token operator">&amp;&amp;</span> h <span class="token operator">&lt;</span> minTopHash
<span class="token punctuation">}</span>

<span class="token comment">// 获取 b 的溢出桶</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token function">overflow</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">)</span> <span class="token operator">*</span>bmap <span class="token punctuation">{</span>
   <span class="token comment">// bmap 数据结构的最后一个指针就是指向溢出桶的指针</span>
   <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token operator">-</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置 b 的溢出桶</span>
<span class="token comment">// bmap 数据结构的最后一个指针指向溢出桶</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token function">setoverflow</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> ovf <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token operator">-</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> ovf
<span class="token punctuation">}</span>

<span class="token comment">// 获取 b 中保存 keys 的指针（指向了桶内的第一个 key）</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>在 <code>ev</code> 中用到了两个常量，在 <code>bucket</code> 的 <code>tophash</code> 里面，会通过下面几个标志来记录桶里面槽的状态：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 这个 cell 是空的，并且在更高的索引或溢出处没有更多的非空 cell。</span>
emptyRest <span class="token operator">=</span> <span class="token number">0</span>
<span class="token comment">// 这个 cell 是空的</span>
emptyOne <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// key/elem 有效。 entry 已被迁移到较大的哈希表的前半部分（扩容了）。</span>
evacuatedX <span class="token operator">=</span> <span class="token number">2</span>
<span class="token comment">// 同上，但迁移到大的哈希表的后半部分（扩容了）。</span>
evacuatedY <span class="token operator">=</span> <span class="token number">3</span>
<span class="token comment">// cell 是空的，bucket 已经被迁移了</span>
evacuatedEmpty <span class="token operator">=</span> <span class="token number">4</span>
<span class="token comment">// 正常填充单元格的最小 tophash。</span>
minTopHash <span class="token operator">=</span> <span class="token number">5</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>为了跟正常的 <code>tophash</code> 区分开来，如果计算出来的 <code>tophash</code> 小于 <code>minTopHash</code>，会将计算出来的 <code>tophash</code> 加上 <code>minTopHash</code>：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// tophash 计算 hash 的 tophash 值。</span>
<span class="token comment">// 这是一个字节的大小的。（hash 最高的 8 位）</span>
<span class="token keyword">func</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">uint8</span> <span class="token punctuation">{</span>
   <span class="token comment">// top 本质上就是 hash 的前面 8 个字节（goarch.PtrSize*8 - 8，左移位数：指针的字节大小 - 8 字节）</span>
   top <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>goarch<span class="token punctuation">.</span>PtrSize<span class="token operator">*</span><span class="token number">8</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span> top <span class="token operator">&lt;</span> minTopHash <span class="token punctuation">{</span>
      top <span class="token operator">+=</span> minTopHash
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> top
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这样一来，<strong>通过 <code>tophash</code> 这一个字节就可以记录桶里面槽的状态了，非常节省空间。</strong></p> <h2 id="map-的创建的实现"><a href="#map-的创建的实现" class="header-anchor">#</a> map 的创建的实现</h2> <p>我们已经了解了哈希表的基本工作机制了，现在就让我们来深入了解一下 go 里 <code>map</code> 的实现，先是 <code>map</code> 的创建， <code>map</code> 的创建是通过 <code>makemap()</code> 函数实现的（对应我们写的代码是 <code>make(map[int]int, 10)</code>），<code>map</code> 的创建步骤如下：</p> <ol><li>计算 <code>map</code> 所需内存，判断是否在一个合理范围之内。</li> <li>使用 <code>new</code> 初始化 <code>hmap</code> 结构体。</li> <li>生成随机哈希种子。</li> <li>计算出一个最小的 <code>B</code>，也就是根据用户传递给 <code>make</code> 的第二个参数算出一个最小的 <code>B</code> 的值，最终桶的数量为 <code>2^B</code> 个。</li> <li>如果 <code>B</code> 大于 <code>0</code>，则给哈希表的 <code>buckets</code> 分配内存。</li> <li>最后，返回新创建好的 <code>hmap</code>。</li></ol> <p>下文在寻址过程中，大量使用了指针的运算，所以如果对 <code>unsafe.Pointer</code> 比较熟悉的话，看起来会比较轻松，如果不熟悉也没关系，可以看看我另外一篇文章《深入理解 go unsafe》。</p> <h3 id="makemap-实现"><a href="#makemap-实现" class="header-anchor">#</a> makemap 实现</h3> <p><code>makemap</code> 具体源码如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// makemap 是 make(map[k]v, hint) 的实现，创建一个 map。</span>
<span class="token comment">// 如果编译器可以确定 map 或者第一个 bucket 可以在栈上创建，h 和/或 bucket 可能为 non-nil。</span>
<span class="token comment">// 如果 h != nil，map 可以直接在 h 中创建。</span>
<span class="token comment">// 如果 h.buckets != nil，buckets 指针指向的那个元素可以作为第一个 bucket。</span>
<span class="token keyword">func</span> <span class="token function">makemap</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> hint <span class="token builtin">int</span><span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">)</span> <span class="token operator">*</span>hmap <span class="token punctuation">{</span>
   <span class="token comment">// 计算所需要的内存大小</span>
   mem<span class="token punctuation">,</span> overflow <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>hint<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
   <span class="token comment">// 如果溢出或者超出最大分配内存，则设置 hint = 0；</span>
   <span class="token comment">// 这样的话，B 也会等于 0；</span>
   <span class="token comment">// 则最终的 map 只会有一个 bucket（2^B = 1）</span>
   <span class="token keyword">if</span> overflow <span class="token operator">||</span> mem <span class="token operator">&gt;</span> maxAlloc <span class="token punctuation">{</span>
      hint <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 初始化 hmap（分配 hmap 结构体本身所需要的内存）</span>
   <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      h <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>hmap<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 生成一个随机的哈希种子</span>
   h<span class="token punctuation">.</span>hash0 <span class="token operator">=</span> <span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token comment">// 根据传入的 hint，计算出需要的最小桶数量。</span>
   <span class="token comment">// 实际上是计算 B 的大小，桶的数量都是运行时通过 2^B 计算的。</span>
   B <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
   <span class="token comment">// 如果 hint 导致超过了负载因子，则将 B 加 1，一直加到小于负载因子。</span>
   <span class="token comment">// 简单来说就是：hint / (2^B) &gt; 负载因子，也就是 hint 个键值对放到所有桶中，</span>
   <span class="token comment">// 每个桶中元素数量大于负载因子（6.5）的时候，则将 B 加 1。</span>
   <span class="token comment">// 注：map 扩容的时候也是这个判断标准。</span>
   <span class="token keyword">for</span> <span class="token function">overLoadFactor</span><span class="token punctuation">(</span>hint<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      B<span class="token operator">++</span>
   <span class="token punctuation">}</span>
   h<span class="token punctuation">.</span>B <span class="token operator">=</span> B

   <span class="token comment">// 分配初始哈希表。</span>
   <span class="token comment">// 如果 B==0，则稍后（在mapassign中）延迟分配桶字段。</span>
   <span class="token comment">// 若 hint 较大，则清零此内存可能需要一段时间。</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>B <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> nextOverflow <span class="token operator">*</span>bmap
      <span class="token comment">// 初始化 buckets（分配 buckets 所需要的内存）</span>
      h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> nextOverflow <span class="token operator">=</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
      <span class="token comment">// 如果 hint 比较大，则会预先分配溢出桶，记录到 extra 字段中。</span>
      <span class="token keyword">if</span> nextOverflow <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
         h<span class="token punctuation">.</span>extra <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>mapextra<span class="token punctuation">)</span>
         h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>nextOverflow <span class="token operator">=</span> nextOverflow
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> h
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h3 id="overloadfactor-实现"><a href="#overloadfactor-实现" class="header-anchor">#</a> overLoadFactor 实现</h3> <p>这里面有一个比较重要的函数，那就是 <code>overLoadFactor</code>，这个函数用来判断某一个数量是否超过 <code>map</code> 的负载因子，如果超过，那就需要扩容了：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// overLoadFactor 报告放置在 2^B 个桶中的键值对数量是否超过负载因子。</span>
<span class="token keyword">func</span> <span class="token function">overLoadFactor</span><span class="token punctuation">(</span>count <span class="token builtin">int</span><span class="token punctuation">,</span> B <span class="token builtin">uint8</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> count <span class="token operator">&gt;</span> bucketCnt <span class="token operator">&amp;&amp;</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">&gt;</span> loadFactorNum<span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">bucketShift</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">/</span>loadFactorDen<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><code>count &gt; bucketCnt</code>，前半部分判断很简单，就是判断数量一个桶能不能放得下。一个桶就能装下所有数据的话，根本就不用计算了，肯定没超过负载因子。</li> <li>后半部分判断翻译过来是：<code>桶数量 * 负载因子(6.5) &lt; 总键值对数量</code>，意味着平均每个桶存储的元素个数大于 <code>6.5</code> 了，也就是说超过了负载因子了。</li> <li>在其他函数中，<strong>判断是否超过负载因子的时候都是使用上面这个函数</strong>。</li> <li><code>loadFactorNum</code> 和 <code>loadFactorDen</code> 是预定义的变量，它们相除就是负载因子 <code>6.5</code>。</li> <li><code>bucketShift(B)</code> 很简单，就是 <code>2^B</code>。</li></ul> <h3 id="makebucketarray-实现"><a href="#makebucketarray-实现" class="header-anchor">#</a> makeBucketArray 实现</h3> <p>在创建 <code>map</code> 的时候，使用了 <code>makeBucketArray</code> 来给 <code>map</code> 的桶分配内存，<code>makeBucketArray</code> 实现步骤如下：</p> <ol><li>如果判断到 <code>B &gt;= 4</code>，也就是初始化时需要分配的桶数量大于等于 <code>2^4 = 16</code> 的时候，则会预先分配溢出桶，分配的溢出桶个数为 <code>2^(b-4)</code> 个。</li> <li>接着，给 <code>map</code> 的桶（<code>buckets</code> 字段）分配内存（包含了普通桶和溢出桶，普通桶和溢出桶的内存一次性分配，溢出桶的内存在普通桶后面）。</li> <li>最后，判断到需要分配溢出桶的话（<code>B &gt;= 4</code>），则将溢出桶的指针写入到最后一个普通桶的 <code>overflow</code> 字段。</li></ol> <p>分配 <code>buckets</code> 内存的两种情况：</p> <ol><li>如果 <code>B &lt; 4</code>，那么分配内存的过程很简单，就是分配 <code>buckets</code> 所需要的内存，也就是分配普通桶所需要的内存就足够了，如下图：</li></ol> <p><img src="/images/go/map/12.webp" alt="map_3_1.png"></p> <ol><li>如果 <code>B &gt;= 4</code>，那么分配内存的过程就相对复杂，会预先分配一部分溢出桶。在后面需要创建溢出桶的时候，就会先使用这时候创建的溢出桶，而不是直接新建，如下图：</li></ol> <p><img src="/images/go/map/13.webp" alt="map_3_2.png"></p> <p>说明：</p> <ul><li>分配 <code>buckets</code> 所需要的内存的时候，会分配一部分溢出桶所需要的内存，普通桶和溢出桶的内存是连续的，分配给溢出桶的内存就在普通桶的后面。</li> <li>在 <code>makemap</code> 中会新建 <code>mapextra</code> 结构体，用 <code>nextOverflow</code> 字段来保存溢出桶的指针，指向第一个溢出桶的位置。</li> <li>最后一个溢出桶的 <code>overflow</code> 指针（指向溢出桶的指针），指向了 <code>buckets</code> 入口，这里并不是说将第一个普通桶作为最后一个溢出桶的溢出桶，而是一个标记作用。因为前面的溢出桶的 <code>overflow</code> 字段都是 <code>nil</code>，而最后一个溢出桶的 <code>overflow</code> 不是 <code>nil</code>，这样一来，我们通过判断溢出桶的 <code>overflow</code> 是否为 <code>nil</code> 就可以知道是否是最后一个溢出桶。如果是最后一个溢出桶，那么将 <code>map</code> 里面的 <code>extra.nextOverflow</code> 字段设置为 <code>nil</code>，表示预分配的溢出桶用完了，后面如果再需要溢出桶的时候，就只能直接 <code>new</code> 一个了。</li> <li><code>buckets</code> 指针下面的普通桶和溢出桶所需要的内存大小都是 <code>t.bucketsize</code>，也就是 <code>bmap</code> 所需要的内存大小（当然是内存对齐之后的）。</li></ul> <p>具体实现如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// makeBucketArray 初始化 map bucket 底层的数组（分配 buckets 的内存）。</span>
<span class="token comment">// 1&lt;&lt;b 是要分配的最小存储桶数。</span>
<span class="token comment">// dirtyalloc 应该是 nil（不为 nil，表示清空 map），或者是 makeBucketArray 之前使用相同的 t 和 b 参数分配的桶数组。</span>
<span class="token comment">// 如果 dirtyalloc 为 nil，将分配一段新的内存；否则将清除 dirtyalloc 指向的内存，将其作为新分配的内存。</span>
<span class="token comment">//</span>
<span class="token comment">// 参数：</span>
<span class="token comment">// t：底层表示 map 的类型</span>
<span class="token comment">// b：bucket 的大小为 2^b</span>
<span class="token comment">// dirtyalloc: 不为 nil 表示要清空，用于 mapclear 函数。</span>
<span class="token comment">//</span>
<span class="token comment">// 返回值：</span>
<span class="token comment">// buckets：正常桶数组入口</span>
<span class="token comment">// nextOverflow：溢出桶数组入口</span>
<span class="token keyword">func</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> b <span class="token builtin">uint8</span><span class="token punctuation">,</span> dirtyalloc unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>buckets unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> nextOverflow <span class="token operator">*</span>bmap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// bucket 数量 = 1 &lt;&lt; b</span>
   base <span class="token operator">:=</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
   nbuckets <span class="token operator">:=</span> base
   <span class="token comment">// 对于小的 b，溢出桶不太可能。避免计算开销。</span>
   <span class="token comment">// 桶的数量小于 2^4 时候，由于数据较少、使用溢出桶的可能性较低，</span>
   <span class="token comment">// 会省略创建溢出桶的过程以减少额外开销。</span>
   <span class="token comment">//</span>
   <span class="token comment">// 但是大于等于 2^4 的时候，使用到溢出桶的可能性就会比较大，所以需要预先分配溢出桶。</span>
   <span class="token keyword">if</span> b <span class="token operator">&gt;=</span> <span class="token number">4</span> <span class="token punctuation">{</span>
      <span class="token comment">// 大于等于 2^4 的时候，额外创建 2^(B-4) 个溢出桶。</span>
      nbuckets <span class="token operator">+=</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span>
      sz <span class="token operator">:=</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size <span class="token operator">*</span> nbuckets <span class="token comment">// 溢出桶所需要的内存大小</span>
      up <span class="token operator">:=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span>          <span class="token comment">// 计算需要的内存大小</span>
      <span class="token keyword">if</span> up <span class="token operator">!=</span> sz <span class="token punctuation">{</span>
         <span class="token comment">// 分配的内存与实际需要的内存不一样，</span>
         <span class="token comment">// 可能会比 sz 大一点，重新计算 nbuckets。</span>
         <span class="token comment">// 下面的 nbuckets 才是最终的 bucket 数量（普通桶 + 溢出桶的数量）</span>
         nbuckets <span class="token operator">=</span> up <span class="token operator">/</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// buckets 所在的内存初始化/清空（mapclear）</span>
   <span class="token keyword">if</span> dirtyalloc <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token comment">// 创建新的 bucket 数组</span>
      buckets <span class="token operator">=</span> <span class="token function">newarray</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucket<span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span>nbuckets<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 清空原有的内存</span>
      buckets <span class="token operator">=</span> dirtyalloc
      <span class="token comment">// buckets 所需要的总内存大小（单位：字节）</span>
      size <span class="token operator">:=</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>size <span class="token operator">*</span> nbuckets
      <span class="token comment">// 清空 buckets 开始的 size 字节大小的内存</span>
      <span class="token keyword">if</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
         <span class="token comment">// 有指针</span>
         <span class="token function">memclrHasPointers</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 上面 b &gt;= 4 的情况</span>
   <span class="token keyword">if</span> base <span class="token operator">!=</span> nbuckets <span class="token punctuation">{</span>
      <span class="token comment">// 处理一下预先分配的溢出桶。</span>
      nextOverflow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> base<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// buckets 和溢出桶内存是相邻的，计算第一个溢出桶的指针</span>
      last <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>nbuckets<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 最后一个溢出桶</span>
      last<span class="token punctuation">.</span><span class="token function">setoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span><span class="token punctuation">)</span>                             <span class="token comment">// 最后一个溢出桶的 overflow 指针链接到第一个普通桶</span>
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 返回普通桶、溢出桶的指针</span>
   <span class="token keyword">return</span> buckets<span class="token punctuation">,</span> nextOverflow
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br></div></div><h2 id="map-定位-key-的实现"><a href="#map-定位-key-的实现" class="header-anchor">#</a> map 定位 key 的实现</h2> <p>我们从上面的讲解中应该很清楚 <code>map</code> 中 <code>bucket</code> 这个数据结构了（上面的 <code>bmap</code> 那个图），在做查找、修改、删除操作的时候， 都需要先根据 <code>key</code> 找到具体的键值对保存在哪一个 <code>bucket</code> 以及 <code>bucket</code> 中的哪一个位置，所以这个操作其实是非常关键的。 在开始下文之前，就先来讲讲 <code>map</code> 中是如何定位一个 <code>key</code> 的。</p> <p>其实定位的过程比较简单，假设现在要查找一个 <code>key</code>，那定位 <code>key</code> 的大概步骤如下：</p> <ol><li>计算 <code>hash</code>: 根据 <code>key</code> 计算出其哈希值 <code>hash</code>。</li> <li>计算 <code>bucket</code>: 哈希值对 <code>buckets</code> 长度取模（<code>hash % len(buckets)</code>），不过实际实现的时候使用了一种优化的方式，位运算（<code>hash &amp; (2^B - 1)</code>），也就是由哈希值的最低 <code>B</code> 位来决定 <code>key</code> 最终使用哪一个 <code>bucket</code>（结果跟直接取模不一样，但是思想一样，都能保证得出的结果落在 <code>len(buckets)</code> 范围内）。</li> <li>遍历 <code>bucket</code>（先是普通桶）里面的每一个槽（有 8 个），比较哈希值的最高 8 位（8 bit，也就是 <code>tophash</code>）是否相等，如果相等，则获取存储在 <code>bucket</code> 里面的 <code>key</code>，跟我们需要定位的 <code>key</code> 做比较，如果相等，则说明已经找到了 <code>key</code>，如果 <code>key</code> 不相等，则继续遍历下一个槽，直到 <code>bucket</code> 中所有的槽都被遍历完毕。</li> <li>如果 <code>bucket</code> 里面的 8 个槽都遍历完了，仍然没有找到我们需要找的 <code>key</code>。那么会从 <code>bucket</code> 的溢出桶去查找，溢出桶内的查找过程跟普通桶内的查找过程是一样的。</li> <li>如此遍历，直到所有溢出桶都遍历完（在找不到的情况下才会遍历 <code>bucket</code> （普通桶）所有的溢出桶）。</li></ol> <p>这个查找过程可以表示为下图：</p> <p><img src="/images/go/map/14.webp" alt="map_4_1.png"></p> <p>注意：<strong>确定一个 <code>key</code> 需要 <code>tophash</code> 和 <code>key</code> 都相等，如果 <code>tophash</code> 相等而 <code>key</code> 不相等，则需要继续比较 <code>bucket</code> 中其他的槽。</strong></p> <h2 id="map-读取数据的实现"><a href="#map-读取数据的实现" class="header-anchor">#</a> map 读取数据的实现</h2> <p>从 <code>map</code> 中读取某一个键的方法主要有三个：<code>mapaccess1</code>、<code>mapaccess2</code>、<code>mapaccessK</code>，这三个方法的代码其实是大同小异的，所以这里只拿 <code>mapaccessK</code> 来讲解。</p> <p>这三个方法的不同之处在于：</p> <ul><li><code>mapaccess1</code> 只返回 <code>key</code> 对应的值，对应 <code>v := map[&quot;k&quot;]</code> 这种写法。</li> <li><code>mapaccess2</code> 返回 <code>key</code> 对应的值，以及是否存在的标志，对应 <code>v, ok := map[&quot;k&quot;]</code> 这种写法。</li> <li><code>mapaccessK</code> 用于遍历 <code>map</code> 的时候，返回 <code>key</code> 和 <code>value</code>，对应 <code>for k, v := range map {}</code> 这种写法（在迭代的时候在 <code>mapiternext</code> 里面调用）。</li></ul> <h3 id="mapaccessk-的查找步骤"><a href="#mapaccessk-的查找步骤" class="header-anchor">#</a> <code>mapaccessK</code> 的查找步骤</h3> <p><code>mapaccessK</code> 的查找步骤大概就是上一个图说的，只不过下面的描述更加详细一点（em... 有点重复了）：</p> <ul><li><p>判断 <code>map</code> 是否为空，为空直接返回</p></li> <li><p>计算 <code>key</code> 对应的哈希值 =&gt; <code>hash</code></p></li> <li><p>计算桶的掩码 =&gt; <code>m</code>，<code>hash &amp; m</code> 得到 <code>bucket</code> 的索引</p></li> <li><p>判断是否正在扩容，如果是，需要判断 key 对应的桶的数据是否已经被迁移到新的桶里面：</p> <ul><li>如果是，则需要从新的桶里面查找。</li> <li>如果还没有被迁移，则需要从旧桶中读取。</li></ul></li> <li><p>计算 <code>tophash</code> =&gt; <code>top</code>（也就是 <code>hash</code> 的最高 8 位）</p></li> <li><p>遍历找到的桶的每一个槽（</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>slot/cell
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>）</p> <ul><li>比较 <code>tophash</code> 是否相等</li> <li>如果不等，判断桶后面是否都没有数据了（<code>b.tophash[i] == emptyRest</code>）</li> <li>如果没有数据了，跳出循环 =&gt; 找不到 <code>key</code> 对应的值</li> <li>如果还有数据，则继续遍历下一个槽</li></ul></li> <li><p>如果找到一个槽的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>tophash
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>跟上面计算的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>tophash
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>相等，则比较</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>key
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>是否相等</p> <ul><li>是，则返回对应的值（<strong><code>tophash</code> 和 <code>key</code> 都相等，则表明找到了相应的 <code>key</code>，返回对应的值</strong>）。</li> <li>否，继续遍历下一个槽（依然是先比较 <code>tophash</code>，<code>tophash</code> 相等则再比较 <code>key</code> 是否相等）</li></ul></li> <li><p>溢出桶也找不到，则返回零值（及是否找到的标志）。</p></li></ul> <h3 id="mapaccessk-的实现"><a href="#mapaccessk-的实现" class="header-anchor">#</a> <code>mapaccessK</code> 的实现</h3> <p>对于整型的键值的 <code>map</code>，go 里面有针对优化的实现，但其实代码逻辑上都是差不多的，所以不细说了。下面来看看 <code>mapaccessK</code> 的实现：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 在迭代 map 的时候，返回键值对。</span>
<span class="token comment">// 参数：</span>
<span class="token comment">// t: map 类型元信息（记录了 map 中的 key/value 的类型等信息，比如 key 的大小，可用于计算内存偏移）</span>
<span class="token comment">// h: map 结构体类型（也就是实际的哈希表类型）</span>
<span class="token comment">// key: 需要查找的 key</span>
<span class="token comment">// 返回值：</span>
<span class="token comment">// 第一个返回值：当前遍历到的 key 的指针</span>
<span class="token comment">// 第二个返回值：当前遍历到的 key 对应的值的指针</span>
<span class="token keyword">func</span> <span class="token function">mapaccessK</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// map 是空的</span>
   <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 根据 key 和 hash0 计算 hash</span>
   hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// hash 的掩码，类似 IP 的掩码</span>
   <span class="token comment">//（比如，假设 B = 3，一共有 8 个元素，索引为 0～7，那么掩码 m 表示为二进制就是 111）。</span>
   <span class="token comment">// 用于跟 hash 值做 &amp; 运算（hash &amp; m），得到 hash 对应 bucket 的索引（0～m）</span>
   m <span class="token operator">:=</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
   <span class="token comment">// 根据 hash 计算 bucket 地址，b 是 hash 匹配到的 bucket</span>
   b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 正在扩容，如果 bucket 还没迁移到新的地址，则需要从 oldbuckets 中访问</span>
   <span class="token keyword">if</span> c <span class="token operator">:=</span> h<span class="token punctuation">.</span>oldbuckets<span class="token punctuation">;</span> c <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token comment">// 不是等量扩容，需要从旧桶中读取，所以 m 要移除最高位（右移一位）</span>
      <span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">sameSizeGrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 不是等量扩容，则将 m 除以 2，因为是 2 倍扩容，</span>
         <span class="token comment">// 所以 buckets 的大小为 oldbuckets 长度的 2 倍，</span>
         <span class="token comment">// 除以 2 才是旧的桶数量</span>
         m <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// key 在 oldbuckets 中的地址</span>
      oldb <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">evacuated</span><span class="token punctuation">(</span>oldb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// b 尚未迁移到新的 buckets 中，还在 oldbuckets 中</span>
         <span class="token comment">// 则需要从旧桶中查找</span>
         b <span class="token operator">=</span> oldb
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 计算 tophash</span>
   top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
bucketloop<span class="token punctuation">:</span>
   <span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 从 bucket 中查找，一个 bucket 可以存储的元素个数是 bucketCnt，也就是 8</span>
      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
         <span class="token comment">// tophash 不匹配，肯定不是这个槽</span>
         <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">{</span>
            <span class="token comment">// bucket 剩余的槽是空的，不用再找了，跳出循环</span>
            <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">{</span>
               <span class="token keyword">break</span> bucketloop
            <span class="token punctuation">}</span>
            <span class="token comment">// 继续比较下一个槽</span>
            <span class="token keyword">continue</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// tophash 匹配</span>
         <span class="token comment">// 接下来将这个槽的 key 取出来</span>
         k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token comment">// key 是指针类型</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            k <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 比较 key 跟 k 是否相等</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 相等则读取对应的值（表示找到了匹配的 key 了）</span>
            e <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 值是指针类型</span>
            <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               e <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 找到了，返回键值对</span>
            <span class="token keyword">return</span> k<span class="token punctuation">,</span> e
         <span class="token punctuation">}</span>
         
         <span class="token comment">// 注意：执行到这里，说明 tophash 相等，</span>
         <span class="token comment">// 但是 key 不匹配，仍然需要继续遍历。</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 普通桶和溢出桶的所有槽都找不到，返回 nil</span>
   <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br></div></div><p>这里需要注意的是，如果在扩容的过程中查找，会先判断数据是否已经被迁移到新桶，如果还没有被迁移，则需要从旧的桶中查找。</p> <h3 id="mapaccessk-关键代码"><a href="#mapaccessk-关键代码" class="header-anchor">#</a> <code>mapaccessK</code> 关键代码</h3> <ol><li><code>bucket</code> 的定位代码</li></ol> <div class="language-go line-numbers-mode"><pre class="language-go"><code>m <span class="token operator">:=</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
<span class="token comment">// b 就是定位到的 bucket 所在的内存地址</span>
b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash<span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>bucket</code> 索引（<code>hash &amp; m</code>）的定位方式如下：</p> <p><img src="/images/go/map/15.webp" alt="map_4_2.png"></p> <p>因为 <code>buckets</code> 是指向 <code>bmap</code> 的指针数组，所以我们可以通过 <code>buckets</code> 加上 <code>bucket</code> 的索引，就可以定位到 <code>bucket</code> 的内存地址。 因为每一个 <code>bmap</code> 的大小是 <code>t.bucketsize</code>，所以 <code>bucket</code> 的索引乘以 <code>t.bucketsize</code>，也即 <code>(hash&amp;m)*uintptr(t.bucketsize)</code>，就是 <code>bucket</code> 的相对偏移量。 然后 <code>buckets</code> 的地址加上 <code>bucket</code> 的相对偏移量，就可以定位到 <code>bucket</code> 的内存地址。</p> <p><img src="/images/go/map/16.webp" alt="map_4_3.png"></p> <p>我们需要注意的是，我们计算得到 <code>bucket</code> 的指针后，需要将其转换为 <code>bmap</code> 类型的指针，才能进行后续的操作。</p> <p>然后 <code>key</code> 和 <code>value</code> 也是通过类似的指针运算来定位的。需要说明的是：</p> <ul><li><code>add</code> 函数是做指针算术运算的函数，具体来说就是 <code>add(a, b)</code> 就是 <code>a</code> 地址加上 <code>b</code> 的偏移量，返回的是 <code>unsafe.Pointer</code> 类型的指针。</li> <li><code>unsafe.Pointer(b)</code> 是 <code>bucket</code> 的内存地址</li> <li><code>dataOffset</code> 是 <code>bucket</code> 中第一个 <code>key</code> 的地址偏移量，</li> <li><code>t.keysize</code> 是 <code>key</code> 的大小</li> <li><code>t.elemsize</code> 是 <code>map</code> 值的大小</li> <li><code>bucketCnt</code> 是 <code>bucket</code> 中槽的数量（8 个，预定义的常量）。</li></ul> <p>然后大家可以结合上面的 <code>bmap</code> 内存布局图来理解上面指针计算的代码。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 读取 bucket 中的第 i 个 key。</span>
k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 读取 bucket 中的第 i 个 value</span>
e <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol><li><code>b.tophash[i] == emptyRest</code> 判断的理解</li></ol> <p><img src="/images/go/map/17.webp" alt="map_4_4.png"></p> <p><code>emptyRest</code> 是一个比较特殊的标记，它表示 <code>bucket</code> 中的后续槽都是空的。 在 <code>map</code> 删除元素的时候，会判断后面还有没有元素，如果没有元素的话，就会将 <code>b.tophash[i]</code> 设置为 <code>emptyRest</code>。 这样在查找的时候，就可以通过 <code>b.tophash[i] == emptyRest</code> 来判断后面的槽都是空的，就不需要继续遍历了。</p> <ol><li><code>indirectkey</code> 和 <code>indirectelem</code> 的理解</li></ol> <p>我们发现上面读取 <code>key</code> 和 <code>value</code> 的时候有一个比较特别的操作：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    k <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>相信不少读者第一次看到这几行代码的时候会跟我一样有点懵逼，从 <code>maptype</code> 的定义我们可以看出一点端倪：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>mt <span class="token operator">*</span>maptype<span class="token punctuation">)</span> <span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span> <span class="token comment">// store ptr to key instead of key itself</span>
   <span class="token keyword">return</span> mt<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span><span class="token number">1</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token comment">// 存储了 key 的指针，而不是 key 本身</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mt <span class="token operator">*</span>maptype<span class="token punctuation">)</span> <span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span> <span class="token comment">// store ptr to elem instead of elem itself</span>
   <span class="token keyword">return</span> mt<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span><span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token comment">// 存储了 elem 的指针，而不是 elem 本身</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>简单来说，就是 go 底层在有时候会将 <code>key</code> 和 <code>value</code> 保存为指针，而不是直接保存 <code>key</code> 和 <code>value</code> 本身。 这样一来，go 里面的 <code>map</code> 操作就需要根据 <code>key</code> 和 <code>value</code> 的类型来判断是否需要进行指针解引用，也就是取出实际的 <code>key</code> 和 <code>value</code>。</p> <h2 id="map-写入和修改的设计与实现"><a href="#map-写入和修改的设计与实现" class="header-anchor">#</a> map 写入和修改的设计与实现</h2> <p>在 go 中，<code>map</code> 的写入和修改都是通过 <code>mapassign</code> 函数来实现的，因为写入和修改本质上是同一个操作，都是找到对应的 <code>key</code>，然后修改对应的值。</p> <h3 id="mapassign-的实现步骤"><a href="#mapassign-的实现步骤" class="header-anchor">#</a> <code>mapassign</code> 的实现步骤</h3> <ol><li>计算 <code>key</code> 的 <code>hash</code> 值。</li> <li>如果 <code>buckets</code> 还没有初始化，则进行分配内存。</li> <li>计算出 <code>bucket</code> 的索引。</li> <li>如果正在扩容，则迁移当前即将要操作的 <code>bucket</code>（也就是上一步计算出来的索引对应的 <code>bucket</code>）。</li> <li>计算 <code>tophash</code>。</li> <li>遍历 <code>bucket</code> 中的槽，记录下第一个空的槽的 <code>tophash</code> 索引指针、<code>key</code> 指针，<code>value</code> 指针。如果最后找不到 <code>key</code> 的时候，会插入到这里。</li> <li>如果 <code>bucket</code> 的所有桶都找不到 <code>key</code>，则判断是否需要扩容，需要的话就进行扩容，然后再执行 6 的操作。</li> <li>另外一种情况，不需要扩容，而且 <code>bucket</code> 以及它的溢出桶也满了，则需要新建溢出桶来保存 <code>key</code></li> <li>最后，将 <code>tophash/key/value</code> 插入到需要 <code>bucket</code> 第一个空的槽。又或者如果已经存在，对 <code>value</code> 进行更新。</li></ol> <h3 id="mapassign-图解"><a href="#mapassign-图解" class="header-anchor">#</a> <code>mapassign</code> 图解</h3> <p>可以分两种情况：</p> <ol><li>普通桶和溢出桶都找不到 <code>key</code> 的情况下，将 <code>key</code> 插入桶中第一个空的槽</li></ol> <p><img src="/images/go/map/18.webp" alt="map_5_1.png"></p> <ol><li>在 <code>bucket</code> 中找到了 <code>key</code>，则会对其进行更新</li></ol> <p><img src="/images/go/map/19.webp" alt="map_5_2.png"></p> <p>对于 <code>key</code> 和 <code>value</code> 的存储，有以下两种情况：</p> <ol><li>直接保存在 <code>bucket</code> 中：</li></ol> <p>这样在我们需要修改 <code>key</code>/<code>value</code> 的时候，通过 <code>bucket</code> 加上 <code>索引 * keysize/valuesize</code> 就可以得到对应键值存储的实际内存。</p> <p><img src="/images/go/map/20.webp" alt="map_5_4.png"></p> <ol><li>在 <code>bucket</code> 中保存的是 <code>key/value</code> 的内存地址（<code>unsafe.Pointer</code>）类型</li></ol> <p>这样如果我们需要修改/读取实际的键值的时候，就需要先从 <code>bucket</code> 中获取这个指针，然后解引用得到实际存储键值的内存指针。</p> <p><img src="/images/go/map/21.webp" alt="map_5_3.png"></p> <p>注意：在我们做如下运算的时候（假设 <code>bucket</code> 没有存储实际的 <code>key</code>，而是存储了 <code>key</code> 的指针）：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>得到的结果是，指向 <code>keys[i]</code>（也就是第 <code>i</code> 个 <code>key</code>）的指针（<code>unsafe.Pointer</code> 类型）。 如果 <code>key</code> 保存在 <code>bucket</code> 中，通过这个指针我们就可以读写 <code>key</code> 了。 否则，表示这个指针指向的内存存储的只是一个指针，如果我们需要修改实际的 <code>key</code>， 就需要通过 <code>key</code> 指针（<code>A</code>）拿到这里存储的指针（<code>B</code>），然后再通过 <code>B</code> 来修改实际的 <code>key</code>。</p> <p><img src="/images/go/map/22.webp" alt="map_5_5.png"></p> <blockquote><p>对 <code>value</code> 的读写同理。</p></blockquote> <h3 id="mapassign-源码剖析"><a href="#mapassign-源码剖析" class="header-anchor">#</a> <code>mapassign</code> 源码剖析</h3> <blockquote><p>扩容的操作后面会有解析，这一节就先不细说了。</p></blockquote> <p>这个函数的定义如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 功能：插入 key 或者修改 map 中的 key</span>
<span class="token comment">// 参数：</span>
<span class="token comment">// t：map 类型元信息</span>
<span class="token comment">// h：map 结构体（实际保存键值对的地方）</span>
<span class="token comment">// key：我们要修改或者插入的 key</span>
<span class="token comment">// 返回值：</span>
<span class="token comment">// 只有一个，那就是我们插入或者修改之后的值。</span>
<span class="token keyword">func</span> <span class="token function">mapassign</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span>
   <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">plainError</span><span class="token punctuation">(</span><span class="token string">&quot;assignment to entry in nil map&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 并发写，直接报错</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent map writes&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 计算 key 的哈希值（是一个无符号整数）</span>
   hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token comment">// 在调用 t.hasher 之后设置 hashWriting，</span>
   <span class="token comment">// 因为 t.hasher 可能会 panic，在这种情况下，我们实际上还没有进行写操作。</span>
   <span class="token comment">// 写标记。（如果读操作发现有写标志则会报错）</span>
   h<span class="token punctuation">.</span>flags <span class="token operator">^=</span> hashWriting

   <span class="token comment">// 如果 buckets 是空，则新建一个 bucket</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>buckets <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      h<span class="token punctuation">.</span>buckets <span class="token operator">=</span> <span class="token function">newobject</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucket<span class="token punctuation">)</span> <span class="token comment">// newarray(t.bucket, 1)</span>
   <span class="token punctuation">}</span>

again<span class="token punctuation">:</span>
   <span class="token comment">// bucket 指示第几个 bucket（命名貌似有点不合适）</span>
   bucket <span class="token operator">:=</span> hash <span class="token operator">&amp;</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
   <span class="token comment">// 正在扩容的话，则将 bucket 迁移到新桶</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">growWork</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> bucket<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// b 为即将要写入的 bucket</span>
   b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> bucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 计算 key 的 tophash</span>
   top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>

   <span class="token keyword">var</span> inserti <span class="token operator">*</span><span class="token builtin">uint8</span>         <span class="token comment">// 要插入的 tophash 地址</span>
   <span class="token keyword">var</span> insertk unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 要插入的键地址</span>
   <span class="token keyword">var</span> elem unsafe<span class="token punctuation">.</span>Pointer    <span class="token comment">// 要插入的值地址</span>
bucketloop<span class="token punctuation">:</span>
   <span class="token keyword">for</span> <span class="token punctuation">{</span>
      <span class="token comment">// 循环 bucket 的槽</span>
      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">{</span>
            <span class="token comment">// tophash 不匹配，并且当前槽为空，则记录要插入的位置（找不到 key 的时候，最后会插入到这里）</span>
            <span class="token keyword">if</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> inserti <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
               inserti <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
               insertk <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
               elem <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
               <span class="token comment">// 为什么找到了可以插入的地方，不中断循环？</span>
               <span class="token comment">// 原因是，这个函数是寻找已经存在的 key 的（插入和修改都是用这个函数），</span>
               <span class="token comment">// 如果对应的 key 保存到了后面的槽里面的话，这里直接中断循环就是不对的。</span>
               <span class="token comment">// 因为在这种情况下，理应更新后面的那个槽。</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// bucket 没有找到对应的 key，同时 bucket 中剩余的槽都是空的。</span>
            <span class="token comment">// （这意味着 map 中找不到 key，需要插入这个 key 了）</span>
            <span class="token comment">// 中止对 bucket 里面槽的遍历。</span>
            <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">{</span>
               <span class="token keyword">break</span> bucketloop
            <span class="token punctuation">}</span>
            <span class="token comment">// 虽然找到了空闲的槽，但还是要查看 bucket 中的其他槽，看 key 是否已经存在。</span>
            <span class="token comment">// （如果存在的话，修改 key 对应的值就可以了，当然这个函数里面不会修改，而是返回值的地址，从函数外部修改）</span>
            <span class="token comment">// 这个很好理解，保存值的指针都拿到了，想修改就很简单了。</span>
            <span class="token comment">// 如果 key 已经存在，则返回已存在 key 的对应的 elem 的地址。</span>
            <span class="token keyword">continue</span>
         <span class="token punctuation">}</span>

         <span class="token comment">// tophash 相等，依然需要比较 key 是否相等。</span>
         k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            k <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 但是 key 不想等，继续比较下一个槽</span>
         <span class="token keyword">if</span> <span class="token operator">!</span>t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// tophash 相等、key 也相等，说明已经存在，更新它即可</span>
         <span class="token comment">// 用 key 更新 k</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">needkeyupdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">,</span> k<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 计算 value 所在的地址</span>
         elem <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token comment">// 找到了 key，直接跳转到 done</span>
         <span class="token keyword">goto</span> done
      <span class="token punctuation">}</span>
      <span class="token comment">// 当前的桶里面所有槽都找不到。</span>
      <span class="token comment">// 继续遍历溢出桶（在溢出桶中查找 key 是否存在/有没有空余的槽）</span>
      ovf <span class="token operator">:=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
      <span class="token keyword">if</span> ovf <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
         <span class="token comment">// 溢出桶也找不到，跳出循环</span>
         <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// b 指向下一个溢出桶，下次循环遍历这个溢出桶</span>
      b <span class="token operator">=</span> ovf
   <span class="token punctuation">}</span>

   <span class="token comment">// 未找到 key，需要插入这个新的 key。</span>
   
   <span class="token comment">// 如果我们达到了最大负载系数或者我们有太多的溢出桶，</span>
   <span class="token comment">// 同时，如果还没有开始扩容，那么现在开始扩容。</span>
   <span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">overLoadFactor</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">tooManyOverflowBuckets</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>noverflow<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">hashGrow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">)</span>
      <span class="token comment">// 扩容哈希表会使所有内容无效，因此需要再次尝试插入。</span>
      <span class="token comment">// （上面循环获取到的插入位置的指针已经失效了，扩容之后插入的位置改变了，所以需要再次计算要插入的 bucket，以及要插入的槽中的位置）</span>
      <span class="token keyword">goto</span> again
   <span class="token punctuation">}</span>

   <span class="token comment">// 表明没有找到可以插入的地方，则新建一个溢出桶来保存，</span>
   <span class="token comment">// 溢出桶的第一个元素就用来保存 key，返回溢出桶第一个元素 elem 的地址</span>
    <span class="token comment">// （这意味着，我们要插入的桶，所有的槽都有数据了，并且也不是我们要找的 key，所需要溢出桶了）</span>
    <span class="token keyword">if</span> inserti <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当前存储桶及其连接的所有溢出存储桶已满，分配一个新的溢出桶。</span>
      newb <span class="token operator">:=</span> h<span class="token punctuation">.</span><span class="token function">newoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
      <span class="token comment">// 溢出桶的第一个 tophash 的指针</span>
      inserti <span class="token operator">=</span> <span class="token operator">&amp;</span>newb<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      <span class="token comment">// 溢出桶的第一个 key 的指针</span>
      insertk <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newb<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
      <span class="token comment">// 溢出桶的第一个 value 的指针</span>
      elem <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>insertk<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 在插入位置存储新 key/elem</span>
   <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">// 这意味着需要给 key 分配内存来保存它</span>
      kmem <span class="token operator">:=</span> <span class="token function">newobject</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">)</span>           <span class="token comment">// 给 key 分配内存（kmem 是保存 key 的内存指针）</span>
      <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>insertk<span class="token punctuation">)</span> <span class="token operator">=</span> kmem <span class="token comment">// bucket 里面的 key 保存新分配的内存指针</span>
      insertk <span class="token operator">=</span> kmem                     <span class="token comment">// insertk 指向新分配的地址（跟上一行并不重复）</span>
      <span class="token comment">// 最终效果是，insertk 和 kmem 指向了新分配的保存 key 的内存地址。</span>
      <span class="token comment">// 当然，insertk = kmem 不需要也可以，但这样一来下面也要改成：</span>
      <span class="token comment">// if t.indirectkey() {</span>
      <span class="token comment">//     typedmemmove(t.key, kmem, key)</span>
      <span class="token comment">// } else {</span>
      <span class="token comment">//     typedmemmove(t.key, insertk, key)</span>
      <span class="token comment">// }</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vmem <span class="token operator">:=</span> <span class="token function">newobject</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elem<span class="token punctuation">)</span>       <span class="token comment">// 给 elem 分配内存</span>
      <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span> <span class="token operator">=</span> vmem <span class="token comment">// bucket 里面 elem 的槽保存新分配的地址</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 移动 key 到 insertK（保存新的 key）</span>
   <span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">,</span> insertk<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
   <span class="token comment">// 保存 tophash</span>
   <span class="token operator">*</span>inserti <span class="token operator">=</span> top
   <span class="token comment">// map 元素个数 +1</span>
   h<span class="token punctuation">.</span>count<span class="token operator">++</span>

done<span class="token punctuation">:</span>
   <span class="token comment">// 并发写则报错（多个协程同时写 map）</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 写标志被清除了</span>
      <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent map writes&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 清除写标志</span>
   h<span class="token punctuation">.</span>flags <span class="token operator">&amp;^=</span> hashWriting
    <span class="token comment">// bucket 中的值保存的是指针，这个时候就不能返回 bucket 中值的地址了，而是返回 bucket 中值指向的另外一个地址的指针。</span>
   <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获取指向 elem 实际存储地址的指针</span>
      elem <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 返回存储值的指针</span>
   <span class="token keyword">return</span> elem
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br></div></div><p>有几点要注意的：</p> <ol><li>go 中 <code>map</code> 是不允许并发读写的，如果有，直接报错。</li> <li>这里面我们看到了有扩容的操作，<strong>在 go 中，<code>map</code> 的扩容发生在插入、修改和删除的时候，是一种渐进式扩容的方式，每次扩容会迁移两个 <code>bucket</code></strong>，详细的后面讲到扩容的时候会细说。</li> <li>在 <code>bucketloop</code> 这个循环中，会记录下第一个空的槽，在找不到 <code>key</code> 的时候会进行插入操作。</li> <li>如果找到，则返回保存值的地址的指针。如果没找到，则将 <code>key</code> 插入到上一步找到的空的槽中，如果也没有空的槽，则会新建溢出桶来保存新插入的 <code>key</code>。</li> <li>在这个函数中，会判断插入之后是否超过负载因子，又或者溢出桶是否太多，来决定是否扩容。</li></ol> <blockquote><p>关于 <code>key</code> 匹配的过程，其实跟上面的 <code>mapaccess</code> 是一样的过程，先找普通桶，然后查找溢出桶。</p></blockquote> <h2 id="map-删除-key-的实现"><a href="#map-删除-key-的实现" class="header-anchor">#</a> map 删除 key 的实现</h2> <p>对于删除操作，其实有一些操作上面已经说过了，如如何定位一个 <code>key</code>。所以下面的讲述会侧重讲解跟删除操作密切相关的操作。</p> <h3 id="map-删除-key-的步骤"><a href="#map-删除-key-的步骤" class="header-anchor">#</a> map 删除 key 的步骤</h3> <ol><li>定位 <code>key</code> 所在 <code>bucket</code>，计算 <code>tophash</code>。</li> <li>遍历 <code>bucket</code> 的每一个槽，比较 <code>tophash</code> 以及 <code>key</code>，普通桶中查找不到会继续查找溢出桶。</li> <li>如果查找到 <code>key</code> 的话，会清空对应 <code>key</code> 在 <code>bucket</code> 内存中的 <code>tophash</code>、<code>key</code> 和 <code>value</code>。</li> <li>如果后面的槽没有元素了，则设置 <code>emptyRest</code> 标记。<strong>这样在后续查找的时候就可以避免不必要的搜索了。</strong></li></ol> <h3 id="map-删除过程图解"><a href="#map-删除过程图解" class="header-anchor">#</a> map 删除过程图解</h3> <p>删除的过程比较简单，定位 <code>key</code> 的过程上面有过详细的讲解了，这里只详细画图阐述一下 <code>emptyRest</code> 的标记设置：</p> <p><img src="/images/go/map/23.webp" alt="map_6_1.png"></p> <h3 id="map-删除源码剖析"><a href="#map-删除源码剖析" class="header-anchor">#</a> map 删除源码剖析</h3> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 从 map 中删除 key（以及对应的 elem）</span>
<span class="token comment">// 参数：</span>
<span class="token comment">// t：map 类型元数据的结构体</span>
<span class="token comment">// h：实际保存键值对的桶</span>
<span class="token comment">// key：需要删除的 key</span>
<span class="token keyword">func</span> <span class="token function">mapdelete</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> key unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// map 是空的</span>
   <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 key 的类型不可哈希则 panic</span>
      <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">hashMightPanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// see issue 23734</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 并发写则抛出 fatal 错误</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent map writes&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 计算 key 的 hash</span>
   hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token comment">// 在调用 t.hasher 之后设置 hashWriting，</span>
   <span class="token comment">// 因为 t.hasher 可能会 panic ，在这种情况下，我们实际上没有执行 write（delete）。</span>
   h<span class="token punctuation">.</span>flags <span class="token operator">^=</span> hashWriting

   <span class="token comment">// 计算 key 落在哪一个 bucket 中</span>
   bucket <span class="token operator">:=</span> hash <span class="token operator">&amp;</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
   <span class="token comment">// 如果正在扩容，则迁移 bucket 到新的内存地址中（迁移到新的桶）</span>
   <span class="token comment">// (迁移当前正在访问的 bucket)</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">growWork</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> bucket<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 获取 bucket 实例（key 所在的 bucket）</span>
   b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> bucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 记录原始的 bucket 实例</span>
   <span class="token comment">//（目的是为了方便加 emptyRest 标记）</span>
   bOrig <span class="token operator">:=</span> b
   <span class="token comment">// 计算 tophash</span>
   top <span class="token operator">:=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
search<span class="token punctuation">:</span>
   <span class="token comment">// 在 bucket 内进行搜索</span>
   <span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 遍历 bucket 的每一个槽</span>
      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
         <span class="token comment">// tophash 不想等的时候，需要判断后面是否还有元素</span>
         <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> top <span class="token punctuation">{</span>
            <span class="token comment">// 从 i 开始 bucket 后面都是空的了，</span>
            <span class="token comment">// 中止搜索过程（去除写标记，函数执行完毕）</span>
            <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> emptyRest <span class="token punctuation">{</span>
               <span class="token keyword">break</span> search
            <span class="token punctuation">}</span>
            <span class="token comment">// 还有元素，继续搜索</span>
            <span class="token keyword">continue</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// tophash 相等</span>
         <span class="token comment">// 获取 key 在 bucket 中的内存地址</span>
         k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
         k2 <span class="token operator">:=</span> k <span class="token comment">// k2 代表的是指向实际存储 key 的指针（unsafe.Pointer） </span>
         <span class="token comment">// k2 指向原始的地址</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            k2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// key 不想等，继续检查下一个 slot（continue）</span>
         <span class="token keyword">if</span> <span class="token operator">!</span>t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> k2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 只有在键中有指针时才清除键。</span>
         <span class="token comment">// 清空 key 的内存</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 清除 bucket 里面保存 key 的内存</span>
            <span class="token comment">//（bucket 只是存储了 key 的指针）</span>
            <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token comment">// 清除包含指针的 key</span>
            <span class="token function">memclrHasPointers</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 值的地址</span>
         e <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token comment">// 清空值</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 清除 bucket 里面保存 elem 的内存</span>
            <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> t<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token comment">// 清除包含指针的 elem（值）</span>
            <span class="token function">memclrHasPointers</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> t<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 清除不包含指针的 elem 的内存</span>
            <span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> t<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// tophash 设置为空标记</span>
         b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> emptyOne
         <span class="token comment">// 如果 bucket 现在以一堆 emptyOne 状态结束，</span>
         <span class="token comment">// 将这些状态更改为 emptyRest 状态。</span>
         <span class="token comment">// 最好将其作为一个单独的函数，但 for 循环当前不可内联。（所以用 goto）</span>
         <span class="token keyword">if</span> i <span class="token operator">==</span> bucketCnt<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
            <span class="token comment">// 要删除的 key 是 bucket 里面的最后一个元素。</span>
            <span class="token comment">// 同时还有溢出桶，并且溢出桶里面还有元素 =&gt; 表明当前删除的 key 不是 bucket 以及溢出桶里面的最后一个元素。</span>
            <span class="token keyword">if</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>tophash<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> emptyRest <span class="token punctuation">{</span>
               <span class="token comment">// 不是最后一个元素</span>
               <span class="token keyword">goto</span> notLast
            <span class="token punctuation">}</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 要删除的 key 不是 bucket 的最后一个元素。</span>
            <span class="token comment">// 并且后面还有元素。</span>
            <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> emptyRest <span class="token punctuation">{</span>
               <span class="token keyword">goto</span> notLast
            <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
         
         <span class="token comment">// 执行到这里的时候，表明刚刚删除的 key 是 bucket 以及溢出桶中的最后一个元素。</span>
         <span class="token comment">// 如果不是最后一个元素的话，上面的 if 判断已经跳转了。</span>
         
         <span class="token comment">// 下面的 for 循环做的事情是：</span>
         <span class="token comment">// 1. 将当前 key 的标志设置为：emptyRest，表示后面没有元素了。</span>
         <span class="token comment">// 2. 从 bucket 的第一个 key 出发遍历所有的槽（包含溢出桶），</span>
         <span class="token comment">//    将最后一个元素以后一直到被删除的 key 的中间的所有槽标记为 emptyRest</span>
         <span class="token comment">// 目的是，在后续遍历的时候可以避免一些不必要的查找操作，见到 emptyRest 就可以直接中断循环了。</span>

         <span class="token comment">// 例子，bucket 里 key 的内存布局为 | nil | a | nil | nil | b | nil |</span>
         <span class="token comment">// b 被删除的时候，b 以及 a 后面的两个元素都要标记为 emptyRest（溢出桶同理）</span>
         <span class="token keyword">for</span> <span class="token punctuation">{</span>
            <span class="token comment">// 给当前遍历到的 bucket 槽打上 emptyRest 标记</span>
            b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> emptyRest
            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 当前的桶遍历完了（因为是从后往前遍历）</span>
               <span class="token comment">// b 是普通桶（不是溢出桶）</span>
               <span class="token keyword">if</span> b <span class="token operator">==</span> bOrig <span class="token punctuation">{</span>
                  <span class="token comment">// 所有空的槽都处理完了</span>
                  <span class="token keyword">break</span>
               <span class="token punctuation">}</span>
               <span class="token comment">// b 是上一次循环处理的桶</span>
               c <span class="token operator">:=</span> b <span class="token comment">// c 是上一个 b </span>
               <span class="token comment">// 查找上一个存储桶，在其最后一个条目处继续。 </span>
               <span class="token comment">// 如：bucket &lt;- overflow1 &lt;- overflow2 &lt;- ... &lt;- overflowN</span>
               <span class="token comment">// 假设 c 是 overflow2，那么下面的循环过后，b 就是 overflow1</span>
               <span class="token comment">// prevB.overflow = b  =&gt; 找 prevB，也即：遍历完当前的桶，找前一个桶。</span>
               <span class="token keyword">for</span> b <span class="token operator">=</span> bOrig<span class="token punctuation">;</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token punctuation">}</span>
               <span class="token comment">// b 指向了前一个 bucket（前一个桶）</span>

               <span class="token comment">// 处理前一个 bucket 的最后一个槽</span>
               i <span class="token operator">=</span> bucketCnt <span class="token operator">-</span> <span class="token number">1</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token comment">// 继续处理前一个槽</span>
               i<span class="token operator">--</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 找到了一个不是空的槽，表示有数据了，不需要再打 emptyRest 标记了。</span>
            <span class="token keyword">if</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> emptyOne <span class="token punctuation">{</span>
               <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 被删除的元素如果不是最后一个元素，直接跳转到这里。</span>
      notLast<span class="token punctuation">:</span>
         <span class="token comment">// 找到了元素，并且删除了。</span>
         <span class="token comment">// map 的元素个数减 1</span>
         h<span class="token punctuation">.</span>count<span class="token operator">--</span>
         <span class="token comment">// 重置哈希种子，使攻击者更难重复触发哈希冲突。见 issue 25237。</span>
         <span class="token keyword">if</span> h<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            h<span class="token punctuation">.</span>hash0 <span class="token operator">=</span> <span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 在 bucket 内找到了对应的元素，并且删除了。</span>
         <span class="token comment">// 退出循环。</span>
         <span class="token keyword">break</span> search
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 如果当前没有写标记，则抛出 fatal 错误（不能并发读写 map）</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent map writes&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 清除写标记</span>
   h<span class="token punctuation">.</span>flags <span class="token operator">&amp;^=</span> hashWriting
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br><span class="line-number">169</span><br><span class="line-number">170</span><br><span class="line-number">171</span><br><span class="line-number">172</span><br><span class="line-number">173</span><br></div></div><p>注意：</p> <ol><li>go <code>map</code> 不允许并发写，所以如果发现有并发读写，则抛出 fatal 错误。</li> <li>如果删除的是最后一个元素，则需要往前遍历，将每一个空的槽设置为 <code>emptyRest</code> 状态。</li> <li>如果是 <code>indirectkey</code>、<code>indirectelem</code>，在删除的时候，只会将 <code>bucket</code> 中的指针置为 <code>nil</code>，对于实际的 <code>key</code> 和 <code>value</code> 不会进行处理。（无所谓，GC 会出手）。</li></ol> <h2 id="map-的扩容实现"><a href="#map-的扩容实现" class="header-anchor">#</a> map 的扩容实现</h2> <p>从上面的讲解中，我们知道，底层存储 <code>key/value</code>  的是 <code>bucket</code>，而 <code>bucekt</code> 的大小是一段有一定大小的连续内存。 如果我们插入的元素过多，我们初始化时分配的 <code>bucket</code> 的内存就会放不下了，这个时候 go 的 <code>map</code> 会有两种方式解决这个问题：</p> <ol><li>使用溢出桶（在 <code>bmap</code> 的上再链接一个 <code>bmap</code>，也就是溢出桶，普通桶放不下的时候，就放溢出桶中）</li> <li>分配新的更大的空间来存放现有的这些键值对。在 go 里面新分配的内存空间将会是原来的 2 倍。</li></ol> <h3 id="map-扩容的条件"><a href="#map-扩容的条件" class="header-anchor">#</a> map 扩容的条件</h3> <p><code>map</code> 的扩容发生在插入或者修改或者删除 <code>key</code> 的时候，扩容的条件在 <code>mapassign</code> 中写了：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 条件：</span>
<span class="token comment">// 1. 没有在扩容</span>
<span class="token comment">// 2. 超过负载因子</span>
<span class="token comment">// 3. 太多溢出桶</span>
<span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">overLoadFactor</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">tooManyOverflowBuckets</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>noverflow<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">hashGrow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 判断是否超过负载因子。</span>
<span class="token keyword">func</span> <span class="token function">overLoadFactor</span><span class="token punctuation">(</span>count <span class="token builtin">int</span><span class="token punctuation">,</span> B <span class="token builtin">uint8</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> count <span class="token operator">&gt;</span> bucketCnt <span class="token operator">&amp;&amp;</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">&gt;</span> loadFactorNum<span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">bucketShift</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token operator">/</span>loadFactorDen<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 判断是否有太多的溢出桶了</span>
<span class="token comment">// 多的标准是：</span>
<span class="token comment">// B &lt;= 15 的时候，溢出桶数量大于 2^B 的时候</span>
<span class="token comment">// B &gt; 15 的时候，溢出桶的数量大于 2^15 的时候</span>
<span class="token keyword">func</span> <span class="token function">tooManyOverflowBuckets</span><span class="token punctuation">(</span>noverflow <span class="token builtin">uint16</span><span class="token punctuation">,</span> B <span class="token builtin">uint8</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果阈值太低，我们会做额外的工作。</span>
   <span class="token comment">// 如果阈值太高，则增长和收缩的 map 会保留大量未使用的内存。</span>
   <span class="token comment">// “太多” 意味着（大约）与常规桶一样多的溢出桶。</span>
   <span class="token comment">// 有关详细信息，请参见incrnoverflow。</span>
   <span class="token comment">// B &gt; 15 =&gt; 2 ^ 15，B &lt;= 15 =&gt; 2 ^ B</span>
   <span class="token keyword">if</span> B <span class="token operator">&gt;</span> <span class="token number">15</span> <span class="token punctuation">{</span>
      B <span class="token operator">=</span> <span class="token number">15</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> noverflow <span class="token operator">&gt;=</span> <span class="token function">uint16</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>B<span class="token operator">&amp;</span><span class="token number">15</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="hashgrow-实现"><a href="#hashgrow-实现" class="header-anchor">#</a> hashGrow 实现</h3> <p><code>hashGrow</code> 是被用来分配新的内存空间的，新的内存空间将被用来保存旧的 <code>buckets</code>。<strong>需要注意的是，这个函数里面并没有做数据迁移的操作。</strong> go 的 <code>map</code> 扩容的时候，数据迁移的方式是渐进式扩容，在我们插入/修改/删除 <code>key</code> 的时候会迁移 2 个 <code>bucket</code>，这样可以避免性能的瞬时抖动。 我们熟知的 <code>redis</code> 的扩容过程也是渐进式扩容的。</p> <p>下面是 <code>hashGrow</code> 的实现源码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// hash 扩容（这个方法只是分配了空间，实际上还没有做数据复制的操作）</span>
<span class="token comment">// 参数：</span>
<span class="token comment">// t：map 类型元信息</span>
<span class="token comment">// h：实际保存键值对的结构体</span>
<span class="token keyword">func</span> <span class="token function">hashGrow</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 扩容的两种情况：</span>
   <span class="token comment">// 1、如果我们达到了负载系数，就要进行 2 倍扩容。</span>
   <span class="token comment">// 2、否则，如果溢出桶太多，进行等量扩容。</span>
   bigger <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token comment">// 尚未超过负载因子，进行等量扩容</span>
   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">overLoadFactor</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      bigger <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 等量扩容</span>
      h<span class="token punctuation">.</span>flags <span class="token operator">|=</span> sameSizeGrow
   <span class="token punctuation">}</span>
   <span class="token comment">// 记录旧的 buckets</span>
   oldbuckets <span class="token operator">:=</span> h<span class="token punctuation">.</span>buckets
   <span class="token comment">// 分配新的内存空间，oldbuckets 将会被渐进式迁移到 newbuckets 中</span>
   newbuckets<span class="token punctuation">,</span> nextOverflow <span class="token operator">:=</span> <span class="token function">makeBucketArray</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">.</span>B<span class="token operator">+</span>bigger<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>

   <span class="token comment">// flags 标记有使用旧桶</span>
   <span class="token comment">// 正在迭代的时候扩容</span>
   <span class="token comment">// 先把 h.flags 中的迭代标记位清除。</span>
   <span class="token comment">// 最后如果发现 h.flags 中还有迭代标记位，说明在扩容的过程中有新的迭代操作，</span>
   <span class="token comment">// 那就把它转移到 oldIterator 中。</span>
   flags <span class="token operator">:=</span> h<span class="token punctuation">.</span>flags <span class="token operator">&amp;^</span> <span class="token punctuation">(</span>iterator <span class="token operator">|</span> oldIterator<span class="token punctuation">)</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>iterator <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      flags <span class="token operator">|=</span> oldIterator
   <span class="token punctuation">}</span>
   <span class="token comment">// 提交扩容操作</span>
   h<span class="token punctuation">.</span>B <span class="token operator">+=</span> bigger <span class="token comment">// 加上扩容的数量</span>
   h<span class="token punctuation">.</span>flags <span class="token operator">=</span> flags
   h<span class="token punctuation">.</span>oldbuckets <span class="token operator">=</span> oldbuckets <span class="token comment">// 记录旧桶</span>
   h<span class="token punctuation">.</span>buckets <span class="token operator">=</span> newbuckets    <span class="token comment">// 指向新的桶数组</span>
   h<span class="token punctuation">.</span>nevacuate <span class="token operator">=</span> <span class="token number">0</span>           <span class="token comment">// 0 个桶已完成迁移（当前函数只是分配空间，不做迁移）</span>
   h<span class="token punctuation">.</span>noverflow <span class="token operator">=</span> <span class="token number">0</span>           <span class="token comment">// 所有溢出桶没有了（移动到了 oldoverflow）</span>

   <span class="token comment">// 记录扩容前的溢出桶</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>extra <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>overflow <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>oldoverflow <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
         <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;oldoverflow is not nil&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>oldoverflow <span class="token operator">=</span> h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>overflow
      h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>overflow <span class="token operator">=</span> <span class="token boolean">nil</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 扩容之后，h.B+bigger &gt;= 4 了，预分配了溢出桶（扩容前没有溢出桶）</span>
   <span class="token comment">// 所以这里要记录溢出桶</span>
   <span class="token keyword">if</span> nextOverflow <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> h<span class="token punctuation">.</span>extra <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
         h<span class="token punctuation">.</span>extra <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>mapextra<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>nextOverflow <span class="token operator">=</span> nextOverflow
   <span class="token punctuation">}</span>

   <span class="token comment">// 哈希表数据的实际迁移过程是通过 growWork() 和 evacuate() 增量完成的。</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><h3 id="数据迁移的两条线"><a href="#数据迁移的两条线" class="header-anchor">#</a> 数据迁移的两条线</h3> <p>go <code>map</code> 在扩容的时候，数据迁移会有两条线进行：</p> <ol><li>从第一个 <code>bucket</code> 开始迁移。</li> <li>插入、修改、删除的时候，<code>key</code> 的哈希值定位到的 <code>bucket</code> 会被迁移。</li></ol> <p>具体如下图：</p> <p><img src="/images/go/map/24.webp" alt="map_7_1.png"></p> <blockquote><p>如果已经被迁移，则不再需要迁移。</p></blockquote> <p>这样一来就可以保证在一定的操作次数之后，全部 <code>bucket</code> 都被迁移。就算你每次插入、修改、删除都是同一个 <code>key</code>（也就是同一个 <code>bucket</code>）， 我们第一条线的迁移都会在每次写操作的时候，迁移一个 <code>bucket</code>。这样无论如何，写操作到了一定次数之后，所有的 <code>bucket</code> 都会被迁移了。</p> <h3 id="什么时候-bucket-迁移之后下标会改变"><a href="#什么时候-bucket-迁移之后下标会改变" class="header-anchor">#</a> 什么时候 bucket 迁移之后下标会改变？</h3> <p>当然这里说的是增量扩容，如果是等量扩容，<code>bucket</code> 的下标不会改变。</p> <p>先说答案：<code>hash &amp; m</code> 的最高位是 1 的时候。</p> <p>我们知道，在定位 <code>bucket</code> 的时候是通过 <code>hash &amp; m</code> 的方式来定位 <code>bucket</code> 的索引的（具体可以看上面定位 <code>key</code> 的那一节）， 而 2 倍扩容之后，<code>bucket</code> 的长度是原来的 2 倍，转换为二进制的时候，就是在原来的基础上多了一位，所以 <code>hash &amp; m</code> 的结果就会多一位， 而最高的那个二进制位如果是 1，说明 <code>hash &amp; m</code> 的结果是大于新的 <code>bucket</code> 数组长度的一半的（<strong>也就是比原来的索引都要大</strong>）。 那么会最高位是 1 会比原来的索引会大多少呢？答案是 <code>bucket</code> 数组的长度的一半（也就是 <code>2^(B-1)</code>）：</p> <p><img src="/images/go/map/25.webp" alt="map_7_2.png"></p> <p>我们可以再看看之前的那个计算 <code>bucket</code> 索引的图：</p> <p><img src="/images/go/map/26.webp" alt="map_7_3.png"></p> <p>我们会发现，当 <code>B = 3</code> 的时候，不管 <code>hash</code> 是什么，<code>hash &amp; m</code> 的结果都是 <code>0~7</code>。 而只有当 <code>B = 4</code> 的时候，<code>hash &amp; m</code> 的结果才有可能落入 <code>8~15</code> 范围内，而且只有 <code>hash &amp; m</code> 的最高位是 1 的时候才有可能。</p> <p><strong>所以结论是，当 <code>hash &amp; m</code> 的最高位是 1 的时候，<code>bucket</code> 的下标就会改变。</strong> 而 <code>hash % m</code> 的其他位跟之前是一样的，所以下标增加的范围其实就是 <code>2^(B - 1)</code>，也就是旧的 <code>buckets</code> 的个数。</p> <h3 id="bucket-迁移图解"><a href="#bucket-迁移图解" class="header-anchor">#</a> bucket 迁移图解</h3> <p><img src="/images/go/map/27.webp" alt="map_7_4.png"></p> <p>说明：</p> <ul><li><code>oldbuckets</code> 是迁移前的桶，<code>buckets</code> 是迁移后的桶（也就是当前的 <code>h.buckets</code>）。</li> <li><code>hash &amp; m</code> 为 <code>0xxx</code> 的时候，会迁移到 <code>x</code> 这个 <code>bucket</code> 中。</li> <li><code>hash &amp; m</code> 为 <code>1xxx</code> 的时候，会迁移到 <code>x + 2^(B-1)</code> 这个 <code>bucket</code> 中（也就是 <code>y</code> 中），因为 <code>1000</code> 就是 <code>2^(4 - 1)</code>。</li></ul> <p>假设需要迁移的是 <code>oldbucket</code>，下标为 <code>3</code>，那么 <code>oldbucket</code> 里面的 <code>key</code> 可能迁移的位置只可能是右边的 <code>x</code> 和 <code>y</code> 指向的 <code>bucket</code>。 这取决于 <code>oldbucket</code> 里面的 <code>key</code> 哈希值的倒数第 <code>4</code> 位； 如果是 <code>0</code>，那么就迁移到 <code>x</code> 指向的 <code>bucket</code>，如果是 <code>1</code>，那么就迁移到 <code>y</code> 指向的 <code>bucket</code>。</p> <p><code>oldbucket</code> 中所有的 <code>key</code> 只会迁移到 <code>x</code> 或 <code>y</code> 中。同时 <code>x</code> 和 <code>y</code> 也只可能有 <code>oldbucket</code> 的 <code>key</code>，不可能有其他旧的 <code>bucket</code> 的 <code>key</code>。这是由 <code>hash &amp; m</code> 可以推断出来的。</p> <h3 id="bucket-迁移源码剖析"><a href="#bucket-迁移源码剖析" class="header-anchor">#</a> bucket 迁移源码剖析</h3> <p><strong>开始之前，我们要记住 <code>x</code> 和 <code>y</code> 是怎么来的。</strong></p> <p>在开始看代码之前，我们需要明确一点：<strong>虽然整个哈希表是渐进式迁移的，但是单个 <code>bucket</code> 的迁移不是渐进式的。</strong></p> <ol><li>我们先看看 <code>growWork</code> 函数：</li></ol> <p>这是迁移桶的函数，一次会迁移两个桶。不过实际上并不是严格的两个，因为迁移的函数会先判断桶是否已经被迁移， 如果桶还没有被迁移，才会进行迁移，如果桶已经被迁移则不做任何操作。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 桶迁移</span>
<span class="token comment">// 参数：h 需要扩容的 map，t map 类型信息，bucket 旧桶的索引</span>
<span class="token comment">// 1、迁移当前访问到的桶（mapassign、mapdelete 的时候）</span>
<span class="token comment">// 2、继续逐个迁移 bucket，直到迁移完成（这个是从第一个桶开始迁移的）</span>
<span class="token keyword">func</span> <span class="token function">growWork</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> bucket <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 迁移当前访问到的桶</span>
   <span class="token function">evacuate</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> bucket<span class="token operator">&amp;</span>h<span class="token punctuation">.</span><span class="token function">oldbucketmask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// 继续逐个迁移 bucket，直到迁移完成</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">evacuate</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>nevacuate<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ol><li>然后看看 <code>evacuate</code> 函数：</li></ol> <p>这个就是实际做迁移操作的函数。它会根据 <code>hash &amp; m</code> 的倒数第 <code>B</code> 位是否为 1 来决定将 <code>key</code> 迁移到 <code>h.buckets</code> 的前半部分还是后半部分。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 迁移的目的地（旧桶 -&gt; 目标桶）</span>
<span class="token comment">// evacuate 中会定义两个这个 evacDst 变量，</span>
<span class="token comment">// 一个指向 h.buckets 的前半部分，一个指向后半部分。（对应前一个图的 x，y）</span>
<span class="token comment">// 迁移的时候，会根据 key 的哈希值的倒数第 4 位来决定迁移到哪个 evacDst 中。</span>
<span class="token keyword">type</span> evacDst <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   b <span class="token operator">*</span>bmap          <span class="token comment">// 迁移目的地 bucket</span>
   i <span class="token builtin">int</span>            <span class="token comment">// key/elem 在迁移目标 bucket 里面对应的下标</span>
   k unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 目标 bucket 下一个保存 key 的地址指针</span>
   e unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 目标 bucket 下一个保存 elem 的地址指针</span>
<span class="token punctuation">}</span>

<span class="token comment">// 扩容的时候，bucket 迁移的实现</span>
<span class="token comment">// oldbucket 需要迁移的旧桶索引</span>
<span class="token keyword">func</span> <span class="token function">evacuate</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> oldbucket <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// b 指向旧桶</span>
   b <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>oldbuckets<span class="token punctuation">,</span> oldbucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 扩容之前的桶的数量</span>
   <span class="token comment">// oldbucket+newbit 对应 y，oldbucket 对应 x</span>
   newbit <span class="token operator">:=</span> h<span class="token punctuation">.</span><span class="token function">noldbuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 如果 b 尚未迁移，则进行迁移</span>
   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">evacuated</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// xy 包含 x 和 y（低和高）迁移目的地。</span>
      <span class="token comment">// 迁移的时候，在 h.buckets 中，前 noldbuckets 个桶就是 x，后 noldbuckets 个桶就是代表 y。</span>
      <span class="token keyword">var</span> xy <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>evacDst
      <span class="token comment">// x 存储了新桶的地址</span>
      x <span class="token operator">:=</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      <span class="token comment">// x 指向 oldbucket 可能迁移到的新桶（h.buckets 的前半部分）</span>
      x<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> oldbucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// x 桶中下一个用来保存旧桶的 key 的地址</span>
      x<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
      <span class="token comment">// x 桶中下一个用来保存旧桶的 elem 的地址</span>
      x<span class="token punctuation">.</span>e <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>

      <span class="token comment">// 如果不是等量扩容（有可能会迁移到 oldbucket+newbit 的位置上）</span>
      <span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">sameSizeGrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         y <span class="token operator">:=</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
         <span class="token comment">// y 指向增量空间上的第 oldbucket+newbit 个位置</span>
         y<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> <span class="token punctuation">(</span>oldbucket<span class="token operator">+</span>newbit<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token comment">// y 桶中下一个保存旧桶 key 的地址</span>
         y<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
         <span class="token comment">// y 桶中下一个保存旧桶 elem 的地址</span>
         y<span class="token punctuation">.</span>e <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 开始迁移旧桶（同时也会迁移溢出桶）</span>
      <span class="token keyword">for</span> <span class="token punctuation">;</span> b <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 旧 bucket 上第一个 key</span>
         k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
         <span class="token comment">// 旧 bucket 上第一个 value</span>
         e <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token comment">// 遍历 bucket 的槽</span>
         <span class="token comment">// 获取需要迁移的 key/elem(k/e) 对，迁移到新桶上(&amp;xy[useY])</span>
         <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token punctuation">,</span> k<span class="token punctuation">,</span> e <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取旧的 tophash</span>
            top <span class="token operator">:=</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token comment">// bucket 的这个槽是空的</span>
            <span class="token keyword">if</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>top<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment">// 写入已迁移标记</span>
               b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> evacuatedEmpty
               <span class="token comment">// 处理下一个 key/elem</span>
               <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// tophash 错误</span>
            <span class="token keyword">if</span> top <span class="token operator">&lt;</span> minTopHash <span class="token punctuation">{</span>
               <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;bad map state&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 复制一份 k</span>
            k2 <span class="token operator">:=</span> k
            <span class="token comment">// k2 指向实际的 key</span>
            <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               k2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// useY 决定了是迁移到 x 还是 y，如果是等量扩容，那么就是迁移到 x</span>
            <span class="token keyword">var</span> useY <span class="token builtin">uint8</span>
            <span class="token comment">// 如果不是等量扩容</span>
            <span class="token keyword">if</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">sameSizeGrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment">// 计算哈希以做出迁移决定（是否需要将此 key/elem 迁移到桶 x 或桶 y）。</span>
               hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
               <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>iterator <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">reflexivekey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>k2<span class="token punctuation">,</span> k2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token comment">// 下面这段是原英文注释的翻译（可能不太准确）：</span>
                  <span class="token comment">// 如果 key != key（不是一个数字），则散列可能（并且可能）与旧散列完全不同。</span>
                  <span class="token comment">// 此外，它是不可再现的。</span>
                  <span class="token comment">// 在迭代器存在的情况下，再现性是必需的，因为我们的迁移决策必须与迭代器所做的任何决策相匹配。</span>
                  <span class="token comment">// 幸运的是，我们可以任意发送这些 key。</span>
                  <span class="token comment">// 此外，tophash 对于这些类型的 key 没有意义。我们让 tophash 的最低位的决定如何迁移。</span>
                  <span class="token comment">// 我们为下一个级别重新计算一个新的随机 tophash，这样在多次扩容后，这些 key 将均匀分布在所有桶中。</span>
                  useY <span class="token operator">=</span> top <span class="token operator">&amp;</span> <span class="token number">1</span>
                  top <span class="token operator">=</span> <span class="token function">tophash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
               <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                  <span class="token comment">// 原理参考上面那个图。</span>
                  <span class="token keyword">if</span> hash<span class="token operator">&amp;</span>newbit <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 取决于 oldB + 1 位是 0 还是 1</span>
                     useY <span class="token operator">=</span> <span class="token number">1</span>
                  <span class="token punctuation">}</span>
               <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> evacuatedX<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">!=</span> evacuatedY <span class="token operator">||</span> evacuatedX<span class="token operator">^</span><span class="token number">1</span> <span class="token operator">!=</span> evacuatedY <span class="token punctuation">{</span>
               <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;bad evacuatedN&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 记录旧桶的迁移状态</span>
            b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> evacuatedX <span class="token operator">+</span> useY <span class="token comment">// evacuatedX + 1 == evacuatedY</span>
            <span class="token comment">// dst 是迁移的目标 bucket</span>
            dst <span class="token operator">:=</span> <span class="token operator">&amp;</span>xy<span class="token punctuation">[</span>useY<span class="token punctuation">]</span>

            <span class="token comment">// 目标 bucket 装不下了，使用溢出桶</span>
            <span class="token keyword">if</span> dst<span class="token punctuation">.</span>i <span class="token operator">==</span> bucketCnt <span class="token punctuation">{</span>
               <span class="token comment">// 创建溢出桶</span>
               dst<span class="token punctuation">.</span>b <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">newoverflow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> dst<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
               dst<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span>
               <span class="token comment">// dst.k 指向溢出桶的第一个 key 的地址</span>
               dst<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span> 
               <span class="token comment">// dst.e 指向溢出桶的第一个 elem 的地址</span>
               dst<span class="token punctuation">.</span>e <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>k<span class="token punctuation">,</span> bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 使用 &amp; 运算优化，不用进行边界检查</span>
            <span class="token comment">// 记录 tophash</span>
            dst<span class="token punctuation">.</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>dst<span class="token punctuation">.</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span>bucketCnt<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> top <span class="token comment">// mask dst.i as an optimization, to avoid a bounds check</span>
            <span class="token comment">// 将旧的 key/elem 复制到 dst 指向的槽</span>
            <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// bucket 的 key 保存的是指针</span>
               <span class="token comment">// 修改实际存储 key 的内存</span>
               <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>k<span class="token punctuation">)</span> <span class="token operator">=</span> k2 <span class="token comment">// copy pointer</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token comment">// 修改 bucket 中保存 key 的内存</span>
               <span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>key<span class="token punctuation">,</span> dst<span class="token punctuation">.</span>k<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// copy elem</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// bucket 的 elem 保存的是指针</span>
               <span class="token comment">// 修改实际存储 elem 的内存</span>
               <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>e<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token comment">// 修改 bucket 中保存 elem 的内存</span>
               <span class="token function">typedmemmove</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elem<span class="token punctuation">,</span> dst<span class="token punctuation">.</span>e<span class="token punctuation">,</span> e<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 目标桶的元素个数 +1</span>
            <span class="token comment">// dst 指向下一个空的槽（slot/cell）</span>
            dst<span class="token punctuation">.</span>i<span class="token operator">++</span>
            <span class="token comment">// 这些更新可能会将这些指针推到 key 或 elem 数组的末尾。</span>
            <span class="token comment">// 这没关系，因为我们在桶的末端有溢出桶指针，以防止指针指向桶的末端。</span>
            <span class="token comment">// 如果指向数组末尾，在下次迁移的时候，会创建溢出桶。</span>
            dst<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>k<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
            dst<span class="token punctuation">.</span>e <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>dst<span class="token punctuation">.</span>e<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 上面有判断 dst.i == bucketCnt，所以这里不会溢出</span>
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 取消链接溢出桶并清除 key/elem 以帮助 GC。（清除旧桶的内存）</span>
      <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>oldIterator <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>ptrdata <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
         b <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>oldbuckets<span class="token punctuation">,</span> oldbucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token comment">// tophash 状态不能清除。</span>
         <span class="token comment">// 但是 key/elem 都可以清除。</span>
         ptr <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> dataOffset<span class="token punctuation">)</span>
         n <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span> <span class="token operator">-</span> dataOffset
         <span class="token function">memclrHasPointers</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 刚刚迁移的桶，就是顺序迁移的下一个桶，</span>
   <span class="token comment">// 则需要更新 nevacuate 字段，表示已经迁移了多少个桶</span>
   <span class="token keyword">if</span> oldbucket <span class="token operator">==</span> h<span class="token punctuation">.</span>nevacuate <span class="token punctuation">{</span>
      <span class="token function">advanceEvacuationMark</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> t<span class="token punctuation">,</span> newbit<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br></div></div><ol><li><code>advanceEvacuationMark</code> 的作用是更新 <code>nevacuate</code> 字段，表示已经迁移了多少个桶。</li></ol> <p>我们上面说了，哈希表扩容的时候，会有两条线，<code>advanceEvacuationMark</code> 就是处理顺序迁移的那条线，让 <code>nevacuate</code> 指向下一个未迁移的桶。 为什么需要做这个处理呢？这是因为另外一条线的迁移是随机的，访问到哪个桶就迁移哪个桶，这就导致了，顺序迁移的那条线，在将 <code>nevacuate</code> 指向下一个桶的时候，其实下一个桶是已经迁移了的，我们下次顺序迁移的时候肯定不需要迁移这个桶。 那么解决办法就是，继续向后查找，找到第一个未迁移的桶。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 记录迁移进度（从顺序迁移的位置往后遍历，保证 nevacuate 指向下一个尚未迁移的桶）</span>
<span class="token comment">// 参数：h 需要扩容的 map，t map 类型信息，newbit 是旧桶的数量</span>
<span class="token keyword">func</span> <span class="token function">advanceEvacuationMark</span><span class="token punctuation">(</span>h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> newbit <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// nevacuate 索引加 1</span>
   h<span class="token punctuation">.</span>nevacuate<span class="token operator">++</span>
   <span class="token comment">// 往后找一个未迁移的桶（最多遍历 1024 个桶）。</span>
   stop <span class="token operator">:=</span> h<span class="token punctuation">.</span>nevacuate <span class="token operator">+</span> <span class="token number">1024</span>
   <span class="token keyword">if</span> stop <span class="token operator">&gt;</span> newbit <span class="token punctuation">{</span>
      stop <span class="token operator">=</span> newbit
   <span class="token punctuation">}</span>
   <span class="token comment">// 向后遍历，找到第一个未迁移的桶。</span>
   <span class="token keyword">for</span> h<span class="token punctuation">.</span>nevacuate <span class="token operator">!=</span> stop <span class="token operator">&amp;&amp;</span> <span class="token function">bucketEvacuated</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>nevacuate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      h<span class="token punctuation">.</span>nevacuate<span class="token operator">++</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 这意味着所有旧桶都迁移完了</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>nevacuate <span class="token operator">==</span> newbit <span class="token punctuation">{</span>
      <span class="token comment">// 扩容已经完成。释放旧的普通桶数组。</span>
      h<span class="token punctuation">.</span>oldbuckets <span class="token operator">=</span> <span class="token boolean">nil</span>
      <span class="token comment">// 也可以丢弃旧的溢出桶。</span>
      <span class="token comment">// 如果它们仍然被迭代器引用，那么迭代器将保存指向切片的指针。</span>
      <span class="token comment">//（但是 h 不再需要保存指向切片的指针）</span>
      <span class="token keyword">if</span> h<span class="token punctuation">.</span>extra <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
         h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>oldoverflow <span class="token operator">=</span> <span class="token boolean">nil</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 移除等量扩容标志</span>
      h<span class="token punctuation">.</span>flags <span class="token operator">&amp;^=</span> sameSizeGrow
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>这里需要注意的是下面几行代码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>stop <span class="token operator">:=</span> h<span class="token punctuation">.</span>nevacuate <span class="token operator">+</span> <span class="token number">1024</span>
<span class="token keyword">if</span> stop <span class="token operator">&gt;</span> newbit <span class="token punctuation">{</span>
    stop <span class="token operator">=</span> newbit
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们在将 <code>nevacuate</code> 加上 1 之后，还会继续往后遍历 1024 个 bucket，如果 bucket 已迁移，则将 <code>nevacuate</code> 加 1。</p> <p>如果没有这个操作会怎样？那就意味着可能有很多的 bucket 都已经迁移了，但是顺序迁移的位置（<code>nevacuate</code>）还没有更新， 这样可能会导致顺序迁移的位置每次都指向了已迁移的 <code>bucket</code>。 最终导致，迁移的时候，只迁移了访问到的 <code>bucket</code>，而没有迁移顺序迁移位置上的那个 <code>bucket</code>。</p> <p><strong>也就是说，每次迁移的时候只会迁移 1 个 <code>bucket</code>，而不是 2 个，这样一来 <code>growWork</code> 需要调用的次数比原来更多，也就是说，需要写操作次数更多才能完成全部 <code>bucket</code> 的迁移</strong>。</p> <p>这个函数做的事情可以表示成下图：</p> <p><img src="/images/go/map/28.webp" alt="map_7_5.png"></p> <p>在这个图中，<code>nevacuate</code> 一开始是 <code>1</code>，然后因为 <code>3</code> 这个 <code>bucket</code> 在这次 <code>growWork</code> 中已经迁移了， <code>nevacuate</code> 如果要指向下一个未迁移的 <code>bucket</code> 的话，就要跳过之前已经迁移的 <code>2</code>，以及本次 <code>growWork</code> 中已经迁移的 <code>3</code>， 所以最终 <code>nevacuate</code> 指向了 <code>4</code>，也就是下一个未迁移的 <code>bucket</code>。</p> <h3 id="等量扩容的效果"><a href="#等量扩容的效果" class="header-anchor">#</a> 等量扩容的效果</h3> <p>在上面我们讲解的时候，其实已经假设了扩容是增量扩容（2 倍扩容），但实际上还有一种扩容方式，就是等量扩容。 等量扩容的时候，扩容前后的 <code>bucket</code> 其实数量是一样的，那么为什么还要进行扩容呢？</p> <p>这是因为，溢出桶太多了，数据非常零散地分布在了很多的溢出桶中，这样会导致 <code>bucket</code> 中很多槽都是空的， 这样一来，进行查找、修改、删除的时候，需要遍历很多的溢出桶，这样会导致性能下降。如下图：</p> <p><img src="/images/go/map/29.webp" alt="map_7_6.png"></p> <p>这个图中，我们假设要查找的 <code>key</code> 所在的普通桶以及前两个溢出桶都是空的，又或者 <code>key</code> 不在前面三个桶中，那只有遍历到最后一个溢出桶的时候才能找到我们要查找的 <code>key</code>。为了针对这种键值对数量没有达到扩容的阈值，但是溢出桶太多的情况，Go 语言提供了等量扩容的方式。</p> <p>在等量扩容的时候，会将所有的溢出桶都迁移到新的 <code>bucket</code> 中，这样一来，<code>bucket</code> 中的槽就会被填满，而溢出桶也可能不再需要。</p> <p>最后，针对上图的情况，<code>key = foo</code> 会被迁移到普通桶中，这样在查找的时候，只需要遍历普通桶就可以找到了。 当然，实际中的情况是，对于零散分布在多个溢出桶中的键值对，会被逐个往前挪，最终效果就是，桶中没有空的槽，除了最后一个 <code>key</code> 以后的槽。</p> <p>大家可以结合下图想象一下：</p> <p>当然下图只是描述了一下部分 <code>key</code>，如果 <code>key</code> 分布。实际上 <code>key</code> 在触发等量扩容的情况下，是零散地分布在不同的 <code>bucket</code> 中的（包括溢出桶）。</p> <p><img src="/images/go/map/30.webp" alt="map_7_7.png"></p> <h2 id="map-的迭代实现"><a href="#map-的迭代实现" class="header-anchor">#</a> map 的迭代实现</h2> <p>go 的 <code>map</code> 迭代的时候，我们会发现，返回结果的顺序并不固定，这是因为 <code>map</code> 的迭代是无序的。 在 <code>map</code> 遍历的时候，每次都会从一个随机的 <code>bucket</code> 开始遍历，而且选了一个 <code>bucket</code> 之后， 还会从 <code>bucket</code> 中随机选择一个槽开始遍历，这样一来，每次遍历的结果都是不一样的。</p> <h3 id="map-迭代器数据结构"><a href="#map-迭代器数据结构" class="header-anchor">#</a> map 迭代器数据结构</h3> <p>迭代器的功能：记录要遍历的 <code>map</code>，以及当前遍历到的 <code>bucket</code> 以及槽的索引，以便进行下一次遍历。</p> <p>go 的 <code>map</code> 迭代器的数据结构如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 哈希迭代结构。</span>
<span class="token keyword">type</span> hiter <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   <span class="token comment">// 必须排在第一位。 写入 nil 表示迭代结束</span>
   key unsafe<span class="token punctuation">.</span>Pointer
   <span class="token comment">// 必须在第二个位置（参见 cmd/compile/internal/walk/range.go）。</span>
   elem unsafe<span class="token punctuation">.</span>Pointer
   t    <span class="token operator">*</span>maptype       <span class="token comment">// map 的类型信息，包括 key、elem 的类型等信息</span>
   h    <span class="token operator">*</span>hmap          <span class="token comment">// 需要迭代的 hmap</span>
   <span class="token comment">// hash_iter 初始化时的 bucket 指针</span>
   buckets unsafe<span class="token punctuation">.</span>Pointer
   <span class="token comment">// 当前正在遍历的 bucket</span>
   bptr <span class="token operator">*</span>bmap
   <span class="token comment">// 保持 hmap.buckets 的溢出桶存活</span>
   overflow <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap
   <span class="token comment">// 保持 hmap.oldbuckets 的溢出桶存活</span>
   oldoverflow <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>bmap
   <span class="token comment">// bucket 迭代开始位置（随机选择的 bucket）</span>
   startBucket <span class="token builtin">uintptr</span>
   <span class="token comment">// 在迭代期间开始的桶内偏移量（应该足够大以容纳 bucketCnt-1）</span>
   offset <span class="token builtin">uint8</span>
   <span class="token comment">// 已经从桶数组的末尾环绕到开始</span>
   wrapped     <span class="token builtin">bool</span>
   B           <span class="token builtin">uint8</span>   <span class="token comment">// 就是当前遍历的 hmap 的那个 B</span>
   i           <span class="token builtin">uint8</span>   <span class="token comment">// 当前遍历的 bucket 内 key 的索引</span>
   bucket      <span class="token builtin">uintptr</span> <span class="token comment">// 当前遍历的 bucket</span>
   checkBucket <span class="token builtin">uintptr</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>几点注意的：</p> <ol><li>全部键值对遍历完的时候，<code>key</code> 会被置为 <code>nil</code>，这样一来，我们就可以通过 <code>key</code> 是否为 <code>nil</code> 来判断是否遍历完了。（当然这个不用开发者来判断，<code>for...range</code> 底层已经帮我们做了这个判断）。</li> <li><code>hiter</code> 结构体保存了当前正在迭代的 <code>bucket</code>（<code>bptr</code>）、<code>bucket</code> 中的 <code>key</code> 的索引（<code>i</code>）等信息，这样一来，我们就可以通过这些信息来确定下一个 <code>key</code> 的位置。</li></ol> <h3 id="迭代器的初始化实现"><a href="#迭代器的初始化实现" class="header-anchor">#</a> 迭代器的初始化实现</h3> <p>go 的 <code>map</code> 初始化是通过 <code>runtime.mapiterinit</code> 来实现的，这个函数的实现如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// mapiterinit 初始化用于 range 遍历 map 的 hiter 结构。（初始化 hiter）</span>
<span class="token comment">// 'it' 指向的 hiter 结构由编译器顺序传递在堆栈上分配，或由 reflect_mapiterinit 在堆上分配。</span>
<span class="token comment">// 两者都需要将 hiter 置零，因为结构包含指针。</span>
<span class="token keyword">func</span> <span class="token function">mapiterinit</span><span class="token punctuation">(</span>t <span class="token operator">*</span>maptype<span class="token punctuation">,</span> h <span class="token operator">*</span>hmap<span class="token punctuation">,</span> it <span class="token operator">*</span>hiter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// hiter 记录 map 的类型信息</span>
   it<span class="token punctuation">.</span>t <span class="token operator">=</span> t
   <span class="token comment">// 如果 map 是空的直接返回</span>
   <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 个人猜测：内存对齐判断，这个由编译器决定的</span>
   <span class="token keyword">if</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>hiter<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">/</span>goarch<span class="token punctuation">.</span>PtrSize <span class="token operator">!=</span> <span class="token number">12</span> <span class="token punctuation">{</span>
      <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;hash_iter size incorrect&quot;</span><span class="token punctuation">)</span> <span class="token comment">// see cmd/compile/internal/reflectdata/reflect.go</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// it 关联上 map</span>
   it<span class="token punctuation">.</span>h <span class="token operator">=</span> h

   <span class="token comment">// 获取桶状态的快照</span>
   it<span class="token punctuation">.</span>B <span class="token operator">=</span> h<span class="token punctuation">.</span>B
   <span class="token comment">// 当前的 buckets</span>
   it<span class="token punctuation">.</span>buckets <span class="token operator">=</span> h<span class="token punctuation">.</span>buckets
   <span class="token comment">// bucket 里面没有包含指针</span>
   <span class="token keyword">if</span> t<span class="token punctuation">.</span>bucket<span class="token punctuation">.</span>ptrdata <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token comment">// 分配当前切片并记住指向当前切片和旧切片的指针。</span>
      <span class="token comment">// 这将保持所有相关的溢出桶处于活动状态，即使在迭代时表增长和/或溢出桶添加到表中。</span>
      h<span class="token punctuation">.</span><span class="token function">createOverflow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      it<span class="token punctuation">.</span>overflow <span class="token operator">=</span> h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>overflow
      it<span class="token punctuation">.</span>oldoverflow <span class="token operator">=</span> h<span class="token punctuation">.</span>extra<span class="token punctuation">.</span>oldoverflow
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 决定从哪里开始遍历。</span>
   <span class="token comment">// 策略：随机选定一个 bucket，然后从该 bucket 开始遍历。</span>
   <span class="token comment">// 生成随机数</span>
   <span class="token keyword">var</span> r <span class="token builtin">uintptr</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>B <span class="token operator">&gt;</span> <span class="token number">31</span><span class="token operator">-</span>bucketCntBits <span class="token punctuation">{</span>
      r <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">fastrand64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      r <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// r =&gt; 扫描的入口（随机选的 bucket）</span>
   it<span class="token punctuation">.</span>startBucket <span class="token operator">=</span> r <span class="token operator">&amp;</span> <span class="token function">bucketMask</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>B<span class="token punctuation">)</span>
   <span class="token comment">// 随机定位的 bucket 中的槽。</span>
   it<span class="token punctuation">.</span>offset <span class="token operator">=</span> <span class="token function">uint8</span><span class="token punctuation">(</span>r <span class="token operator">&gt;&gt;</span> h<span class="token punctuation">.</span>B <span class="token operator">&amp;</span> <span class="token punctuation">(</span>bucketCnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token comment">// 记录当前扫描的 bucket</span>
   it<span class="token punctuation">.</span>bucket <span class="token operator">=</span> it<span class="token punctuation">.</span>startBucket

   <span class="token comment">// 记住我们有一个迭代器。</span>
   <span class="token comment">// 可以与另一个 mapiteinit() 同时运行。</span>
   <span class="token keyword">if</span> old <span class="token operator">:=</span> h<span class="token punctuation">.</span>flags<span class="token punctuation">;</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>iterator<span class="token operator">|</span>oldIterator<span class="token punctuation">)</span> <span class="token operator">!=</span> iterator<span class="token operator">|</span>oldIterator <span class="token punctuation">{</span>
      atomic<span class="token punctuation">.</span><span class="token function">Or8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>h<span class="token punctuation">.</span>flags<span class="token punctuation">,</span> iterator<span class="token operator">|</span>oldIterator<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 开始遍历</span>
   <span class="token function">mapiternext</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br></div></div><p>这个函数主要功能是初始化迭代器，我们最需要关心的是，这个函数里面会生成一个随机数，然后通过这个随机数来决定从哪一个 <code>bucket</code> 开始遍历， 以及从 <code>bucket</code> 中的哪一个槽开始遍历（也是随机的）。</p> <h3 id="map-遍历图解"><a href="#map-遍历图解" class="header-anchor">#</a> map 遍历图解</h3> <p>那为什么从随机定位的 <code>bucket</code> 以及随机定位的 <code>key</code> 就可以实现遍历呢？其实很简单，如果看过我之前写的 《go chan 设计与实现》的话， 就会知道 <code>chan</code> 的实现中是通过数组来实现环形队列的。而我们可以借助环形队列的特性来理解 <code>map</code> 的遍历。遍历到最后一个 <code>bucket</code> 之后， 下一个 <code>bucket</code> 就是第一个 <code>bucket</code>，这样就实现了环形遍历。同样的，遍历到最后一个 <code>key</code> 之后，下一个 <code>key</code> 就是第一个 <code>key</code>，这样也实现了环形遍历。</p> <p>我们需要做的就是，在遍历开始的时候，记录第一个 <code>bucket</code>，然后每次遍历 <code>bucket</code> 的时候， 比较当前的 <code>bucket</code> 是否是第一个 <code>bucket</code>，是的话，意味着遍历结束了。 同样的，对于 <code>bucket</code> 内 <code>key</code> 的遍历也是。</p> <p>不过，在实际实现中，<code>key</code> 有点不一样，<code>key</code> 的遍历是通过将 <code>i</code> 从 <code>0</code> 遍历到 <code>7</code>，对于每一个 <code>i</code>，加上 <code>it.offset</code>，然后对 <code>8</code> 取模， 这样就可以实现环形遍历了，代码如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
   <span class="token comment">// 桶内第 i 个元素</span>
   offi <span class="token operator">:=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> it<span class="token punctuation">.</span>offset<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>bucketCnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>具体遍历过程如下图：</p> <p><img src="/images/go/map/31.webp" alt="map_8_1.png"></p> <h3 id="发生在扩容期间的遍历"><a href="#发生在扩容期间的遍历" class="header-anchor">#</a> 发生在扩容期间的遍历</h3> <p>go 的 <code>map</code> 设计中，是不允许在迭代的时候进行插入、修改、删除的，但只是在获取下一个键值对的时候不允许， 在迭代器获取了键值对之后，就算还没有全部遍历完 <code>map</code> 的所有元素，还是可以允许做插入、修改、删除操作的。 这样一来，有可能会出现一些奇怪的现象，比如插入的 <code>key</code> 遍历不出来，或者遍历出来的 <code>key</code> 有重复等等。这是需要开发者注意的地方。</p> <p>另外，迭代可以发生在扩容的过程中，但是扩容其实对迭代其实是没有什么影响的。因为迭代的时候会做一些判断尽量保证所有 <code>key</code> 都能被遍历到。 但不能保证我们对 <code>map</code> 做了写操作后依然可以全部 <code>key</code> 都遍历。</p> <p>在遍历的过程中，如果 <code>map</code> 发生了扩容，那么遍历的过程就会变得复杂一些。因为在扩容的过程中，<code>map</code> 会新建一个 <code>bucket</code>， 然后将原来的 <code>bucket</code> 中的 <code>key</code> 重新散列到新的 <code>bucket</code> 中。所以在遍历的过程中，如果发现当前的 <code>bucket</code> 已经发生了扩容， 需要做一些判断，比如：</p> <ol><li>如果发现 <code>bucket</code> 还没有迁移，则从 <code>oldbuckets</code> 中遍历。</li> <li>如果发现 <code>bucket</code> 在迁移之后索引跟原来的不一样，则跳过。</li></ol> <p>具体可以参考下图：</p> <p><img src="/images/go/map/32.webp" alt="map_8_2.png"></p> <p>这里假设的条件是：旧桶个数为 <code>4</code>，增量扩容后，新桶个数为 <code>8</code>。<code>hiter</code> 当前迭代的是新桶。</p> <p>说明：</p> <ol><li><code>h.oldbuckets</code> 指向了还没迁移完的桶，<code>h.buckets</code> 是当前的桶。</li> <li><code>hiter</code> 迭代器要迭代的是新的桶。迭代器初始化的时候正在进行 2 倍扩容。</li> <li><code>checkBucket</code> 是下一个要遍历的桶（索引为 <code>1</code>），图中的情况是，这个桶还没有被迁移。所以需要从 <code>h.oldbuckets</code> 中读取。</li> <li><code>checkBucket</code> 中的 <code>key</code> 有可能会迁移到 <code>h.buckets</code> 中的 <code>1</code> 或者 <code>5</code> 位置。（具体可以看上面桶迁移的实现那一节）</li> <li>如果 <code>key</code> 是要被迁移到 <code>5</code> 中的话，那么遍历的时候会跳过，因为后面会遍历到 <code>5</code> 中的 <code>key</code>。</li> <li>对于第 5 点，在遍历 <code>5</code> 这个 <code>bucket</code> 的时候，由于我们是使用当前遍历的 <code>bucket</code> 的下标结合旧桶的长度计算在旧桶中的下标的，所以还是可以取得到旧桶，然后遍历的时候取出那些应该迁移到 <code>5</code> 这个 <code>bucket</code> 的 <code>key</code>，对于那些应该要迁移到 <code>1</code> 的 <code>key</code> 则跳过。</li> <li>下一个要遍历的桶的索引为 <code>2</code>。</li></ol> <p>对于第 6 点桶索引计算的特别说明，如果是增量扩容，计算 <code>bucket</code> 的下标方式如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// bucket 是当前要遍历的 bucket 的下标</span>
<span class="token comment">// it.h.oldbucketmask() 是旧桶的 B 的掩码</span>
oldbucket <span class="token operator">:=</span> bucket <span class="token operator">&amp;</span> it<span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">oldbucketmask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当然如果这个桶已经迁移，那么还是会从新桶遍历（也就是 <code>bucket &amp; it.h.oldbucketmask()</code> 里的 <code>bucket</code> 本身）。</p> <h3 id="键值对遍历源码剖析"><a href="#键值对遍历源码剖析" class="header-anchor">#</a> 键值对遍历源码剖析</h3> <p><code>map</code> 中实现遍历的函数是 <code>mapiternext</code>，这个函数做的事情，也就是上面两个图描述的遍历过程，代码如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 参数：迭代器实例</span>
<span class="token keyword">func</span> <span class="token function">mapiternext</span><span class="token punctuation">(</span>it <span class="token operator">*</span>hiter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 获取底层的 hmap 实例</span>
   h <span class="token operator">:=</span> it<span class="token punctuation">.</span>h
   <span class="token comment">// 正在插入、修改、删除 key 但时候，不能获取下一个 key，</span>
   <span class="token comment">// 注意：这不能保证插入、修改、删除之后，进行迭代。</span>
   <span class="token keyword">if</span> h<span class="token punctuation">.</span>flags<span class="token operator">&amp;</span>hashWriting <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">&quot;concurrent map iteration and map write&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   t <span class="token operator">:=</span> it<span class="token punctuation">.</span>t           <span class="token comment">// *maptype</span>
   bucket <span class="token operator">:=</span> it<span class="token punctuation">.</span>bucket <span class="token comment">// 当前遍历到的 bucket 下标（int 类型）</span>
   b <span class="token operator">:=</span> it<span class="token punctuation">.</span>bptr        <span class="token comment">// 当前 bucket 的指针（实际的 bucket，bmap 指针类型）</span>
   i <span class="token operator">:=</span> it<span class="token punctuation">.</span>i           <span class="token comment">// 迭代器当前遍历到的位置（bucket 内 key 的位置）</span>
   checkBucket <span class="token operator">:=</span> it<span class="token punctuation">.</span>checkBucket <span class="token comment">// 这个用来判断是否是增量扩容的</span>

next<span class="token punctuation">:</span>
   <span class="token comment">// 注意：下面的 if 的功能是，获取下一个桶。</span>
   <span class="token comment">// 如果 b 是 nil，有以下两种情况：</span>
   <span class="token comment">// a. 第一次遍历，还没有遍历到任何 bucket。</span>
   <span class="token comment">// b. 遍历完最后一个 bucket 了。</span>
   <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      <span class="token comment">// 已经迭代完了，直接退出函数</span>
      <span class="token keyword">if</span> bucket <span class="token operator">==</span> it<span class="token punctuation">.</span>startBucket <span class="token operator">&amp;&amp;</span> it<span class="token punctuation">.</span>wrapped <span class="token punctuation">{</span>
         <span class="token comment">// for...range 查看到 key 是 nil 会中止迭代</span>
         it<span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token boolean">nil</span>
         it<span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token boolean">nil</span>
         <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 如果正在扩容</span>
      <span class="token keyword">if</span> h<span class="token punctuation">.</span><span class="token function">growing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> it<span class="token punctuation">.</span>B <span class="token operator">==</span> h<span class="token punctuation">.</span>B <span class="token punctuation">{</span>
         <span class="token comment">// 迭代器是在扩容过程中启动的，扩容尚未完成。</span>
         <span class="token comment">// 如果我们正在查看的存储桶尚未迁移，</span>
         <span class="token comment">// 那么我们需要遍历旧存储桶，同时只返回将迁移到此存储桶的数据。</span>
         <span class="token comment">// 那些需要迁移到另一个下标的桶则跳过。</span>
         oldbucket <span class="token operator">:=</span> bucket <span class="token operator">&amp;</span> it<span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">oldbucketmask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token comment">// 获取旧桶</span>
         b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>oldbuckets<span class="token punctuation">,</span> oldbucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">evacuated</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 旧桶还没有迁移</span>
            checkBucket <span class="token operator">=</span> bucket
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 已经迁移了，获取新桶</span>
            b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> bucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            checkBucket <span class="token operator">=</span> noCheck
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 并没有在扩容，获取新的桶</span>
         b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>bmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>buckets<span class="token punctuation">,</span> bucket<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>bucketsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         checkBucket <span class="token operator">=</span> noCheck
      <span class="token punctuation">}</span>

      <span class="token comment">// bucket 指向了下一个要迭代的桶的下标</span>
      bucket<span class="token operator">++</span>
      <span class="token comment">// 判断当前遍历的桶是否到最后一个桶了</span>
      <span class="token keyword">if</span> bucket <span class="token operator">==</span> <span class="token function">bucketShift</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         bucket <span class="token operator">=</span> <span class="token number">0</span>
         it<span class="token punctuation">.</span>wrapped <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 已经从第一个随机定位的 bucket 遍历到最后一个 bucket 了，下一个应该是第一个 bucket 了</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 开始遍历新的 bucket 的时候，重置 i</span>
      i <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 开始遍历桶内的键值对</span>
   <span class="token keyword">for</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCnt<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
      <span class="token comment">// 计算桶内键值对的下标（从随机的 it.offset 下标开始遍历）</span>
      offi <span class="token operator">:=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> it<span class="token punctuation">.</span>offset<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>bucketCnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token comment">// 如果槽是空的，或者 key 已经迁移，则跳过。</span>
      <span class="token keyword">if</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>offi<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>offi<span class="token punctuation">]</span> <span class="token operator">==</span> evacuatedEmpty <span class="token punctuation">{</span>
         <span class="token keyword">continue</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 桶内第 i 个元素的 key 的指针</span>
      <span class="token comment">// 获取 key 或 elem 的解析前面的小节有详细的解释了，不再赘述。</span>
      k <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span><span class="token function">uintptr</span><span class="token punctuation">(</span>offi<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         k <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 桶内第 i 个元素的 elem 的指针</span>
      e <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> dataOffset<span class="token operator">+</span>bucketCnt<span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>keysize<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">uintptr</span><span class="token punctuation">(</span>offi<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">uintptr</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>elemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>

      <span class="token comment">// 增量扩容的 key 判断</span>
      <span class="token comment">// 需要判断迁移之后的 key 落入的是 h.buckets 的前半部分还是后半部分（x 还是 y）</span>
      <span class="token comment">// 具体看上面的迁移实现。</span>
      <span class="token keyword">if</span> checkBucket <span class="token operator">!=</span> noCheck <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">sameSizeGrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">reflexivekey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// key 是可比较的</span>
            <span class="token comment">// 如果这个 key 将会被迁移到 h.buckets 的后半部分，跳过它</span>
            hash <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">hasher</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>hash0<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> hash<span class="token operator">&amp;</span><span class="token function">bucketMask</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token operator">!=</span> checkBucket <span class="token punctuation">{</span>
               <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 对于不可比较的 key，</span>
            <span class="token comment">// 是由 tophash 的最低位来决定迁移到前半部分还是后半部分的。</span>
            <span class="token comment">// 取 checkBucket 的最高位来比较，因为 checkBucket 的最高位决定了</span>
            <span class="token comment">// 当前遍历的 bucket 是上半部分还是后半部分的 bucket。</span>
            <span class="token keyword">if</span> checkBucket<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>B<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>offi<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment">// 如果当前的 key 没有落入当前遍历的 bucket，则跳过它</span>
               <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      
      <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>offi<span class="token punctuation">]</span> <span class="token operator">!=</span> evacuatedX <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>tophash<span class="token punctuation">[</span>offi<span class="token punctuation">]</span> <span class="token operator">!=</span> evacuatedY<span class="token punctuation">)</span> <span class="token operator">||</span>
         <span class="token operator">!</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">reflexivekey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> t<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 上面的判断：</span>
         <span class="token comment">// 1、表示 key 还没有迁移。</span>
         <span class="token comment">// 2、或者，key 是不可比较的。</span>
         <span class="token comment">// 则直接返回</span>
         it<span class="token punctuation">.</span>key <span class="token operator">=</span> k
         <span class="token keyword">if</span> t<span class="token punctuation">.</span><span class="token function">indirectelem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         it<span class="token punctuation">.</span>elem <span class="token operator">=</span> e
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 自迭代器启动以来，哈希表已扩容。</span>
         <span class="token comment">// key 已经被迁移到其他地方。</span>
         <span class="token comment">// 检查当前哈希表中的数据。</span>
         <span class="token comment">// 此代码处理已删除、更新或删除并重新插入 key 的情况。</span>
         <span class="token comment">// 注意：我们需要重新标记 key，因为它可能已更新为 equal() 但不是相同的 key（例如 +0.0 vs -0.0）。</span>
         <span class="token comment">// 获取当前遍历到的 key/elem。</span>
         rk<span class="token punctuation">,</span> re <span class="token operator">:=</span> <span class="token function">mapaccessK</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> h<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
         <span class="token keyword">if</span> rk <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token comment">// key 已经被删除了，继续遍历下一个 key</span>
            <span class="token keyword">continue</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 外部是通过 it 的 key/elem 来获取当前遍历到的键值对的</span>
         it<span class="token punctuation">.</span>key <span class="token operator">=</span> rk
         it<span class="token punctuation">.</span>elem <span class="token operator">=</span> re
      <span class="token punctuation">}</span>
      <span class="token comment">// 记录当前迭代的 bucket</span>
      it<span class="token punctuation">.</span>bucket <span class="token operator">=</span> bucket
      <span class="token comment">// 遍历到下一个 bucket 了，更新 bptr</span>
      <span class="token keyword">if</span> it<span class="token punctuation">.</span>bptr <span class="token operator">!=</span> b <span class="token punctuation">{</span> <span class="token comment">// avoid unnecessary write barrier; see issue 14921</span>
         it<span class="token punctuation">.</span>bptr <span class="token operator">=</span> b
      <span class="token punctuation">}</span>
      <span class="token comment">// 迭代器的 i 指向 bucket 内的下一个 key</span>
      it<span class="token punctuation">.</span>i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token comment">// 记录是否需要检查 key 的标记</span>
      it<span class="token punctuation">.</span>checkBucket <span class="token operator">=</span> checkBucket
      <span class="token comment">// 找到了键值对（保存在 it.key/it.elem 中了），返回。</span>
      <span class="token comment">// mapiternext 外部可以通过 hiter 的 key/elem 属性来获取当前遍历到的 key/val。</span>
      <span class="token comment">// 遍历下一个元素的时候，再次调用 mapiternext 函数。</span>
      <span class="token comment">//（无所谓，hiter 会记住迭代到哪里的）</span>
      <span class="token comment">// 也即：每遍历一个元素，调用一次 mapiternext 函数。</span>
      <span class="token keyword">return</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 当前的 bucket 遍历完了，那么继续从溢出桶中查找下一个元素。</span>
   <span class="token comment">// b 指向溢出桶，迭代溢出桶</span>
   b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">overflow</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
   <span class="token comment">// 遍历下一个桶了，key 从 0 开始遍历</span>
   i <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token comment">// 遍历当前 bucket 的溢出桶</span>
   <span class="token keyword">goto</span> next
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br></div></div><h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <ul><li>哈希表相比数组，可以很快速地查找，所以常见的编程语言都会有对应的实现。</li> <li>哈希冲突有两种解决方法：<strong>开放地址法</strong>和<strong>链表法</strong>，go 里的 <code>map</code> 使用的是<strong>链表法</strong>。</li> <li>哈希表初始化分配的是比较小的内存，只能存放少量键值对，但是随着我们插入的数据越来越多，哈希表会进行扩容，防止哈希表的读写性能下降。</li> <li>go 的 <code>map</code> 扩容有两种方式：键值对太多的时候会进行 2 倍扩容，溢出桶太多会进行等量扩容。</li> <li><code>map</code> 中使用 <code>buckets</code> 来存储桶，一个桶里面可以存储 <code>8</code> 个键值对，一个桶满了的时候，会创建溢出桶来保存多出来的 <code>key</code>。</li> <li><code>map</code> 中桶的结构体是 <code>bmap</code>，它里面的会将所有 <code>key</code> 连续存储，所有的 <code>value</code> 也会连续存储。</li> <li><code>map</code> 定位 <code>key</code> 的时候，会使用哈希值与 <code>B</code> 的掩码做 <code>&amp;</code> 运算（我们可以将其理解为一种模运算的另外一种实现），从而得到 <code>bucket</code> 的下标，然后遍历这个 <code>bucket</code> 中的每一个槽。先比较 <code>tophash</code>，如果 <code>tophash</code> 相等再比较 <code>key</code>，如果 <code>tophash</code> 和 <code>key</code> 都相等，则表明找到了我们要找的 <code>key</code>。如果这两者有一个不等，继续比较下一个 <code>key</code>。</li> <li>如果一个 <code>bucket</code> 中的所有 <code>key</code> 被遍历完了也没有找到，那么继续从溢出桶中查找。</li> <li><code>map</code> 读取数据是通过 <code>mapaccess1</code>、<code>mapaccess2</code>、<code>mapaccessK</code> 实现的，对于整型键值的 <code>map</code> 有优化的 <code>mapaccess</code> 实现（对于 <code>bmap</code> 里键值的访问更加高效）。</li> <li><code>map</code> 写入和修改数据都是通过 <code>mapassign</code> 函数实现的，这个函数在找不到 <code>key</code> 的时候会进行插入操作。</li> <li><code>map</code> 删除数据是通过 <code>mapdelete</code> 函数实现的。删除的时候会需要将 <code>bucket</code> 末尾的所有空的槽的标记更新为 <code>emptyRest</code>。</li> <li><code>map</code> 扩容的条件有两个：超过负载因子、溢出桶太多。只有在增量扩容的时候，<code>key</code> 所对应的 <code>bucket</code> 的下标才有可能发生变化。</li> <li><code>map</code> 扩容的时候，会迁移当前正在写入、删除的 <code>bucket</code>，同时也会从第一个 <code>bucket</code> 开始迁移，一次写操作会迁移两个 <code>bucket</code>。这样可以保证在一定的写操作以后，所有 <code>bucket</code> 都能迁移完成。</li> <li>等量扩容的时候，<code>key</code> 在新桶中的 <code>bucket</code> 下标不变，但是 <code>key</code> 在桶内的分布会更加地紧凑，从而会提高查找效率。</li> <li><code>map</code> 的迭代是通过 <code>hiter</code> 结构体来实现的，迭代的过程中 <code>hiter</code> 会记录当前的 <code>bucket</code>、<code>key</code>，普通桶迭代完后，迭代溢出桶。<code>map</code> 的迭代是通过 <code>mapiternext</code> 函数实现的，每次获取键值对都是通过这个 <code>mapiternext</code> 函数。</li> <li><code>map</code> 迭代如果发生在增量扩容的时候，对于未迁移的 <code>bucket</code>，会判断 <code>key</code> 的 <code>bucket</code> 是否会发生变化，如果 <code>key</code> 对应的 <code>bucket</code> 已经改变，则迭代的时候会跳过。</li></ul></div></div> <div class="page-slot page-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script></br><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="auto"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="7043271566"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Golang" title="标签">#Golang</a><a href="/tags/?tag=map" title="标签">#map</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/17/2023</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Goroutine 泄露 - 被遗忘的发送者</div></a> <a href="/pages/golang/go-slice/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">go slice 设计与实现</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="prev">Goroutine 泄露 - 被遗忘的发送者</a></span> <span class="next"><a href="/pages/golang/go-slice/">go slice 设计与实现</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/mosquito-config-ws/"><div>
            mosquito配置ws协议
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/pip-download-offline/"><div>
            Pip包的离线下载和安装
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/favorites/sd/"><div>
            stable diffusion 相关收藏
            <!----></div></a> <span class="date">02-24</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/moxiaolong" title="Star我" target="_blank" class="iconfont icon-github"></a><a href="http://music.163.com/playlist?id=8444337" title="有品位的歌单" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2024
    <span>Dra-M</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bc3c2a75.js" defer></script><script src="/assets/js/2.472001a0.js" defer></script><script src="/assets/js/32.67d8d455.js" defer></script>
  </body>
</html>
