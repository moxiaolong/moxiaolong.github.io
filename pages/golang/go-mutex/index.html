<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入理解 go Mutex | Dra-M</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/logo.webp">
    <link rel="manifest" href="/manifest.json">
    <script data-ad-client="ca-pub-8621788234752924" defer="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924" crossorigin="anonymous"></script>
    <meta name="description" content="一些技术(前端、后端、运维)相关的经验、随想、资源收藏，和一些哲学随想。">
    <meta name="keywords" content="开发技术,哲学,DragonMo,Dra-M,莫小龙">
    <meta name="theme-color" content="#7b074b">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <link rel="preload" href="/assets/css/0.styles.8ee39092.css" as="style"><link rel="preload" href="/assets/js/app.bc3c2a75.js" as="script"><link rel="preload" href="/assets/js/2.472001a0.js" as="script"><link rel="preload" href="/assets/js/38.05c111ca.js" as="script"><link rel="prefetch" href="/assets/js/10.da818c35.js"><link rel="prefetch" href="/assets/js/100.c9dc513a.js"><link rel="prefetch" href="/assets/js/101.f3685f69.js"><link rel="prefetch" href="/assets/js/102.98577fde.js"><link rel="prefetch" href="/assets/js/103.401885da.js"><link rel="prefetch" href="/assets/js/104.5ca2a2ba.js"><link rel="prefetch" href="/assets/js/105.896bd937.js"><link rel="prefetch" href="/assets/js/106.199efe2c.js"><link rel="prefetch" href="/assets/js/107.206ba497.js"><link rel="prefetch" href="/assets/js/108.c1eb4655.js"><link rel="prefetch" href="/assets/js/109.221866e5.js"><link rel="prefetch" href="/assets/js/11.a6aff4f5.js"><link rel="prefetch" href="/assets/js/110.e3239981.js"><link rel="prefetch" href="/assets/js/111.ef06b5a1.js"><link rel="prefetch" href="/assets/js/112.ccf225d6.js"><link rel="prefetch" href="/assets/js/113.8d8640b2.js"><link rel="prefetch" href="/assets/js/114.056f749a.js"><link rel="prefetch" href="/assets/js/115.ed35567d.js"><link rel="prefetch" href="/assets/js/116.29426a1f.js"><link rel="prefetch" href="/assets/js/117.86847b2b.js"><link rel="prefetch" href="/assets/js/118.885246c5.js"><link rel="prefetch" href="/assets/js/119.6b04ff26.js"><link rel="prefetch" href="/assets/js/12.dd3a474e.js"><link rel="prefetch" href="/assets/js/120.99542ea6.js"><link rel="prefetch" href="/assets/js/121.c89b2199.js"><link rel="prefetch" href="/assets/js/122.b4c96f13.js"><link rel="prefetch" href="/assets/js/123.e74abe64.js"><link rel="prefetch" href="/assets/js/124.5479e5ef.js"><link rel="prefetch" href="/assets/js/125.47f5d91e.js"><link rel="prefetch" href="/assets/js/126.2eda5054.js"><link rel="prefetch" href="/assets/js/127.fbf8b987.js"><link rel="prefetch" href="/assets/js/128.3bb898fe.js"><link rel="prefetch" href="/assets/js/129.59014c61.js"><link rel="prefetch" href="/assets/js/13.2d318d3d.js"><link rel="prefetch" href="/assets/js/130.b5701dcd.js"><link rel="prefetch" href="/assets/js/131.af42802d.js"><link rel="prefetch" href="/assets/js/132.a0a52815.js"><link rel="prefetch" href="/assets/js/133.c7f6fcd9.js"><link rel="prefetch" href="/assets/js/134.1fa00d40.js"><link rel="prefetch" href="/assets/js/135.1c93b5ec.js"><link rel="prefetch" href="/assets/js/136.ce22005d.js"><link rel="prefetch" href="/assets/js/137.d689e32c.js"><link rel="prefetch" href="/assets/js/138.52557618.js"><link rel="prefetch" href="/assets/js/139.5576ce4a.js"><link rel="prefetch" href="/assets/js/14.41100292.js"><link rel="prefetch" href="/assets/js/140.3becc2ed.js"><link rel="prefetch" href="/assets/js/141.60103e1a.js"><link rel="prefetch" href="/assets/js/142.f44d458d.js"><link rel="prefetch" href="/assets/js/143.5a60f54e.js"><link rel="prefetch" href="/assets/js/144.ce362fab.js"><link rel="prefetch" href="/assets/js/145.f4d3209c.js"><link rel="prefetch" href="/assets/js/146.f90aee50.js"><link rel="prefetch" href="/assets/js/15.daabeb64.js"><link rel="prefetch" href="/assets/js/16.a4a3b21c.js"><link rel="prefetch" href="/assets/js/17.8b6cce9b.js"><link rel="prefetch" href="/assets/js/18.60b289d4.js"><link rel="prefetch" href="/assets/js/19.0c18504f.js"><link rel="prefetch" href="/assets/js/20.7a975e23.js"><link rel="prefetch" href="/assets/js/21.3329c224.js"><link rel="prefetch" href="/assets/js/22.5df3725f.js"><link rel="prefetch" href="/assets/js/23.1e2b6c8a.js"><link rel="prefetch" href="/assets/js/24.aac0154b.js"><link rel="prefetch" href="/assets/js/25.b26ee63b.js"><link rel="prefetch" href="/assets/js/26.6b63d3fb.js"><link rel="prefetch" href="/assets/js/27.8b487354.js"><link rel="prefetch" href="/assets/js/28.731619d6.js"><link rel="prefetch" href="/assets/js/29.4fe59357.js"><link rel="prefetch" href="/assets/js/3.6dd7c6e7.js"><link rel="prefetch" href="/assets/js/30.a93d8117.js"><link rel="prefetch" href="/assets/js/31.42cc0c6c.js"><link rel="prefetch" href="/assets/js/32.67d8d455.js"><link rel="prefetch" href="/assets/js/33.da390ef3.js"><link rel="prefetch" href="/assets/js/34.47f5bc34.js"><link rel="prefetch" href="/assets/js/35.bb95ae18.js"><link rel="prefetch" href="/assets/js/36.79ce5ff9.js"><link rel="prefetch" href="/assets/js/37.e48e5b35.js"><link rel="prefetch" href="/assets/js/39.a9c4a557.js"><link rel="prefetch" href="/assets/js/4.76079b7d.js"><link rel="prefetch" href="/assets/js/40.45a45204.js"><link rel="prefetch" href="/assets/js/41.978ccffc.js"><link rel="prefetch" href="/assets/js/42.895064c8.js"><link rel="prefetch" href="/assets/js/43.c9b2330d.js"><link rel="prefetch" href="/assets/js/44.114f4169.js"><link rel="prefetch" href="/assets/js/45.5a1432cf.js"><link rel="prefetch" href="/assets/js/46.cce4db9a.js"><link rel="prefetch" href="/assets/js/47.b9ba2714.js"><link rel="prefetch" href="/assets/js/48.2e84c7f6.js"><link rel="prefetch" href="/assets/js/49.77f31886.js"><link rel="prefetch" href="/assets/js/5.13679220.js"><link rel="prefetch" href="/assets/js/50.70b8a00f.js"><link rel="prefetch" href="/assets/js/51.8f3d4e26.js"><link rel="prefetch" href="/assets/js/52.a0dff1b5.js"><link rel="prefetch" href="/assets/js/53.1a5d0aa9.js"><link rel="prefetch" href="/assets/js/54.d9b622f7.js"><link rel="prefetch" href="/assets/js/55.a078dc68.js"><link rel="prefetch" href="/assets/js/56.5a331510.js"><link rel="prefetch" href="/assets/js/57.5bec8258.js"><link rel="prefetch" href="/assets/js/58.21fe4b06.js"><link rel="prefetch" href="/assets/js/59.53211a94.js"><link rel="prefetch" href="/assets/js/6.738f6e32.js"><link rel="prefetch" href="/assets/js/60.1d1893dd.js"><link rel="prefetch" href="/assets/js/61.2dd0ba1c.js"><link rel="prefetch" href="/assets/js/62.4df81247.js"><link rel="prefetch" href="/assets/js/63.e7645407.js"><link rel="prefetch" href="/assets/js/64.c1510d68.js"><link rel="prefetch" href="/assets/js/65.e80f3f86.js"><link rel="prefetch" href="/assets/js/66.705d839b.js"><link rel="prefetch" href="/assets/js/67.852e9ce9.js"><link rel="prefetch" href="/assets/js/68.67fbda7f.js"><link rel="prefetch" href="/assets/js/69.7a78efb2.js"><link rel="prefetch" href="/assets/js/7.48b86259.js"><link rel="prefetch" href="/assets/js/70.9fc82048.js"><link rel="prefetch" href="/assets/js/71.ab52b5cf.js"><link rel="prefetch" href="/assets/js/72.e7c7a340.js"><link rel="prefetch" href="/assets/js/73.539e40a1.js"><link rel="prefetch" href="/assets/js/74.598221c8.js"><link rel="prefetch" href="/assets/js/75.876e901b.js"><link rel="prefetch" href="/assets/js/76.42349440.js"><link rel="prefetch" href="/assets/js/77.5834f7c5.js"><link rel="prefetch" href="/assets/js/78.78c797f4.js"><link rel="prefetch" href="/assets/js/79.5d0d35ae.js"><link rel="prefetch" href="/assets/js/8.10c02f71.js"><link rel="prefetch" href="/assets/js/80.e7bc8390.js"><link rel="prefetch" href="/assets/js/81.e4e4f6a8.js"><link rel="prefetch" href="/assets/js/82.98057949.js"><link rel="prefetch" href="/assets/js/83.ad7dd690.js"><link rel="prefetch" href="/assets/js/84.0f7a664d.js"><link rel="prefetch" href="/assets/js/85.378369eb.js"><link rel="prefetch" href="/assets/js/86.01ead6d0.js"><link rel="prefetch" href="/assets/js/87.70598ba5.js"><link rel="prefetch" href="/assets/js/88.600910d8.js"><link rel="prefetch" href="/assets/js/89.c783c1e2.js"><link rel="prefetch" href="/assets/js/9.4b59881c.js"><link rel="prefetch" href="/assets/js/90.85995a12.js"><link rel="prefetch" href="/assets/js/91.21e9dbf9.js"><link rel="prefetch" href="/assets/js/92.8fc80426.js"><link rel="prefetch" href="/assets/js/93.6d7adcc8.js"><link rel="prefetch" href="/assets/js/94.6147d1d9.js"><link rel="prefetch" href="/assets/js/95.61c3d1ab.js"><link rel="prefetch" href="/assets/js/96.1dc4b4c8.js"><link rel="prefetch" href="/assets/js/97.c4c52395.js"><link rel="prefetch" href="/assets/js/98.b78d3e0f.js"><link rel="prefetch" href="/assets/js/99.f1c7ba9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ee39092.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.webp" alt="Dra-M" class="logo"> <span class="site-name can-hide">Dra-M</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=975425198&amp;s=640"> <div class="blogger-info"><h3>莫小龙</h3> <span>保持理智，相信未来。</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Golang</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/golang-gitlab-ssh/" class="sidebar-link">GitLab私服+Go Modules踩坑经验（SSH自定义端口）</a></li><li><a href="/pages/gin/middle/" class="sidebar-link">【代码片段】我使用的Gin中间处理器（自定义异常处理、日志打印、traceId、跨域配置）</a></li><li><a href="/pages/java-to-golang/value-and-reference/" class="sidebar-link">【Java转Go】如何理解Go中的值类型、引用类型、nil</a></li><li><a href="/pages/java-to-golang/oop/" class="sidebar-link">【Java转Go】如何理解面向对象，怎么把Golang用成面向对象的样子</a></li><li><a href="/pages/golang/gmp/" class="sidebar-link">Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="/pages/golang/go-gmp-status/" class="sidebar-link">Go中GMP有哪些状态？</a></li><li><a href="/pages/golang/go-gc/" class="sidebar-link">一文搞懂go gc垃圾回收原理</a></li><li><a href="/pages/golang/go-block/" class="sidebar-link">Go什么时候发生阻塞？阻塞时，调度器会怎么做？</a></li><li><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/" class="sidebar-link">Go netpoller 原生网络模型之源码全面揭秘</a></li><li><a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="sidebar-link">Goroutine 泄露 - 被遗忘的发送者</a></li><li><a href="/pages/golang/go-map/" class="sidebar-link">go map 设计与实现</a></li><li><a href="/pages/golang/go-slice/" class="sidebar-link">go slice 设计与实现</a></li><li><a href="/pages/golang/go-context/" class="sidebar-link">小白也能看懂的context包详解：从入门到精通</a></li><li><a href="/pages/golang/go-interface/" class="sidebar-link">go interface 设计与实现</a></li><li><a href="/pages/golang/go-chan/" class="sidebar-link">深入理解 go chan</a></li><li><a href="/pages/golang/go-chan-design-and-implementation/" class="sidebar-link">go chan 设计与实现</a></li><li><a href="/pages/golang/go-mutex/" aria-current="page" class="active sidebar-link">深入理解 go Mutex</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#互斥锁的定义" class="sidebar-link">互斥锁的定义</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#go-mutex-的基本用法" class="sidebar-link">go Mutex 的基本用法</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#互斥锁使用的两个例子" class="sidebar-link">互斥锁使用的两个例子</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-mutex/#gin-context-中的-set-方法" class="sidebar-link">gin Context 中的 Set 方法</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-mutex/#sync-pool-中的-pinslow-方法" class="sidebar-link">sync.Pool 中的 pinSlow 方法</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#互斥锁使用的注意事项" class="sidebar-link">互斥锁使用的注意事项</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#互斥锁锁定的是什么" class="sidebar-link">互斥锁锁定的是什么？</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#互斥锁实现原理" class="sidebar-link">互斥锁实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-mutex/#信号量" class="sidebar-link">信号量</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-mutex/#等待队列" class="sidebar-link">等待队列</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-mutex/#原子操作" class="sidebar-link">原子操作</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#mutex-的公平性" class="sidebar-link">Mutex 的公平性</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#mutex-源码剖析" class="sidebar-link">Mutex 源码剖析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-mutex/#lock" class="sidebar-link">Lock</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-mutex/#unlock" class="sidebar-link">Unlock</a></li><li class="sidebar-sub-header level4"><a href="/pages/golang/go-mutex/#runtime-semrelease-第二个参数的含义" class="sidebar-link">runtime_Semrelease 第二个参数的含义</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-mutex/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/pages/golang/go-sync-map-1/" class="sidebar-link">深入理解 go sync.Map - 基本原理</a></li><li><a href="/pages/golang/go-sync-map-2/" class="sidebar-link">go sync.Map 设计与实现</a></li><li><a href="/pages/golang/go-sync-once/" class="sidebar-link">深入理解 go sync.Once</a></li><li><a href="/pages/golang/go-reflect-1/" class="sidebar-link">深入理解 go reflect - 反射基本原理</a></li><li><a href="/pages/golang/go-reflect-2/" class="sidebar-link">深入理解 go reflect - 要不要传指针</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程思想</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运维</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script><ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="8498052873"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/code/#技术" data-v-06225672>技术</a></li><li data-v-06225672><a href="/code/#Golang" data-v-06225672>Golang</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://juejin.cn/post/7216223889488560184" target="_blank" title="作者" class="beLink" data-v-06225672>eleven26</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-08-09</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="/img/dragon/18.webp">深入理解 go Mutex<!----></h1>  <div class="theme-vdoing-content content__default"><p>在我们的日常开发中，总会有时候需要对一些变量做并发读写，比如 web 应用在同时接到多个请求之后， 需要对一些资源做初始化，而这些资源可能是只需要初始化一次的，而不是每一个 http 请求都初始化， 在这种情况下，我们需要限制只能一个协程来做初始化的操作，比如初始化数据库连接等， 这个时候，我们就需要有一种机制，可以限制只有一个协程来执行这些初始化的代码。 在 go 语言中，我们可以使用互斥锁（<code>Mutex</code>）来实现这种功能。
</p> <h2 id="互斥锁的定义"><a href="#互斥锁的定义" class="header-anchor">#</a> 互斥锁的定义</h2> <p>这里引用一下维基百科的定义：</p> <p>互斥锁（<em>Mutual exclusion</em>，缩写 <code>Mutex</code>）是一种用于多线程编程中，防止两个线程同时对同一公共资源 （比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（<em>critical section</em>）达成。 临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</p> <blockquote><p>互斥，顾名思义，也就是只有一个线程能持有锁。当然，在 go 中，是只有一个协程能持有锁。</p></blockquote> <p>下面是一个简单的例子：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> sum <span class="token builtin">int</span> <span class="token comment">// 和</span>
<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex <span class="token comment">// 互斥锁</span>

<span class="token comment">// add 将 sum 加 1</span>
<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取锁，只能有一个协程获取到锁，</span>
    <span class="token comment">// 其他协程需要阻塞等待锁释放才能获取到锁。</span>
   mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 临界区域</span>
   sum<span class="token operator">++</span>
   mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">TestMutex</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 启动 1000 个协程</span>
   <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
   wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>

   <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 每个协程里面调用 add()</span>
         <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 等待所有协程执行完毕</span>
   wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 最终 sum 的值应该是 1000</span>
   assert<span class="token punctuation">.</span><span class="token function">Equal</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>上面的例子中，我们定义了一个全局变量 <code>sum</code>，用于存储和，然后定义了一个互斥锁 <code>mu</code>， 在 <code>add()</code> 函数中，我们使用 <code>mu.Lock()</code> 来加锁，然后对 <code>sum</code> 进行加 1 操作， 最后使用 <code>mu.Unlock()</code> 来解锁，这样就保证了在任意时刻，只有一个协程能够对 <code>sum</code> 进行加 1 操作， 从而保证了在并发执行 <code>add()</code> 操作的时候 <code>sum</code> 的值是正确的。</p> <blockquote><p>上面这个例子，在我之前的文章中已经作为例子出现过很多次了，这里不再赘述了。</p></blockquote> <h2 id="go-mutex-的基本用法"><a href="#go-mutex-的基本用法" class="header-anchor">#</a> go Mutex 的基本用法</h2> <p><code>Mutex</code> 我们一般只会用到它的两个方法：</p> <ul><li><code>Lock</code>：获取互斥锁。(只会有一个协程可以获取到锁，通常用在临界区开始的地方。)</li> <li><code>Unlock</code>: 释放互斥锁。(释放获取到的锁，通常用在临界区结束的地方。)</li></ul> <p><code>Mutex</code> 的模型可以用下图表示：</p> <p><img src="/images/go/mutex/1.webp" alt="mutex_1.png"></p> <p>说明：</p> <ul><li>同一时刻只能有一个协程获取到 <code>Mutex</code> 的使用权，其他协程需要排队等待（也就是上图的 <code>G1-&gt;G2-&gt;Gn</code>）。</li> <li>拥有锁的协程从临界区退出的时候需要使用 <code>Unlock</code> 来释放锁，这个时候等待队列的下一个协程可以获取到锁（实际实现比这里说的复杂很多，后面会细说），从而进入临界区。</li> <li>等待的协程会在 <code>Lock</code> 调用处阻塞，<code>Unlock</code> 的时候会使得一个等待的协程解除阻塞的状态，得以继续执行。</li></ul> <blockquote><p>上面提到的这几点也是 <code>Mutex</code> 的基本原理。</p></blockquote> <h2 id="互斥锁使用的两个例子"><a href="#互斥锁使用的两个例子" class="header-anchor">#</a> 互斥锁使用的两个例子</h2> <p>了解了 go <code>Mutex</code> 基本原理之后，让我们再来看看 <code>Mutex</code> 的一些使用的例子。</p> <h3 id="gin-context-中的-set-方法"><a href="#gin-context-中的-set-方法" class="header-anchor">#</a> gin Context 中的 Set 方法</h3> <p>一个很常见的场景就是，并发对 <code>map</code> 进行读写，熟悉 go 的朋友应该知道，go 中的 <code>map</code> 是不支持并发读写的， 如果我们对 <code>map</code> 进行并发读写会导致 <code>panic</code>。</p> <p>而在 <code>gin</code> 的 <code>Context</code> 结构体中，也有一个 <code>map</code> 类型的字段 <code>Keys</code>，用来在上下文间传递键值对数据， 所以在通过 <code>Set</code> 来设置键值对的时候需要使用 <code>c.mu.Lock()</code> 来先获取互斥锁，然后再对 <code>Keys</code> 做设置。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Set is used to store a new key/value pair exclusively for this context.</span>
<span class="token comment">// It also lazy initializes  c.Keys if it was not used previously.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Context<span class="token punctuation">)</span> <span class="token function">Set</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> value any<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取锁</span>
   c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 如果 Keys 还没初始化，则进行初始化</span>
   <span class="token keyword">if</span> c<span class="token punctuation">.</span>Keys <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      c<span class="token punctuation">.</span>Keys <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>any<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

    <span class="token comment">// 设置键值对</span>
   c<span class="token punctuation">.</span>Keys<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token comment">// 释放锁</span>
   c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>同样的，对 <code>Keys</code> 做读操作的时候也需要使用互斥锁：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Get returns the value for the given key, ie: (value, true).</span>
<span class="token comment">// If the value does not exist it returns (nil, false)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Context<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>value any<span class="token punctuation">,</span> exists <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取锁</span>
   c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 读取 key</span>
   value<span class="token punctuation">,</span> exists <span class="token operator">=</span> c<span class="token punctuation">.</span>Keys<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token comment">// 释放锁</span>
   c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>可能会有人觉得奇怪，为什么从 <code>map</code> 中读也还需要锁。这是因为，如果读的时候没有锁保护， 那么就有可能在 <code>Set</code> 设置的过程中，同时也在进行读操作，这样就会 <code>panic</code> 了。</p></blockquote> <p>这个例子想要说明的是，像 <code>map</code> 这种数据结构本身就不支持并发读写，我们这种情况下只有使用 <code>Mutex</code> 了。</p> <h3 id="sync-pool-中的-pinslow-方法"><a href="#sync-pool-中的-pinslow-方法" class="header-anchor">#</a> sync.Pool 中的 pinSlow 方法</h3> <p>在 <code>sync.Pool</code> 的实现中，有一个全局变量记录了进程内所有的 <code>sync.Pool</code> 对象，那就是 <code>allPools</code> 变量， 另外有一个锁 <code>allPoolsMu</code> 用来保护对 <code>allPools</code> 的读写操作：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> <span class="token punctuation">(</span>
   <span class="token comment">// 保护 allPools 和 oldPools 的互斥锁。</span>
   allPoolsMu Mutex

   <span class="token comment">// allPools is the set of pools that have non-empty primary</span>
   <span class="token comment">// caches. Protected by either 1) allPoolsMu and pinning or 2)</span>
   <span class="token comment">// STW.</span>
   allPools <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Pool

   <span class="token comment">// oldPools is the set of pools that may have non-empty victim</span>
   <span class="token comment">// caches. Protected by STW.</span>
   oldPools <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Pool
<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><code>pinSlow</code> 方法中会在 <code>allPoolsMu</code> 的保护下对 <code>allPools</code> 做读写操作：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Pool<span class="token punctuation">)</span> <span class="token function">pinSlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>poolLocal<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// Retry under the mutex.</span>
   <span class="token comment">// Can not lock the mutex while pinned.</span>
   <span class="token function">runtime_procUnpin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   allPoolsMu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取锁</span>
   <span class="token keyword">defer</span> allPoolsMu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 函数返回的时候释放锁</span>
   pid <span class="token operator">:=</span> <span class="token function">runtime_procPin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// poolCleanup won't be called while we are pinned.</span>
   s <span class="token operator">:=</span> p<span class="token punctuation">.</span>localSize
   l <span class="token operator">:=</span> p<span class="token punctuation">.</span>local
   <span class="token keyword">if</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> s <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">indexLocal</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">,</span> pid
   <span class="token punctuation">}</span>
   <span class="token keyword">if</span> p<span class="token punctuation">.</span>local <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
      allPools <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>allPools<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token comment">// 全局变量修改</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span>
   size <span class="token operator">:=</span> runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
   local <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>poolLocal<span class="token punctuation">,</span> size<span class="token punctuation">)</span>
   atomic<span class="token punctuation">.</span><span class="token function">StorePointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">.</span>local<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// store-release</span>
   <span class="token function">runtime_StoreReluintptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">.</span>localSize<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// store-release</span>
   <span class="token keyword">return</span> <span class="token operator">&amp;</span>local<span class="token punctuation">[</span>pid<span class="token punctuation">]</span><span class="token punctuation">,</span> pid
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>这个例子主要是为了说明使用 <code>mu</code> 的另外一种非常常见的场景：<strong>并发读写全局变量</strong>。</p> <h2 id="互斥锁使用的注意事项"><a href="#互斥锁使用的注意事项" class="header-anchor">#</a> 互斥锁使用的注意事项</h2> <p>互斥锁如果使用不当，可能会导致死锁或者出现 <code>panic</code> 的情况，下面是一些常见的错误：</p> <ol><li>忘记使用 <code>Unlock</code> 释放锁。</li> <li><code>Lock</code> 之后还没 <code>Unlock</code> 之前又使用 <code>Lock</code> 获取锁。也就是重复上锁，go 中的 <code>Mutex</code> 不可重入。</li> <li>死锁：位于临界区内不同的两个协程都想获取对方持有的不同的锁。</li> <li>还没 <code>Lock</code> 之前就 <code>Unlock</code>。这会导致 <code>panic</code>，因为这是没有任何意义的。</li> <li>复制 <code>Mutex</code>，比如将 <code>Mutex</code> 作为参数传递。</li></ol> <p>对于第 1 点，我们往往可以使用 <code>defer</code> 关键字来做释放锁的操作。第 2 点不太好发现，只能在开发的时候多加注意。 第 3 点我们在使用锁的时候可以考虑尽量避免在临界区内再去使用别的锁。 最后，<code>Mutex</code> 是不可以复制的，这个可以在编译之前通过 <code>go vet</code> 来做检查。</p> <p>为什么 <code>Mutex</code> 不能被复制呢？因为 <code>Mutex</code> 中包含了锁的状态，如果复制了，那么这个状态也会被复制， 如果在复制前进行 <code>Lock</code>，复制后进行 <code>Unlock</code>，那就意味着 <code>Lock</code> 和 <code>Unlock</code> 操作的其实是两个不同的状态， 这样显然是不行的，是释放不了锁的。</p> <blockquote><p>虽然不可以复制，但是我们可以通过传递指针类型的参数来传递 <code>Mutex</code>。</p></blockquote> <h2 id="互斥锁锁定的是什么"><a href="#互斥锁锁定的是什么" class="header-anchor">#</a> 互斥锁锁定的是什么？</h2> <p>在前一篇文章中，我们提到过，原子操作本质上是变量级的互斥锁。而互斥锁本身锁定的又是什么呢？ 其实互斥锁本质上是一个信号量，它通过获取释放信号量，最终使得协程获得某一个代码块的执行权力。</p> <blockquote><p>也就是说，互斥锁，锁定的是一块代码块。</p></blockquote> <p>我们以 <code>go-zero</code> 里面的 <code>collection/fifo.go</code> 为例子说明一下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Take takes the first element out of q if not empty.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>q <span class="token operator">*</span>Queue<span class="token punctuation">)</span> <span class="token function">Take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>any<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 获取互斥锁（只能有一个协程获取到锁）</span>
   q<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 函数返回的时候释放互斥锁（获取到锁的协程释放锁之后，其他协程才能进行抢占锁）</span>
   <span class="token keyword">defer</span> q<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token comment">// 下面的代码只有抢占到（也就是互斥锁锁定的代码块）</span>
   <span class="token keyword">if</span> q<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
   <span class="token punctuation">}</span>

   element <span class="token operator">:=</span> q<span class="token punctuation">.</span>elements<span class="token punctuation">[</span>q<span class="token punctuation">.</span>head<span class="token punctuation">]</span>
   q<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token function">len</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>elements<span class="token punctuation">)</span>
   q<span class="token punctuation">.</span>count<span class="token operator">--</span>

   <span class="token keyword">return</span> element<span class="token punctuation">,</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>除了锁定代码块的这一个作用，有另外一个比较关键的地方也是我们不能忽视的， 那就是 <strong>互斥锁并不保证临界区内操作的变量不能被其他协程访问。</strong> 互斥锁只能保证一段代码只能一个协程执行，但是对于临界区内涉及的共享资源， 你在临界区外也依然是可以对其进行读写的。</p> <p>我们以上面的代码说明一下：在上面的 <code>Take</code> 函数中，我们对 <code>q.head</code> 和 <code>q.count</code> 都进行了操作， 虽然这些操作代码位于临界区内，但是临界区并不保证持有锁期间其他协程不会在临界区外去修改 <code>q.head</code> 和 <code>q.count</code>。</p> <p>下面就是一个非常典型的<strong>错误</strong>的例子：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">import</span> <span class="token punctuation">(</span>
   <span class="token string">&quot;fmt&quot;</span>
   <span class="token string">&quot;sync&quot;</span>
   <span class="token string">&quot;testing&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
<span class="token keyword">var</span> sum <span class="token builtin">int</span>

<span class="token comment">// 在锁的保护下对 sum 做读写操作</span>
<span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   sum<span class="token operator">++</span>
   mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">TestMutex</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
   wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>

   <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

      <span class="token comment">// 位于临界区外，也依然是可以对 sum 做读写操作的。</span>
      sum<span class="token operator">++</span>
   <span class="token punctuation">}</span>

   wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><blockquote><p>靠谱的做法是，对于有共享资源的读写的操作都使用 <code>Mutex</code> 保护起来。</p></blockquote> <p>当然，如果我们只有一个变量，那么可能使用原子操作就足够了。</p> <h2 id="互斥锁实现原理"><a href="#互斥锁实现原理" class="header-anchor">#</a> 互斥锁实现原理</h2> <p>互斥锁的实现有以下几个关键的地方：</p> <ul><li>信号量：这是操作系统中的同步对象。</li> <li>等待队列：获取不到互斥锁的协程，会放入到一个先入先出队列的队列尾部。这样信号量释放的时候，可以依次对它们唤醒。</li> <li>原子操作：互斥锁的实现中，使用了一个字段来记录了几种不同的状态，使用原子操作可以保证几种状态可以一次性变更完成。</li></ul> <p>我们先来看看 <code>Mutex</code>结构体定义：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">type</span> Mutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   state <span class="token builtin">int32</span> <span class="token comment">// 状态字段</span>
   sema  <span class="token builtin">uint32</span> <span class="token comment">// 信号量</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其中 <code>state</code> 字段记录了四种不同的信息：</p> <p><img src="/images/go/mutex/2.webp" alt="mutex_2.png"></p> <p>这四种不同信息在源码中定义了不同的常量：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">const</span> <span class="token punctuation">(</span>
   mutexLocked      <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">iota</span> <span class="token comment">// 表示有 goroutine 拥有锁</span>
   mutexWoken                   <span class="token comment">// 唤醒（就是第 2 位）</span>
   mutexStarving                <span class="token comment">// 饥饿（第 3 位）</span>
   mutexWaiterShift <span class="token operator">=</span> <span class="token boolean">iota</span>      <span class="token comment">// 表示第 4 位开始，表示等待者的数量</span>

   starvationThresholdNs <span class="token operator">=</span> <span class="token number">1e6</span>  <span class="token comment">// 1ms 进入饥饿模式的等待时间阈值</span>
<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>而 <code>sema</code> 的含义比较简单，就是一个用作不同 goroutine 同步的信号量。</p> <h3 id="信号量"><a href="#信号量" class="header-anchor">#</a> 信号量</h3> <p>go 的 <code>Mutex</code> 是基于信号量来实现的，那信号量又是什么呢？</p> <blockquote><p>维基百科：信号量是一个同步对象，用于保持在 <code>0</code> 至指定最大值之间的一个计数值。当线程完成一次对该 <code>semaphore</code> 对象的等待（<code>wait</code>）时，该计数值减一；当线程完成一次对 <code>semaphore</code> 对象的释放（<code>release</code>）时，计数值加一。</p></blockquote> <p>上面这个解释有点难懂，通俗地说，就是一个数字，调用 <code>wait</code> 的时候，这个数字减去 <code>1</code>，调用 <code>release</code> 的时候，这个数字加上 <code>1</code>。 （还有一个隐含的逻辑是，如果这个数小于 <code>0</code>，那么调用 <code>wait</code> 的时候会阻塞，直到它大于 <code>0</code>。）</p> <p>对应到 go 的 <code>Mutex</code> 中，有两个操作信号量的函数：</p> <ul><li><code>runtime_Semrelease</code>: 自动递增信号量并通知等待的 goroutine。</li> <li><code>runtime_SemacquireMutex</code>: 是一直等到信号量大于 0，然后自动递减。</li></ul> <p>我们注意到了，其实 <code>runtime_SemacquireMutex</code> 是有一个前提条件的，那就是等到信号量大于 0。 其实信号量的两个操作 <code>P/V</code> 就是一个加 1 一个减 1，所以在实际使用的时候，也是需要一个获取锁的操作对应一个释放锁的操作， 否则，其他协程都无法获取到锁，因为信号量一直不满足。</p> <h3 id="等待队列"><a href="#等待队列" class="header-anchor">#</a> 等待队列</h3> <p>go 中如果已经有 goroutine 持有互斥锁，那么其他的协程会放入一个 <code>FIFO</code> 队列中，如下图：</p> <p><img src="/images/go/mutex/3.webp" alt="mutex_3.png"></p> <p>说明：</p> <ul><li><code>G1</code> 表示持有互斥锁的 goroutine，<code>G2</code>...<code>Gn</code> 表示一个 goroutine 的等待队列，这是一个先入先出的队列。</li> <li><code>G1</code> 先持有锁，得以进入临界区，其他想抢占锁的 goroutine 阻塞在 <code>Lock</code> 调用处。</li> <li><code>G1</code> 在使用完锁后，会使用 <code>Unlock</code> 来释放锁，本质上是释放了信号量，然后会唤醒 <code>FIFO</code> 队列头部的 <code>goroutine</code>。</li> <li><code>G2</code> 从 <code>FIFO</code> 队列中移除，进入临界区。<code>G2</code> 使用完锁之后也会使用 <code>Unlock</code> 来释放锁。</li></ul> <blockquote><p>上面只是一个大概模型，在实际实现中，比这个复杂很多倍，下面会继续深入讲解。</p></blockquote> <h3 id="原子操作"><a href="#原子操作" class="header-anchor">#</a> 原子操作</h3> <p>go 的 <code>Mutex</code> 实现中，<code>state</code> 字段是一个 32 位的整数，不同的位记录了四种不同信息，在这种情况下， 只需要通过原子操作就可以保证一次性实现对四种不同状态信息的更改，而不需要更多额外的同步机制。</p> <p>但是毋庸置疑，这种实现会大大降低代码的可读性，因为通过一个整数来记录不同的信息， 就意味着，需要通过各种位运算来实现对这个整数不同位的修改，比如将上锁的操作：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token builtin">new</span> <span class="token operator">|=</span> mutexLocked
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当然，这只是 <code>Mutex</code> 实现中最简单的一种位运算了。下面以 <code>state</code> 记录的四种不同信息为维度来具体讲解一下：</p> <ul><li><div class="language- line-numbers-mode"><pre class="language-text"><code>mutexLocked
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>：这是</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>state
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>的最低位，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>表示锁被占用，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>表示锁没有被占用。</p> <ul><li><code>new := mutexLocked</code> 新状态为上锁状态</li></ul></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>mutexWoken
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>: 这是表示是否有协程被唤醒了的状态</p> <ul><li><code>new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken</code> 等待者数量减去 1 的同时，设置唤醒标识</li> <li><code>new &amp;^= mutexWoken</code> 清除唤醒标识</li></ul></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>mutexStarving
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>：饥饿模式的标识</p> <ul><li><code>new |= mutexStarving</code> 设置饥饿标识</li></ul></li> <li><p>等待者数量：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>state &gt;&gt; mutexWaiterShift
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>就是等待者的数量，也就是上面提到的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FIFO
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>队列中 goroutine 的数量</p> <ul><li><code>new += 1 &lt;&lt; mutexWaiterShift</code> 等待者数量加 1</li> <li><code>delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)</code> 上锁的同时，将等待者数量减 1</li></ul></li></ul> <blockquote><p>这里并没有涵盖 <code>Mutex</code> 中所有的位运算，其他操作在下文讲解源码实现的时候会提到。</p></blockquote> <p>在上面做了这一系列的位运算之后，我们会得到一个新的 <code>state</code> 状态，假设名为 <code>new</code>，那么我们就可以通过 <code>CAS</code> 操作来将 <code>Mutex</code> 的 <code>state</code> 字段更新：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过上面这个原子操作，我们就可以一次性地更新 <code>Mutex</code> 的 <code>state</code> 字段，也就是一次性更新了四种状态信息。</p> <blockquote><p>这种通过一个整数记录不同状态的写法在 <code>sync</code> 包其他的一些地方也有用到，比如 <code>WaitGroup</code> 中的 <code>state</code> 字段。</p></blockquote> <p>最后，对于这种操作，我们需要注意的是，因为我们在执行 <code>CAS</code> 前后是没有其他什么锁或者其他的保护机制的， 这也就意味着上面的这个 <code>CAS</code> 操作是有可能会失败的，那如果失败了怎么办呢？</p> <p>如果失败了，也就意味着肯定有另外一个 goroutine 率先执行了 <code>CAS</code> 操作并且成功了，将 <code>state</code> 修改为了一个新的值。 这个时候，其实我们前面做的一系列位运算得到的结果实际上已经不对了，在这种情况下，<strong>我们需要获取最新的 <code>state</code>，然后再次计算得到一个新的 <code>state</code>。</strong></p> <p>所以我们会在源码里面看到 <code>CAS</code> 操作是写在 <code>for</code> 循环里面的。</p> <h2 id="mutex-的公平性"><a href="#mutex-的公平性" class="header-anchor">#</a> Mutex 的公平性</h2> <p>在前面，我们提到 goroutien 获取不到锁的时候，会进入一个 <code>FIFO</code> 队列的队列尾，在实际实现中，其实没有那么简单， 为了获得更好的性能，在实现的时候会尽量先让运行状态的 goroutine 获得锁，当然如果队列中的 goroutine 等待太久（大于 1ms）， 那么就会先让队列中的 goroutine 获得锁。</p> <p>下面是文档中的说明：</p> <blockquote><p>Mutex 可以处于两种操作模式：正常模式和饥饿模式。在正常模式下，等待者按照FIFO（先进先出）的顺序排队，但是被唤醒的等待者不拥有互斥锁，会与新到达的 Goroutine 竞争所有权。新到达的 Goroutine 有优势——它们已经在 CPU 上运行，数量可能很多，因此被唤醒的等待者有很大的机会失去锁。在这种情况下，它将排在等待队列的前面。如果等待者未能在1毫秒内获取到互斥锁，则将互斥锁切换到饥饿模式。 在饥饿模式下，互斥锁的所有权直接从解锁 Goroutine 移交给队列前面的等待者。新到达的 Goroutine 即使看起来未被锁定，也不会尝试获取互斥锁，也不会尝试自旋。相反，它们会将自己排队在等待队列的末尾。如果等待者获得互斥锁的所有权并发现（1）它是队列中的最后一个等待者，或者（2）它等待时间少于1毫秒，则将互斥锁切换回正常模式。 正常模式的性能要优于饥饿模式，因为 Goroutine 可以连续多次获取互斥锁，即使有被阻塞的等待者。饥饿模式很重要，可以防止尾部延迟的病态情况。</p></blockquote> <p>简单总结：</p> <ul><li><code>Mutex</code> 有两种模式：正常模式、饥饿模式。</li> <li>正常模式下：
<ul><li>被唤醒的 goroutine 和正在运行的 goroutine 竞争锁。这样可以运行中的协程有机会先获取到锁，从而避免了协程切换的开销。性能更好。</li></ul></li> <li>饥饿模式下：
<ul><li>优先让队列中的 goroutine 获得锁，并且直接放弃时间片，让给队列中的 goroutine，运行中的 goroutine 想获取锁要到队尾排队。更加公平。</li></ul></li></ul> <h2 id="mutex-源码剖析"><a href="#mutex-源码剖析" class="header-anchor">#</a> Mutex 源码剖析</h2> <p><code>Mutex</code> 本身的源码其实很少，但是复杂程度是非常高的，所以第一次看的时候可能会非常懵逼，但是不妨碍我们去了解它的大概实现原理。</p> <p><code>Mutex</code> 中主要有两个方法，<code>Lock</code> 和 <code>Unlock</code>，使用起来非常的简单，但是它的实现可不简单。下面我们就来深入了解一下它的实现。</p> <h3 id="lock"><a href="#lock" class="header-anchor">#</a> Lock</h3> <p><code>Lock</code> 方法的实现如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Lock 获取锁。</span>
<span class="token comment">// 如果锁已在使用中，则调用 goroutine 将阻塞，直到互斥量可用。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// Fast path: grab unlocked mutex.</span>
   <span class="token comment">// 上锁成功则直接返回</span>
   <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mutexLocked<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// Slow path (outlined so that the fast path can be inlined)</span>
   <span class="token comment">// 没有上锁成功，这个时候需要做的事情就有点多了。</span>
   m<span class="token punctuation">.</span><span class="token function">lockSlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在 <code>Lock</code> 方法中，第一次获取锁的时候是非常简单的，一个简单的原子操作设置一下 <code>mutexLocked</code> 标识就完成了。 但是如果这个原子操作失败了，表示有其他 goroutine 先获取到了锁，这个时候就需要调用 <code>lockSlow</code> 来做一些额外的操作了：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 获取 mutex 锁</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">lockSlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> waitStartTime <span class="token builtin">int64</span> <span class="token comment">// 当前协程开始等待的时间</span>
   starving <span class="token operator">:=</span> <span class="token boolean">false</span>       <span class="token comment">// 当前协程是否是饥饿模式</span>
   awoke <span class="token operator">:=</span> <span class="token boolean">false</span>          <span class="token comment">// 唤醒标志（是否当前协程就是被唤醒的协程）</span>
   iter <span class="token operator">:=</span> <span class="token number">0</span>               <span class="token comment">// 自旋次数（超过一定次数如果还没能获得锁，就进入等待）</span>
   old <span class="token operator">:=</span> m<span class="token punctuation">.</span>state          <span class="token comment">// 旧的状态，每次 for 循环会重新获取当前的状态字段</span>

   <span class="token keyword">for</span> <span class="token punctuation">{</span>
      <span class="token comment">// 自旋：目的是让正在运行中的 goroutine 尽快获取到锁。</span>
      <span class="token comment">// 两种情况不会自旋：</span>
      <span class="token comment">// 1. 饥饿模式：在饥饿模式下，锁会直接交给等待队列中的 goroutine，所以不会自旋。</span>
      <span class="token comment">// 2. 锁被释放了：另外如果运行到这里的时候，发现锁已经被释放了，也就不需要自旋了。</span>
      <span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">==</span> mutexLocked <span class="token operator">&amp;&amp;</span> <span class="token function">runtime_canSpin</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 设置 mutexWoken 标识</span>
         <span class="token comment">// 如果自旋是有意义的，则会进入到这里，尝试设置 mutexWoken 标识。</span>
         <span class="token comment">// 设置成功在持有锁的 goroutine 获取锁的时候不会唤醒等待队列中的 goroutine，下一个获取锁的就是当前 goroutine。</span>
         <span class="token keyword">if</span> <span class="token operator">!</span>awoke <span class="token operator">&amp;&amp;</span> old<span class="token operator">&amp;</span>mutexWoken <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
            atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> old<span class="token operator">|</span>mutexWoken<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 各个判断的含义：</span>
            <span class="token comment">// !awoke 已经被唤醒过一次了，说明当前协程是被从等待队列中唤醒的协程/又或者已经成功设置 mutexWoken 标识了，不需要再唤醒了。</span>
            <span class="token comment">// old&amp;mutexWoken == 0 如果不等于 0 说明有 goroutine 被唤醒了，不会尝试设置 mutexWoken 标识</span>
            <span class="token comment">// old&gt;&gt;mutexWaiterShift != 0 如果等待队列为空，当前 goroutine 就是下一个抢占锁的 goroutine</span>
            <span class="token comment">// 前面的判断都通过了，才会进行 CAS 操作尝试设置 mutexWoken 标识</span>
            awoke <span class="token operator">=</span> <span class="token boolean">true</span>
         <span class="token punctuation">}</span>
         <span class="token function">runtime_doSpin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 自旋</span>
         iter<span class="token operator">++</span>           <span class="token comment">// 自旋次数 +1（超过一定次数会停止自旋）</span>
         old <span class="token operator">=</span> m<span class="token punctuation">.</span>state    <span class="token comment">// 再次获取锁的最新状态，之后会检查是否锁被释放了</span>
         <span class="token keyword">continue</span>         <span class="token comment">// 继续下一次检查</span>
      <span class="token punctuation">}</span>

      <span class="token builtin">new</span> <span class="token operator">:=</span> old
      <span class="token comment">// 饥饿模式下，新到达的 goroutines 必须排队。</span>
      <span class="token comment">// 不是饥饿状态，直接竞争锁。</span>
      <span class="token keyword">if</span> old<span class="token operator">&amp;</span>mutexStarving <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
         <span class="token builtin">new</span> <span class="token operator">|=</span> mutexLocked
      <span class="token punctuation">}</span>
      <span class="token comment">// 进入等待队列的两种情况：</span>
      <span class="token comment">// 1. 锁依然被占用。</span>
      <span class="token comment">// 2. 进入了饥饿模式。</span>
      <span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
         <span class="token builtin">new</span> <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> mutexWaiterShift <span class="token comment">// 等待者数量 +1</span>
      <span class="token punctuation">}</span>
       <span class="token comment">// 已经等待超过了 1ms，且锁被其他协程占用，则进入饥饿模式</span>
      <span class="token keyword">if</span> starving <span class="token operator">&amp;&amp;</span> old<span class="token operator">&amp;</span>mutexLocked <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
         <span class="token builtin">new</span> <span class="token operator">|=</span> mutexStarving
      <span class="token punctuation">}</span>
      <span class="token comment">// 唤醒之后，需要重置唤醒标志。</span>
      <span class="token comment">// 不管有没有获取到锁，都是要清除这个标识的：</span>
      <span class="token comment">// 获取到锁肯定要清除，如果获取到锁，需要让其他运行中的 goroutine 来抢占锁；</span>
      <span class="token comment">// 如果没有获取到锁，goroutine 会阻塞，这个时候是需要持有锁的 goroutine 来唤醒的，如果有 mutexWoken 标识，持有锁的 goroutine 唤醒不了。</span>
      <span class="token keyword">if</span> awoke <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token builtin">new</span><span class="token operator">&amp;</span>mutexWoken <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;sync: inconsistent mutex state&quot;</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token builtin">new</span> <span class="token operator">&amp;^=</span> mutexWoken <span class="token comment">// 重置唤醒标志</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 成功设置新状态</span>
      <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span>
         <span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 这意味着当前的 goroutine 成功获取了锁</span>
            <span class="token keyword">break</span>
         <span class="token punctuation">}</span>

         <span class="token comment">// 如果已经被唤醒过，会被加入到等待队列头。</span>
         queueLifo <span class="token operator">:=</span> waitStartTime <span class="token operator">!=</span> <span class="token number">0</span>
         <span class="token keyword">if</span> waitStartTime <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            waitStartTime <span class="token operator">=</span> <span class="token function">runtime_nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 阻塞等待</span>
         <span class="token comment">// queueLifo 为 true，表示加入到队列头。否则，加入到队列尾。</span>
         <span class="token comment">// (首次加入队列加入到队尾，不是首次加入则加入队头，这样等待最久的 goroutine 优先能够获取到锁。)</span>
         <span class="token function">runtime_SemacquireMutex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">,</span> queueLifo<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token comment">// 从等待队列中唤醒，检查锁是否应该进入饥饿模式。</span>
         starving <span class="token operator">=</span> starving <span class="token operator">||</span> <span class="token function">runtime_nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>waitStartTime <span class="token operator">&gt;</span> starvationThresholdNs

         <span class="token comment">// 获取当前的锁最新状态</span>
         old <span class="token operator">=</span> m<span class="token punctuation">.</span>state
         <span class="token comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回。</span>
         <span class="token comment">// 饥饿模式下，被唤醒的协程可以直接获取到锁。</span>
         <span class="token comment">// 新来的 goroutine 都需要进入队列等待。</span>
         <span class="token keyword">if</span> old<span class="token operator">&amp;</span>mutexStarving <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果这个 goroutine 被唤醒并且 Mutex 处于饥饿模式，P 的所有权已经移交给我们，</span>
            <span class="token comment">// 但 Mutex 处于不一致的状态：mutexLocked 未设置，我们仍然被视为等待者。修复这个问题。</span>
            <span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexWoken<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
               <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;sync: inconsistent mutex state&quot;</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 加锁，并且减少等待者数量。</span>
            <span class="token comment">// 实际上是两步操作合成了一步：</span>
            <span class="token comment">// 1. m.state = m.state + 1 （获取锁）</span>
            <span class="token comment">// 2. m.state = m.state - 1&lt;&lt;mutexWaiterShift（waiter - 1）</span>
            delta <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>mutexLocked <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>mutexWaiterShift<span class="token punctuation">)</span>
            <span class="token comment">// 清除饥饿状态的两种情况：</span>
            <span class="token comment">// 1. 如果不需要进入饥饿模式（当前被唤醒的 goroutine 的等待时间小于 1ms）</span>
            <span class="token comment">// 2. 原来的等待者数量为 1，说明是最后一个被唤醒的 goroutine。</span>
            <span class="token keyword">if</span> <span class="token operator">!</span>starving <span class="token operator">||</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
               <span class="token comment">// 退出饥饿模式</span>
               delta <span class="token operator">-=</span> mutexStarving
            <span class="token punctuation">}</span>
            <span class="token comment">// 原子操作，设置新状态。</span>
            atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> delta<span class="token punctuation">)</span>
            <span class="token keyword">break</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 设置唤醒标记，重新抢占锁（会与那些运行中的 goroutine 一起竞争锁）</span>
         awoke <span class="token operator">=</span> <span class="token boolean">true</span>
         iter <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// CAS 更新状态失败，获取最新状态，然后重试</span>
         old <span class="token operator">=</span> m<span class="token punctuation">.</span>state
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br></div></div><p>我们可以看到，<code>lockSlow</code> 的处理非常的复杂，又要考虑让运行中的 goroutine 尽快获取到锁，又要考虑不能让等待队列中的 goroutine 等待太久。</p> <p>代码中注释很多，再简单总结一下其中的流程：</p> <ol><li>为了让循环中的 goroutine 可以先获取到锁，会先让 goroutine 自旋等待锁的释放，这是因为运行中的 goroutine 正在占用 CPU，让它先获取到锁可以避免一些不必要的协程切换，从而获得更好的性能。</li> <li>自旋完毕之后，会尝试获取锁，同时也要根据旧的锁状态来更新锁的不同状态信息，比如是否进入饥饿模式等。</li> <li>计算得到一个新的 <code>state</code> 后，会进行 <code>CAS</code> 操作尝试更新 <code>state</code> 状态。</li> <li><code>CAS</code> 失败会重试上面的流程。</li> <li><code>CAS</code> 成功之后会做如下操作：</li></ol> <ul><li>判断当前是否已经获取到锁，如果是，则返回，<code>Lock</code> 成功了。</li> <li>会判断当前的 goroutine 是否是已经被唤醒过，如果是，会将当前 goroutine 加入到等待队列头部。</li> <li>调用 <code>runtime_SemacquireMutex</code>，进入阻塞状态，等待下一次唤醒。</li> <li>唤醒之后，判断是否需要进入饥饿模式。</li> <li>最后，如果已经是饥饿模式，当前 goroutine 直接获取到锁，退出循环，否则，再进行下一次抢占锁的循环中。</li></ul> <p>具体流程我们可以参考一下下面的流程图：</p> <p><img src="/images/go/mutex/4.webp" alt="mutex_4.png"></p> <blockquote><p>图中有一些矩形方框描述了 <code>unlockSlow</code> 的关键流程。</p></blockquote> <h3 id="unlock"><a href="#unlock" class="header-anchor">#</a> Unlock</h3> <p><code>Unlock</code> 方法的实现如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Unlock 释放互斥锁。</span>
<span class="token comment">// 如果 m 在进入 Unlock 时未被锁定，则会出现运行时错误。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// Fast path: drop lock bit.</span>
   <span class="token comment">// unlock 成功</span>
   <span class="token comment">// unLock 操作实际上是将 state 减去 1。</span>
   <span class="token builtin">new</span> <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token operator">-</span>mutexLocked<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token builtin">new</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span> <span class="token comment">// 等待队列为空的时候直接返回了</span>
      <span class="token comment">// 唤醒一个等待锁的 goroutine</span>
      m<span class="token punctuation">.</span><span class="token function">unlockSlow</span><span class="token punctuation">(</span><span class="token builtin">new</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>Unlock</code> 做了两件事：</p> <ol><li>释放当前 goroutine 持有的互斥锁：也就是将 <code>state</code> 减去 1</li> <li>唤醒等待队列中的下一个 goroutine</li></ol> <p>如果只有一个 goroutine 在使用锁，只需要简单地释放锁就可以了。 但是如果有其他的 goroutine 在阻塞等待，那么持有互斥锁的 goroutine 就有义务去唤醒下一个 goroutine。</p> <p>唤醒的流程相对复杂一些：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// unlockSlow 唤醒下一个等待锁的协程。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">unlockSlow</span><span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果未加锁，则会抛出错误。</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">new</span><span class="token operator">+</span>mutexLocked<span class="token punctuation">)</span><span class="token operator">&amp;</span>mutexLocked <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token function">fatal</span><span class="token punctuation">(</span><span class="token string">&quot;sync: unlock of unlocked mutex&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 下面的操作是唤醒一个在等待锁的协程。</span>
   <span class="token comment">// 存在两种情况：</span>
   <span class="token comment">// 1. 正常模式：</span>
   <span class="token comment">//  a. 不需要唤醒：没有等待者、锁已经被抢占、有其他运行中的协程在尝试获取锁、已经进入了饥饿模式</span>
   <span class="token comment">//   b. 需要唤醒：其他情况</span>
   <span class="token comment">// 2. 饥饿模式：唤醒等待队列头部的那个协程</span>
   <span class="token keyword">if</span> <span class="token builtin">new</span><span class="token operator">&amp;</span>mutexStarving <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
      <span class="token comment">// 不是饥饿模式</span>
      old <span class="token operator">:=</span> <span class="token builtin">new</span>
      <span class="token comment">// 自旋</span>
      <span class="token keyword">for</span> <span class="token punctuation">{</span>
         <span class="token comment">// 下面几种情况不需要唤醒：</span>
         <span class="token comment">// 1. 没有等待者了（没得唤醒）</span>
         <span class="token comment">// 2. 锁已经被占用（只能有一个 goroutine 持有锁）</span>
         <span class="token comment">// 3. 有其他运行中的协程已经被唤醒（运行中的 goroutine 通过自旋先抢占到了锁）</span>
         <span class="token comment">// 4. 饥饿模式（饥饿模式下，所有新的 goroutine 都要排队，饥饿模式会直接唤醒等待队列头部的 gorutine）</span>
         <span class="token keyword">if</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexWoken<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 获取到唤醒等待者的权力，开始唤醒一个等待者。</span>
         <span class="token comment">// 下面这一行实际上是两个操作：</span>
         <span class="token comment">// 1. waiter 数量 - 1</span>
         <span class="token comment">// 2. 设置 mutexWoken 标志</span>
         <span class="token builtin">new</span> <span class="token operator">=</span> <span class="token punctuation">(</span>old <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>mutexWaiterShift<span class="token punctuation">)</span> <span class="token operator">|</span> mutexWoken
         <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 正常模式下唤醒了一个 goroutine</span>
            <span class="token comment">//（第二个参数为 false，表示当前的 goroutine 在释放信号量后还会继续执行直到用完时间片）</span>
            <span class="token function">runtime_Semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 唤醒失败，进行下一次尝试。</span>
         old <span class="token operator">=</span> m<span class="token punctuation">.</span>state
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 饥饿模式：将互斥锁的所有权移交给下一个等待者，并放弃我们的时间片，以便下一个等待者可以立即开始运行。</span>
      <span class="token comment">// 注意：如果“mutexLocked”未设置，等待者在唤醒后会将其设置。</span>
      <span class="token comment">// 但是，如果设置了“mutexStarving”，则仍然认为互斥锁已被锁定，因此新到来的goroutine不会获取它。</span>
      <span class="token comment">//</span>
      <span class="token comment">// 当前的 goroutine 放弃 CPU 时间片，让给阻塞在 sema 的 goroutine。</span>
      <span class="token function">runtime_Semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><p><code>unlockSlow</code> 逻辑相比 <code>lockSlow</code> 要简单许多，我们可以再结合下面的流程图来阅读上面的源码：</p> <p><img src="/images/go/mutex/5.webp" alt="mutex_5.png"></p> <h4 id="runtime-semrelease-第二个参数的含义"><a href="#runtime-semrelease-第二个参数的含义" class="header-anchor">#</a> runtime_Semrelease 第二个参数的含义</h4> <p>细心的朋友可能注意到了，在 <code>unlockSlow</code> 的实现中，有两处地方调用了 <code>runtime_Semrelease</code> 这个方法， 这个方法的作用是释放一个信号量，这样可以让阻塞在信号量上的 goroutine 得以继续执行。 它的第一个参数我们都知道，是信号量，而第二个参数 <code>true</code> 和 <code>false</code> 分别传递了一次， 那么 <code>true</code> 和 <code>false</code> 分别有什么作用呢？</p> <p>答案是，设置为 <code>true</code> 的时候，当前的 goroutine 会直接放弃自己的时间片， 将 P 的使用权交给 <code>Mutex</code> 等待队列中的第一个 goroutine， 这样的目的是，让 <code>Mutex</code> 等待队列中的 goroutine 可以尽快地获取到锁。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>互斥锁在并发编程中也算是非常常见的一种操作了，使用互斥锁可以限制只有一个 goroutine 可以进入临界区， 这对于并发修改全局变量、初始化等情况非常好用。最后，再总结一下本文所讲述的内容：</p> <ul><li><p>互斥锁是一种用于多线程编程中，防止两个线程同时对同一公共资源进行读写的机制。go 中的互斥锁实现是 <code>sync.Mutex</code>。</p></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>Mutex
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>的操作只有两个：</p> <ul><li><code>Lock</code> 获取锁，同一时刻只能有一个 goroutine 可以获取到锁，其他 goroutine 会先通过自旋抢占锁，抢不到则阻塞等待。</li> <li><code>Unlock</code> 释放锁，释放锁之前必须有 goroutine 持有锁。释放锁之后，会唤醒等待队列中的下一个 goroutine。</li></ul></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>Mutex
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>常见的使用场景有两个：</p> <ul><li>并发读写 <code>map</code>：如 <code>gin</code> 中 <code>Context</code> 的 <code>Keys</code> 属性的读写。</li> <li>并发读写全局变量：如 <code>sync.Pool</code> 中对 <code>allPools</code> 的读写。</li></ul></li> <li><p>使用</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Mutex
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>需要注意以下几点：</p> <ul><li>不要忘记使用 <code>Unlock</code> 释放锁</li> <li><code>Lock</code> 之后，没有释放锁之前，不能再次使用 <code>Lock</code></li> <li>注意不同 goroutine 竞争不同锁的情况，需要考虑一下是否有可能会死锁</li> <li>在 <code>Unlock</code> 之前，必须已经调用了 <code>Lock</code>，否则会 <code>panic</code></li> <li>在第一次使用 <code>Mutex</code> 之后，不能复制，因为这样一来 <code>Mutex</code> 的状态也会被复制。这个可以使用 <code>go vet</code> 来检查。</li></ul></li> <li><p>互斥锁可以保护一块代码块只能有一个 goroutine 执行，但是不保证临界区内操作的变量不被其他 goroutine 做并发读写操作。</p></li> <li><p>go 的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Mutex
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>基于以下技术实现：</p> <ul><li>信号量：这是操作系统层面的同步机制</li> <li>队列：在 goroutine 获取不到锁的时候，会将这些 goroutine 放入一个 FIFO 队列中，下次唤醒会唤醒队列头的 goroutine</li> <li>原子操作：<code>state</code> 字段记录了四种不同的信息，通过原子操作就可以保证数据的完整性</li></ul></li> <li><p>go</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Mutex
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>的公平性：</p> <ul><li>正在运行的 goroutine 如果需要锁的话，尽量让它先获取到锁，可以避免不必要的协程上下文切换。会和被唤醒的 goroutine 一起竞争锁。</li> <li>但是如果等待队列中的 goroutine 超过了 1ms 还没有获取到锁，那么会进入饥饿模式</li></ul></li> <li><p>go</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Mutex
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>的两种模式：</p> <ul><li>正常模式：运行中的 goroutine 有一定机会比等待队列中的 goroutine 先获取到锁，这种模式有更好的性能。</li> <li>饥饿模式：所有后来的 goroutine 都直接进入等待队列，会依次从等待队列头唤醒 goroutine。可以有效避免尾延迟。</li></ul></li> <li><p>饥饿模式下，<code>Unlock</code> 的时候会直接将当前 goroutine 所在 P 的使用权交给等待队列头部的 goroutine，放弃原本属于自己的时间片。</p></li></ul></div></div> <div class="page-slot page-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script></br><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="auto"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="7043271566"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Golang" title="标签">#Golang</a><a href="/tags/?tag=mutex" title="标签">#mutex</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/17/2023</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/golang/go-chan-design-and-implementation/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">go chan 设计与实现</div></a> <a href="/pages/golang/go-sync-map-1/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">深入理解 go sync.Map - 基本原理</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/golang/go-chan-design-and-implementation/" class="prev">go chan 设计与实现</a></span> <span class="next"><a href="/pages/golang/go-sync-map-1/">深入理解 go sync.Map - 基本原理</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/mosquito-config-ws/"><div>
            mosquito配置ws协议
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/pip-download-offline/"><div>
            Pip包的离线下载和安装
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/favorites/sd/"><div>
            stable diffusion 相关收藏
            <!----></div></a> <span class="date">02-24</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/moxiaolong" title="Star我" target="_blank" class="iconfont icon-github"></a><a href="http://music.163.com/playlist?id=8444337" title="有品位的歌单" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2024
    <span>Dra-M</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bc3c2a75.js" defer></script><script src="/assets/js/2.472001a0.js" defer></script><script src="/assets/js/38.05c111ca.js" defer></script>
  </body>
</html>
