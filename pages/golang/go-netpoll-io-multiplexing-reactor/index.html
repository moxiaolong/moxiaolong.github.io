<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Go netpoller 原生网络模型之源码全面揭秘 | Dra-M</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/logo.webp">
    <link rel="manifest" href="/manifest.json">
    <script data-ad-client="ca-pub-8621788234752924" defer="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924" crossorigin="anonymous"></script>
    <meta name="description" content="一些技术(前端、后端、运维)相关的经验、随想、资源收藏，和一些哲学随想。">
    <meta name="keywords" content="开发技术,哲学,DragonMo,Dra-M,莫小龙">
    <meta name="theme-color" content="#7b074b">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <link rel="preload" href="/assets/css/0.styles.8ee39092.css" as="style"><link rel="preload" href="/assets/js/app.bc3c2a75.js" as="script"><link rel="preload" href="/assets/js/2.472001a0.js" as="script"><link rel="preload" href="/assets/js/30.a93d8117.js" as="script"><link rel="prefetch" href="/assets/js/10.da818c35.js"><link rel="prefetch" href="/assets/js/100.c9dc513a.js"><link rel="prefetch" href="/assets/js/101.f3685f69.js"><link rel="prefetch" href="/assets/js/102.98577fde.js"><link rel="prefetch" href="/assets/js/103.401885da.js"><link rel="prefetch" href="/assets/js/104.5ca2a2ba.js"><link rel="prefetch" href="/assets/js/105.896bd937.js"><link rel="prefetch" href="/assets/js/106.199efe2c.js"><link rel="prefetch" href="/assets/js/107.206ba497.js"><link rel="prefetch" href="/assets/js/108.c1eb4655.js"><link rel="prefetch" href="/assets/js/109.221866e5.js"><link rel="prefetch" href="/assets/js/11.a6aff4f5.js"><link rel="prefetch" href="/assets/js/110.e3239981.js"><link rel="prefetch" href="/assets/js/111.ef06b5a1.js"><link rel="prefetch" href="/assets/js/112.ccf225d6.js"><link rel="prefetch" href="/assets/js/113.8d8640b2.js"><link rel="prefetch" href="/assets/js/114.056f749a.js"><link rel="prefetch" href="/assets/js/115.ed35567d.js"><link rel="prefetch" href="/assets/js/116.29426a1f.js"><link rel="prefetch" href="/assets/js/117.86847b2b.js"><link rel="prefetch" href="/assets/js/118.885246c5.js"><link rel="prefetch" href="/assets/js/119.6b04ff26.js"><link rel="prefetch" href="/assets/js/12.dd3a474e.js"><link rel="prefetch" href="/assets/js/120.99542ea6.js"><link rel="prefetch" href="/assets/js/121.c89b2199.js"><link rel="prefetch" href="/assets/js/122.b4c96f13.js"><link rel="prefetch" href="/assets/js/123.e74abe64.js"><link rel="prefetch" href="/assets/js/124.5479e5ef.js"><link rel="prefetch" href="/assets/js/125.47f5d91e.js"><link rel="prefetch" href="/assets/js/126.2eda5054.js"><link rel="prefetch" href="/assets/js/127.fbf8b987.js"><link rel="prefetch" href="/assets/js/128.3bb898fe.js"><link rel="prefetch" href="/assets/js/129.59014c61.js"><link rel="prefetch" href="/assets/js/13.2d318d3d.js"><link rel="prefetch" href="/assets/js/130.b5701dcd.js"><link rel="prefetch" href="/assets/js/131.af42802d.js"><link rel="prefetch" href="/assets/js/132.a0a52815.js"><link rel="prefetch" href="/assets/js/133.c7f6fcd9.js"><link rel="prefetch" href="/assets/js/134.1fa00d40.js"><link rel="prefetch" href="/assets/js/135.1c93b5ec.js"><link rel="prefetch" href="/assets/js/136.ce22005d.js"><link rel="prefetch" href="/assets/js/137.d689e32c.js"><link rel="prefetch" href="/assets/js/138.52557618.js"><link rel="prefetch" href="/assets/js/139.5576ce4a.js"><link rel="prefetch" href="/assets/js/14.41100292.js"><link rel="prefetch" href="/assets/js/140.3becc2ed.js"><link rel="prefetch" href="/assets/js/141.60103e1a.js"><link rel="prefetch" href="/assets/js/142.f44d458d.js"><link rel="prefetch" href="/assets/js/143.5a60f54e.js"><link rel="prefetch" href="/assets/js/144.ce362fab.js"><link rel="prefetch" href="/assets/js/145.f4d3209c.js"><link rel="prefetch" href="/assets/js/146.f90aee50.js"><link rel="prefetch" href="/assets/js/15.daabeb64.js"><link rel="prefetch" href="/assets/js/16.a4a3b21c.js"><link rel="prefetch" href="/assets/js/17.8b6cce9b.js"><link rel="prefetch" href="/assets/js/18.60b289d4.js"><link rel="prefetch" href="/assets/js/19.0c18504f.js"><link rel="prefetch" href="/assets/js/20.7a975e23.js"><link rel="prefetch" href="/assets/js/21.3329c224.js"><link rel="prefetch" href="/assets/js/22.5df3725f.js"><link rel="prefetch" href="/assets/js/23.1e2b6c8a.js"><link rel="prefetch" href="/assets/js/24.aac0154b.js"><link rel="prefetch" href="/assets/js/25.b26ee63b.js"><link rel="prefetch" href="/assets/js/26.6b63d3fb.js"><link rel="prefetch" href="/assets/js/27.8b487354.js"><link rel="prefetch" href="/assets/js/28.731619d6.js"><link rel="prefetch" href="/assets/js/29.4fe59357.js"><link rel="prefetch" href="/assets/js/3.6dd7c6e7.js"><link rel="prefetch" href="/assets/js/31.42cc0c6c.js"><link rel="prefetch" href="/assets/js/32.67d8d455.js"><link rel="prefetch" href="/assets/js/33.da390ef3.js"><link rel="prefetch" href="/assets/js/34.47f5bc34.js"><link rel="prefetch" href="/assets/js/35.bb95ae18.js"><link rel="prefetch" href="/assets/js/36.79ce5ff9.js"><link rel="prefetch" href="/assets/js/37.e48e5b35.js"><link rel="prefetch" href="/assets/js/38.05c111ca.js"><link rel="prefetch" href="/assets/js/39.a9c4a557.js"><link rel="prefetch" href="/assets/js/4.76079b7d.js"><link rel="prefetch" href="/assets/js/40.45a45204.js"><link rel="prefetch" href="/assets/js/41.978ccffc.js"><link rel="prefetch" href="/assets/js/42.895064c8.js"><link rel="prefetch" href="/assets/js/43.c9b2330d.js"><link rel="prefetch" href="/assets/js/44.114f4169.js"><link rel="prefetch" href="/assets/js/45.5a1432cf.js"><link rel="prefetch" href="/assets/js/46.cce4db9a.js"><link rel="prefetch" href="/assets/js/47.b9ba2714.js"><link rel="prefetch" href="/assets/js/48.2e84c7f6.js"><link rel="prefetch" href="/assets/js/49.77f31886.js"><link rel="prefetch" href="/assets/js/5.13679220.js"><link rel="prefetch" href="/assets/js/50.70b8a00f.js"><link rel="prefetch" href="/assets/js/51.8f3d4e26.js"><link rel="prefetch" href="/assets/js/52.a0dff1b5.js"><link rel="prefetch" href="/assets/js/53.1a5d0aa9.js"><link rel="prefetch" href="/assets/js/54.d9b622f7.js"><link rel="prefetch" href="/assets/js/55.a078dc68.js"><link rel="prefetch" href="/assets/js/56.5a331510.js"><link rel="prefetch" href="/assets/js/57.5bec8258.js"><link rel="prefetch" href="/assets/js/58.21fe4b06.js"><link rel="prefetch" href="/assets/js/59.53211a94.js"><link rel="prefetch" href="/assets/js/6.738f6e32.js"><link rel="prefetch" href="/assets/js/60.1d1893dd.js"><link rel="prefetch" href="/assets/js/61.2dd0ba1c.js"><link rel="prefetch" href="/assets/js/62.4df81247.js"><link rel="prefetch" href="/assets/js/63.e7645407.js"><link rel="prefetch" href="/assets/js/64.c1510d68.js"><link rel="prefetch" href="/assets/js/65.e80f3f86.js"><link rel="prefetch" href="/assets/js/66.705d839b.js"><link rel="prefetch" href="/assets/js/67.852e9ce9.js"><link rel="prefetch" href="/assets/js/68.67fbda7f.js"><link rel="prefetch" href="/assets/js/69.7a78efb2.js"><link rel="prefetch" href="/assets/js/7.48b86259.js"><link rel="prefetch" href="/assets/js/70.9fc82048.js"><link rel="prefetch" href="/assets/js/71.ab52b5cf.js"><link rel="prefetch" href="/assets/js/72.e7c7a340.js"><link rel="prefetch" href="/assets/js/73.539e40a1.js"><link rel="prefetch" href="/assets/js/74.598221c8.js"><link rel="prefetch" href="/assets/js/75.876e901b.js"><link rel="prefetch" href="/assets/js/76.42349440.js"><link rel="prefetch" href="/assets/js/77.5834f7c5.js"><link rel="prefetch" href="/assets/js/78.78c797f4.js"><link rel="prefetch" href="/assets/js/79.5d0d35ae.js"><link rel="prefetch" href="/assets/js/8.10c02f71.js"><link rel="prefetch" href="/assets/js/80.e7bc8390.js"><link rel="prefetch" href="/assets/js/81.e4e4f6a8.js"><link rel="prefetch" href="/assets/js/82.98057949.js"><link rel="prefetch" href="/assets/js/83.ad7dd690.js"><link rel="prefetch" href="/assets/js/84.0f7a664d.js"><link rel="prefetch" href="/assets/js/85.378369eb.js"><link rel="prefetch" href="/assets/js/86.01ead6d0.js"><link rel="prefetch" href="/assets/js/87.70598ba5.js"><link rel="prefetch" href="/assets/js/88.600910d8.js"><link rel="prefetch" href="/assets/js/89.c783c1e2.js"><link rel="prefetch" href="/assets/js/9.4b59881c.js"><link rel="prefetch" href="/assets/js/90.85995a12.js"><link rel="prefetch" href="/assets/js/91.21e9dbf9.js"><link rel="prefetch" href="/assets/js/92.8fc80426.js"><link rel="prefetch" href="/assets/js/93.6d7adcc8.js"><link rel="prefetch" href="/assets/js/94.6147d1d9.js"><link rel="prefetch" href="/assets/js/95.61c3d1ab.js"><link rel="prefetch" href="/assets/js/96.1dc4b4c8.js"><link rel="prefetch" href="/assets/js/97.c4c52395.js"><link rel="prefetch" href="/assets/js/98.b78d3e0f.js"><link rel="prefetch" href="/assets/js/99.f1c7ba9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ee39092.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.webp" alt="Dra-M" class="logo"> <span class="site-name can-hide">Dra-M</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=975425198&amp;s=640"> <div class="blogger-info"><h3>莫小龙</h3> <span>保持理智，相信未来。</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Golang</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/golang-gitlab-ssh/" class="sidebar-link">GitLab私服+Go Modules踩坑经验（SSH自定义端口）</a></li><li><a href="/pages/gin/middle/" class="sidebar-link">【代码片段】我使用的Gin中间处理器（自定义异常处理、日志打印、traceId、跨域配置）</a></li><li><a href="/pages/java-to-golang/value-and-reference/" class="sidebar-link">【Java转Go】如何理解Go中的值类型、引用类型、nil</a></li><li><a href="/pages/java-to-golang/oop/" class="sidebar-link">【Java转Go】如何理解面向对象，怎么把Golang用成面向对象的样子</a></li><li><a href="/pages/golang/gmp/" class="sidebar-link">Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="/pages/golang/go-gmp-status/" class="sidebar-link">Go中GMP有哪些状态？</a></li><li><a href="/pages/golang/go-gc/" class="sidebar-link">一文搞懂go gc垃圾回收原理</a></li><li><a href="/pages/golang/go-block/" class="sidebar-link">Go什么时候发生阻塞？阻塞时，调度器会怎么做？</a></li><li><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/" aria-current="page" class="active sidebar-link">Go netpoller 原生网络模型之源码全面揭秘</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#用户空间与内核空间" class="sidebar-link">用户空间与内核空间</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#i-o-模型" class="sidebar-link">I/O 模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#non-blocking-i-o" class="sidebar-link">Non-blocking I/O</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#i-o-多路复用" class="sidebar-link">I/O 多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#select-poll" class="sidebar-link">select &amp; poll</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#epoll" class="sidebar-link">epoll</a></li><li class="sidebar-sub-header level4"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#延伸" class="sidebar-link">延伸</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#go-netpoller-核心" class="sidebar-link">Go netpoller 核心</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#数据结构" class="sidebar-link">数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#netfd" class="sidebar-link">netFD</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#polldesc" class="sidebar-link">pollDesc</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#实现原理" class="sidebar-link">实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#net-listen" class="sidebar-link">net.Listen</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#listener-accept" class="sidebar-link">Listener.Accept()</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#conn-read-conn-write" class="sidebar-link">Conn.Read/Conn.Write</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#polldesc-waitread-polldesc-waitwrite" class="sidebar-link">pollDesc.waitRead/pollDesc.waitWrite</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#netpoll" class="sidebar-link">netpoll</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#go-netpoller-的价值" class="sidebar-link">Go netpoller 的价值</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#goroutine-的调度" class="sidebar-link">Goroutine 的调度</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#go-netpoller-的问题" class="sidebar-link">Go netpoller 的问题</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#reactor-网络模型" class="sidebar-link">Reactor 网络模型</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/#gnet" class="sidebar-link">gnet</a></li></ul></li><li><a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="sidebar-link">Goroutine 泄露 - 被遗忘的发送者</a></li><li><a href="/pages/golang/go-map/" class="sidebar-link">go map 设计与实现</a></li><li><a href="/pages/golang/go-slice/" class="sidebar-link">go slice 设计与实现</a></li><li><a href="/pages/golang/go-context/" class="sidebar-link">小白也能看懂的context包详解：从入门到精通</a></li><li><a href="/pages/golang/go-interface/" class="sidebar-link">go interface 设计与实现</a></li><li><a href="/pages/golang/go-chan/" class="sidebar-link">深入理解 go chan</a></li><li><a href="/pages/golang/go-chan-design-and-implementation/" class="sidebar-link">go chan 设计与实现</a></li><li><a href="/pages/golang/go-mutex/" class="sidebar-link">深入理解 go Mutex</a></li><li><a href="/pages/golang/go-sync-map-1/" class="sidebar-link">深入理解 go sync.Map - 基本原理</a></li><li><a href="/pages/golang/go-sync-map-2/" class="sidebar-link">go sync.Map 设计与实现</a></li><li><a href="/pages/golang/go-sync-once/" class="sidebar-link">深入理解 go sync.Once</a></li><li><a href="/pages/golang/go-reflect-1/" class="sidebar-link">深入理解 go reflect - 反射基本原理</a></li><li><a href="/pages/golang/go-reflect-2/" class="sidebar-link">深入理解 go reflect - 要不要传指针</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程思想</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运维</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script><ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="8498052873"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/code/#技术" data-v-06225672>技术</a></li><li data-v-06225672><a href="/code/#Golang" data-v-06225672>Golang</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://strikefreedom.top/archives/go-netpoll-io-multiplexing-reactor" target="_blank" title="作者" class="beLink" data-v-06225672>潘少</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-06</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="/img/dragon/2.webp">Go netpoller 原生网络模型之源码全面揭秘<!----></h1>  <div class="theme-vdoing-content content__default"><p>Go 基于 I/O multiplexing 和 goroutine scheduler 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 <code>netpoller</code> )，提供了 <code>goroutine-per-connection</code> 这样简单的网络编程模式。在这种模式下，开发者使用的是同步的模式去编写异步的逻辑，极大地降低了开发者编写网络应用时的心智负担，且借助于 Go runtime scheduler 对 goroutines 的高效调度，这个原生网络模型不论从适用性还是性能上都足以满足绝大部分的应用场景。</p> <p>然而，在工程性上能做到如此高的普适性和兼容性，最终暴露给开发者提供接口/模式如此简洁，其底层必然是基于非常复杂的封装，做了很多取舍，也有可能放弃了一些追求极致性能的设计和理念。事实上 <code>Go netpoller</code> 底层就是基于 epoll/kqueue/iocp 这些 I/O 多路复用技术来做封装的，最终暴露出 <code>goroutine-per-connection</code> 这样的极简的开发模式给使用者。</p> <p>Go netpoller 在不同的操作系统，其底层使用的 I/O 多路复用技术也不一样，可以从 Go 源码目录结构和对应代码文件了解 Go 在不同平台下的网络 I/O 模式的实现。比如，在 Linux 系统下基于 epoll，freeBSD 系统下基于 kqueue，以及 Windows 系统下基于 iocp。</p> <p>本文将基于 Linux 平台来解析 Go netpoller 之 I/O 多路复用的底层是如何基于 epoll 封装实现的，从源码层层推进，全面而深度地解析 Go netpoller 的设计理念和实现原理，以及 Go 是如何利用 <code>netpoller</code> 来构建它的原生网络模型的。主要涉及到的一些概念：I/O 模型、用户/内核空间、epoll、Linux 源码、goroutine scheduler 等等，我会尽量简单地讲解，如果有对相关概念不熟悉的同学，还是希望能提前熟悉一下。
</p> <h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="header-anchor">#</a> 用户空间与内核空间</h2> <p>现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p> <p><img src="/images/go/netpoll/slide_13.jpg" alt="img"></p> <p>现代的网络服务的主流已经完成从 CPU 密集型到 IO 密集型的转变，所以服务端程序对 I/O 的处理必不可少，而一旦操作 I/O 则必定要在用户态和内核态之间来回切换。</p> <h2 id="i-o-模型"><a href="#i-o-模型" class="header-anchor">#</a> I/O 模型</h2> <p>在神作《UNIX 网络编程》里，总结归纳了 5 种 I/O 模型，包括同步和异步 I/O：</p> <ul><li>阻塞 I/O (Blocking I/O)</li> <li>非阻塞 I/O (Nonblocking I/O)</li> <li>I/O 多路复用 (I/O multiplexing)</li> <li>信号驱动 I/O (Signal driven I/O)</li> <li>异步 I/O (Asynchronous I/O)</li></ul> <p>操作系统上的 I/O 是用户空间和内核空间的数据交互，因此 I/O 操作通常包含以下两个步骤：</p> <ol><li>等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&gt; 读取/写入到内核缓冲区</li> <li>从内核缓冲区复制数据 –&gt; 用户空间(读)/从用户空间复制数据 -&gt; 内核缓冲区(写)</li></ol> <p>而判定一个 I/O 模型是同步还是异步，主要看第二步：数据在用户和内核空间之间复制的时候是不是会阻塞当前进程，如果会，则是同步 I/O，否则，就是异步 I/O。基于这个原则，这 5 种 I/O 模型中只有一种异步 I/O 模型：Asynchronous I/O，其余都是同步 I/O 模型。</p> <p>这 5 种 I/O 模型的对比如下：</p> <p><img src="/images/go/netpoll/5-io-model.jpg" alt="img"></p> <h3 id="non-blocking-i-o"><a href="#non-blocking-i-o" class="header-anchor">#</a> Non-blocking I/O</h3> <p>什么叫非阻塞 I/O，顾名思义就是：所有 I/O 操作都是立刻返回而不会阻塞当前用户进程。I/O 多路复用通常情况下需要和非阻塞 I/O 搭配使用，否则可能会产生意想不到的问题。比如，epoll 的 ET(边缘触发) 模式下，如果不使用非阻塞 I/O，有极大的概率会导致阻塞 event-loop 线程，从而降低吞吐量，甚至导致 bug。</p> <p>Linux 下，我们可以通过 <code>fcntl</code> 系统调用来设置 <code>O_NONBLOCK</code> 标志位，从而把 socket 设置成 Non-blocking。当对一个 Non-blocking socket 执行读操作时，流程是这个样子： <img src="/images/go/netpoll/non-blocking-io.png" alt="img"></p> <p>当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 EAGAIN error。从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p> <p><strong>所以，Non-blocking I/O 的特点是用户进程需要不断的主动询问 kernel 数据好了没有。下一节我们要讲的 I/O 多路复用需要和 Non-blocking I/O 配合才能发挥出最大的威力！</strong></p> <h2 id="i-o-多路复用"><a href="#i-o-多路复用" class="header-anchor">#</a> I/O 多路复用</h2> <p><strong>所谓 I/O 多路复用指的就是 select/poll/epoll 这一系列的多路选择器：支持单一线程同时监听多个文件描述符（I/O 事件），阻塞等待，并在其中某个文件描述符可读写时收到通知。 I/O 复用其实复用的不是 I/O 连接，而是复用线程，让一个 thread of control 能够处理多个连接（I/O 事件）。</strong></p> <h3 id="select-poll"><a href="#select-poll" class="header-anchor">#</a> select &amp; poll</h3> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span>
 
<span class="token comment">/* According to earlier standards */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
 
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 和 select 紧密结合的四个宏：</span>
<span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>select 是 epoll 之前 Linux 使用的 I/O 事件驱动技术。</p> <p>理解 select 的关键在于理解 fd_set，为说明方便，取 fd_set 长度为 1 字节，fd_set 中的每一 bit 可以对应一个文件描述符 fd，则 1 字节长的 fd_set 最大可以对应 8 个 fd。select 的调用过程如下：</p> <ol><li>执行 FD_ZERO(&amp;set), 则 set 用位表示是 <code>0000,0000</code></li> <li>若 fd＝5, 执行 FD_SET(fd, &amp;set); 后 set 变为 0001,0000(第 5 位置为 1)</li> <li>再加入 fd＝2, fd=1，则 set 变为 <code>0001,0011</code></li> <li>执行 select(6, &amp;set, 0, 0, 0) 阻塞等待</li> <li>若 fd=1, fd=2 上都发生可读事件，则 select 返回，此时 set 变为 <code>0000,0011</code> (注意：没有事件发生的 fd=5 被清空)</li></ol> <p>基于上面的调用过程，可以得出 select 的特点：</p> <ul><li>可监控的文件描述符个数取决于 sizeof(fd_set) 的值。假设服务器上 sizeof(fd_set)＝512，每 bit 表示一个文件描述符，则服务器上支持的最大文件描述符是 512*8=4096。fd_set 的大小调整可参考 <a href="http://www.cppblog.com/CppExplore/archive/2008/03/21/45061.html" target="_blank" rel="noopener noreferrer">【原创】技术系列之 网络模型（二）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中的模型 2，可以有效突破 select 可监控的文件描述符上限</li> <li>将 fd 加入 select 监控集的同时，还要再使用一个数据结构 array 保存放到 select 监控集中的 fd，一是用于在 select 返回后，array 作为源数据和 fd_set 进行 FD_ISSET 判断。二是 select 返回后会把以前加入的但并无事件发生的 fd 清空，则每次开始 select 前都要重新从 array 取得 fd 逐一加入（FD_ZERO 最先），扫描 array 的同时取得 fd 最大值 maxfd，用于 select 的第一个参数</li> <li>可见 select 模型必须在 select 前循环 array（加 fd，取 maxfd），select 返回后循环 array（FD_ISSET 判断是否有事件发生）</li></ul> <p>所以，select 有如下的缺点：</p> <ol><li>最大并发数限制：使用 32 个整数的 32 位，即 32*32=1024 来标识 fd，虽然可修改，但是有以下第 2, 3 点的瓶颈</li> <li>每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大</li> <li>性能衰减严重：每次 kernel 都需要线性扫描整个 fd_set，所以随着监控的描述符 fd 数量增长，其 I/O 性能会线性下降</li></ol> <p>poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，poll 使用 pollfd 结构而不是 select 的 fd_set 结构，poll 解决了最大文件描述符数量限制的问题，但是同样需要从用户态拷贝所有的 fd 到内核态，也需要线性遍历所有的 fd 集合，所以它和 select 只是实现细节上的区分，并没有本质上的区别。</p> <h3 id="epoll"><a href="#epoll" class="header-anchor">#</a> epoll</h3> <p>epoll 是 Linux kernel 2.6 之后引入的新 I/O 事件驱动技术，I/O 多路复用的核心设计是 1 个线程处理所有连接的 <code>等待消息准备好</code> I/O 事件，这一点上 epoll 和 select&amp;poll 是大同小异的。但 select&amp;poll 错误预估了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。select&amp;poll 的使用方法是这样的： <code>返回的活跃连接 == select(全部待监控的连接)</code> 。</p> <p>什么时候会调用 select&amp;poll 呢？在你认为需要找出有报文到达的活跃连接时，就应该调用。所以，select&amp;poll 在高并发时是会被频繁调用的。这样，这个频繁调用的方法就很有必要看看它是否有效率，因为，它的轻微效率损失都会被 <code>高频</code> 二字所放大。它有效率损失吗？显而易见，全部待监控连接是数以十万计的，返回的只是数百个活跃连接，这本身就是无效率的表现。被放大后就会发现，处理并发上万个连接时，select&amp;poll 就完全力不从心了。这个时候就该 epoll 上场了，epoll 通过一些新的设计和优化，基本上解决了 select&amp;poll 的问题。</p> <p>epoll 的 API 非常简洁，涉及到的只有 3 个系统调用：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span>  </span>
<span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// int epoll_create1(int flags);</span>
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其中，epoll_create 创建一个 epoll 实例并返回 epollfd；epoll_ctl 注册 file descriptor 等待的 I/O 事件(比如 EPOLLIN、EPOLLOUT 等) 到 epoll 实例上；epoll_wait 则是阻塞监听 epoll 实例上所有的 file descriptor 的 I/O 事件，它接收一个用户空间上的一块内存地址 (events 数组)，kernel 会在有 I/O 事件发生的时候把文件描述符列表复制到这块内存地址上，然后 epoll_wait 解除阻塞并返回，最后用户空间上的程序就可以对相应的 fd 进行读写了：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>epoll 的工作原理如下：</p> <p><img src="/images/go/netpoll/epoll-principle.png" alt="img"></p> <p>与 select&amp;poll 相比，epoll 分清了高频调用和低频调用。例如，epoll_ctl 相对来说就是非频繁调用的，而 epoll_wait 则是会被高频调用的。所以 epoll 利用 epoll_ctl 来插入或者删除一个 fd，实现用户态到内核态的数据拷贝，这确保了每一个 fd 在其生命周期只需要被拷贝一次，而不是每次调用 epoll_wait 的时候都拷贝一次。 epoll_wait 则被设计成几乎没有入参的调用，相比 select&amp;poll 需要把全部监听的 fd 集合从用户态拷贝至内核态的做法，epoll 的效率就高出了一大截。</p> <p>在实现上 epoll 采用红黑树来存储所有监听的 fd，而红黑树本身插入和删除性能比较稳定，时间复杂度 O(logN)。通过 epoll_ctl 函数添加进来的 fd 都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把 fd 添加进来的时候时候会完成关键的一步：该 fd 会与相应的设备（网卡）驱动程序建立回调关系，也就是在内核中断处理程序为它注册一个回调函数，在 fd 相应的事件触发（中断）之后（设备就绪了），内核就会调用这个回调函数，该回调函数在内核中被称为： <code>ep_poll_callback</code> ，<strong>这个回调函数其实就是把这个 fd 添加到 rdllist 这个双向链表（就绪链表）中</strong>。epoll_wait 实际上就是去检查 rdllist 双向链表中是否有就绪的 fd，当 rdllist 为空（无就绪 fd）时挂起当前进程，直到 rdllist 非空时进程才被唤醒并返回。</p> <p>相比于 select&amp;poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态，epoll_wait 则是直接返回已就绪 fd，因此 epoll 的 I/O 性能不会像 select&amp;poll 那样随着监听的 fd 数量增加而出现线性衰减，是一个非常高效的 I/O 事件驱动技术。</p> <p><strong>由于使用 epoll 的 I/O 多路复用需要用户进程自己负责 I/O 读写，从用户进程的角度看，读写过程是阻塞的，所以 select&amp;poll&amp;epoll 本质上都是同步 I/O 模型，而像 Windows 的 IOCP 这一类的异步 I/O，只需要在调用 WSARecv 或 WSASend 方法读写数据的时候把用户空间的内存 buffer 提交给 kernel，kernel 负责数据在用户空间和内核空间拷贝，完成之后就会通知用户进程，整个过程不需要用户进程参与，所以是真正的异步 I/O。</strong></p> <h4 id="延伸"><a href="#延伸" class="header-anchor">#</a> 延伸</h4> <p>另外，我看到有些文章说 epoll 之所以性能高是因为利用了 Linux 的 mmap 内存映射让内核和用户进程共享了一片物理内存，用来存放就绪 fd 列表和它们的数据 buffer，所以用户进程在 <code>epoll_wait</code> 返回之后用户进程就可以直接从共享内存那里读取/写入数据了，这让我很疑惑，因为首先看 <code>epoll_wait</code> 的函数声明：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>第二个参数：就绪事件列表，是需要在用户空间分配内存然后再传给 <code>epoll_wait</code> 的，如果内核会用 mmap 设置共享内存，直接传递一个指针进去就行了，根本不需要在用户态分配内存，多此一举。其次，内核和用户进程通过 mmap 共享内存是一件极度危险的事情，内核无法确定这块共享内存什么时候会被回收，而且这样也会赋予用户进程直接操作内核数据的权限和入口，非常容易出现大的系统漏洞，因此一般极少会这么做。所以我很怀疑 epoll 是不是真的在 Linux kernel 里用了 mmap，我就去看了下最新版本（5.3.9）的 Linux kernel 源码：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*
 * Implement the event wait interface for the eventpoll file. It is the kernel
 * part of the user space epoll_wait(2).
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>events<span class="token punctuation">,</span>
			 <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
	<span class="token comment">/* Time to fish for events ... */</span>
	error <span class="token operator">=</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 如果 epoll_wait 入参时设定 timeout == 0, 那么直接通过 ep_events_available 判断当前是否有用户感兴趣的事件发生，如果有则通过 ep_send_events 进行处理</span>
<span class="token comment">// 如果设置 timeout &gt; 0，并且当前没有用户关注的事件发生，则进行休眠，并添加到 ep-&gt;wq 等待队列的头部；对等待事件描述符设置 WQ_FLAG_EXCLUSIVE 标志</span>
<span class="token comment">// ep_poll 被事件唤醒后会重新检查是否有关注事件，如果对应的事件已经被抢走，那么 ep_poll 会继续休眠等待</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
	send_events<span class="token operator">:</span>
	<span class="token comment">/*
	 * Try to transfer events to user space. In case we get 0 events and
	 * there's still timeout left over, we go trying again in search of
	 * more luck.
	 */</span>
  
	<span class="token comment">// 如果一切正常, 有 event 发生, 就开始准备数据 copy 给用户空间了</span>
	<span class="token comment">// 如果有就绪的事件发生，那么就调用 ep_send_events 将就绪的事件 copy 到用户态内存中，</span>
	<span class="token comment">// 然后返回到用户态，否则判断是否超时，如果没有超时就继续等待就绪事件发生，如果超时就返回用户态。</span>
	<span class="token comment">// 从 ep_poll 函数的实现可以看到，如果有就绪事件发生，则调用 ep_send_events 函数做进一步处理</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res <span class="token operator">&amp;&amp;</span> eavail <span class="token operator">&amp;&amp;</span>
			<span class="token operator">!</span><span class="token punctuation">(</span>res <span class="token operator">=</span> <span class="token function">ep_send_events</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timed_out<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> fetch_events<span class="token punctuation">;</span>
  
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// ep_send_events 函数是用来向用户空间拷贝就绪 fd 列表的，它将用户传入的就绪 fd 列表内存简单封装到</span>
<span class="token comment">// ep_send_events_data 结构中，然后调用 ep_scan_ready_list 将就绪队列中的事件写入用户空间的内存；</span>
<span class="token comment">// 用户进程就可以访问到这些数据进行处理</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_send_events</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span>
				<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">ep_send_events_data</span> esed<span class="token punctuation">;</span>
 
	esed<span class="token punctuation">.</span>maxevents <span class="token operator">=</span> maxevents<span class="token punctuation">;</span>
	esed<span class="token punctuation">.</span>events <span class="token operator">=</span> events<span class="token punctuation">;</span>
	<span class="token comment">// 调用 ep_scan_ready_list 函数检查 epoll 实例 eventpoll 中的 rdllist 就绪链表，</span>
	<span class="token comment">// 并注册一个回调函数 ep_send_events_proc，如果有就绪 fd，则调用 ep_send_events_proc 进行处理</span>
	<span class="token function">ep_scan_ready_list</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> ep_send_events_proc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>esed<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> esed<span class="token punctuation">.</span>res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 调用 ep_scan_ready_list 的时候会传递指向 ep_send_events_proc 函数的函数指针作为回调函数，</span>
<span class="token comment">// 一旦有就绪 fd，就会调用 ep_send_events_proc 函数</span>
<span class="token keyword">static</span> __poll_t <span class="token function">ep_send_events_proc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>priv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
	<span class="token comment">/*
	 * If the event mask intersect the caller-requested one,
	 * deliver the event to userspace. Again, ep_scan_ready_list()
	 * is holding ep-&gt;mtx, so no operations coming from userspace
	 * can change the item.
	 */</span>
	revents <span class="token operator">=</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span>epi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 如果 revents 为 0，说明没有就绪的事件，跳过，否则就将就绪事件拷贝到用户态内存中</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>revents<span class="token punctuation">)</span>
		<span class="token keyword">continue</span><span class="token punctuation">;</span>
	<span class="token comment">// 将当前就绪的事件和用户进程传入的数据都通过 __put_user 拷贝回用户空间,</span>
	<span class="token comment">// 也就是调用 epoll_wait 之时用户进程传入的 fd 列表的内存</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__put_user</span><span class="token punctuation">(</span>revents<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uevent<span class="token operator">-&gt;</span>events<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">__put_user</span><span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uevent<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">ep_pm_stay_awake</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>esed<span class="token operator">-&gt;</span>res<span class="token punctuation">)</span>
			esed<span class="token operator">-&gt;</span>res <span class="token operator">=</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
  
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br></div></div><p>从 <code>do_epoll_wait</code> 开始层层跳转，我们可以很清楚地看到最后内核是通过 <code>__put_user</code> 函数把就绪 fd 列表和事件返回到用户空间，而 <code>__put_user</code> 正是内核用来拷贝数据到用户空间的标准函数。此外，我并没有在 Linux kernel 的源码中和 epoll 相关的代码里找到 mmap 系统调用做内存映射的逻辑，所以基本可以得出结论：epoll 在 Linux kernel 里并没有使用 mmap 来做用户空间和内核空间的内存共享，所以那些说 epoll 使用了 mmap 的文章都是误解。</p> <h2 id="go-netpoller-核心"><a href="#go-netpoller-核心" class="header-anchor">#</a> Go netpoller 核心</h2> <p><strong>Go netpoller 基本原理</strong></p> <blockquote><p>Go netpoller 通过在底层对 epoll/kqueue/iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。总结来说，所有的网络操作都以网络描述符 netFD 为中心实现。netFD 与底层 PollDesc 结构绑定，当在一个 netFD 上读写遇到 EAGAIN 错误时，就将当前 goroutine 存储到这个 netFD 对应的 PollDesc 中，同时调用 gopark 把当前 goroutine 给 park 住，直到这个 netFD 上再次发生读写事件，才将此 goroutine 给 ready 激活重新运行。显然，在底层通知 goroutine 再次发生读写等事件的方式就是 epoll/kqueue/iocp 等事件驱动机制。</p></blockquote> <p>众所周知，Go 是一门跨平台的编程语言，而不同平台针对特定的功能有不用的实现，这当然也包括了 I/O 多路复用技术，比如 Linux 里的 I/O 多路复用有 <code>select</code>、<code>poll</code> 和 <code>epoll</code>，而 freeBSD 或者 MacOS 里则是 <code>kqueue</code>，而 Windows 里则是基于异步 I/O 实现的 <code>iocp</code>，等等；因此，Go 为了实现底层 I/O 多路复用的跨平台，分别基于上述的这些不同平台的系统调用实现了多版本的 netpollers，具体的源码路径如下：</p> <ul><li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_epoll.go" target="_blank" rel="noopener noreferrer"><code>src/runtime/netpoll_epoll.go</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_kqueue.go" target="_blank" rel="noopener noreferrer"><code>src/runtime/netpoll_kqueue.go</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_solaris.go" target="_blank" rel="noopener noreferrer"><code>src/runtime/netpoll_solaris.go</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_windows.go" target="_blank" rel="noopener noreferrer"><code>src/runtime/netpoll_windows.go</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_aix.go" target="_blank" rel="noopener noreferrer"><code>src/runtime/netpoll_aix.go</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_fake.go" target="_blank" rel="noopener noreferrer"><code>src/runtime/netpoll_fake.go</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>本文的解析基于 <code>epoll</code> 版本，如果读者对其他平台的 netpoller 底层实现感兴趣，可以在阅读完本文后自行翻阅其他 netpoller 源码，所有实现版本的机制和原理基本类似，所以了解了 <code>epoll</code> 版本的实现后再去学习其他版本实现应该没什么障碍。</p> <p>接下来让我们通过分析最新的 Go 源码（v1.15.3），全面剖析一下整个 Go netpoller 的运行机制和流程。</p> <h2 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h2> <h3 id="netfd"><a href="#netfd" class="header-anchor">#</a> netFD</h3> <p><code>net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)</code> 方法返回了一个 *TCPListener，它是一个实现了 <code>net.Listener</code> 接口的 struct，而通过 <code>listener.Accept()</code> 接收的新连接 *TCPConn 则是一个实现了 <code>net.Conn</code> 接口的 struct，它内嵌了 <code>net.conn</code> struct。仔细阅读上面的源码可以发现，不管是 Listener 的 Accept 还是 Conn 的 Read/Write 方法，都是基于一个 <code>netFD</code> 的数据结构的操作， <code>netFD</code> 是一个网络描述符，类似于 Linux 的文件描述符的概念，netFD 中包含一个 poll.FD 数据结构，而 poll.FD 中包含两个重要的数据结构 Sysfd 和 pollDesc，前者是真正的系统文件描述符，后者对是底层事件驱动的封装，所有的读写超时等操作都是通过调用后者的对应方法实现的。</p> <p><code>netFD</code> 和 <code>poll.FD</code> 的源码：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Network file descriptor.</span>
<span class="token keyword">type</span> netFD <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	pfd poll<span class="token punctuation">.</span>FD
 
	<span class="token comment">// immutable until Close</span>
	family      <span class="token builtin">int</span>
	sotype      <span class="token builtin">int</span>
	isConnected <span class="token builtin">bool</span> <span class="token comment">// handshake completed or use of association with peer</span>
	net         <span class="token builtin">string</span>
	laddr       Addr
	raddr       Addr
<span class="token punctuation">}</span>
 
<span class="token comment">// FD is a file descriptor. The net and os packages use this type as a</span>
<span class="token comment">// field of a larger type representing a network connection or OS file.</span>
<span class="token keyword">type</span> FD <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment">// Lock sysfd and serialize access to Read and Write methods.</span>
	fdmu fdMutex
 
	<span class="token comment">// System file descriptor. Immutable until Close.</span>
	Sysfd <span class="token builtin">int</span>
 
	<span class="token comment">// I/O poller.</span>
	pd pollDesc
 
	<span class="token comment">// Writev cache.</span>
	iovecs <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span>syscall<span class="token punctuation">.</span>Iovec
 
	<span class="token comment">// Semaphore signaled when file is closed.</span>
	csema <span class="token builtin">uint32</span>
 
	<span class="token comment">// Non-zero if this file has been set to blocking mode.</span>
	isBlocking <span class="token builtin">uint32</span>
 
	<span class="token comment">// Whether this is a streaming descriptor, as opposed to a</span>
	<span class="token comment">// packet-based descriptor like a UDP socket. Immutable.</span>
	IsStream <span class="token builtin">bool</span>
 
	<span class="token comment">// Whether a zero byte read indicates EOF. This is false for a</span>
	<span class="token comment">// message based socket connection.</span>
	ZeroReadIsEOF <span class="token builtin">bool</span>
 
	<span class="token comment">// Whether this is a file rather than a network socket.</span>
	isFile <span class="token builtin">bool</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h3 id="polldesc"><a href="#polldesc" class="header-anchor">#</a> pollDesc</h3> <p>前面提到了 pollDesc 是底层事件驱动的封装，netFD 通过它来完成各种 I/O 相关的操作，它的定义如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">type</span> pollDesc <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	runtimeCtx <span class="token builtin">uintptr</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的 struct 只包含了一个指针，而通过 pollDesc 的 init 方法，我们可以找到它具体的定义是在 <code>runtime.pollDesc</code> 这里：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>pd <span class="token operator">*</span>pollDesc<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span>fd <span class="token operator">*</span>FD<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	serverInit<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>runtime_pollServerInit<span class="token punctuation">)</span>
	ctx<span class="token punctuation">,</span> errno <span class="token operator">:=</span> <span class="token function">runtime_pollOpen</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> errno <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> ctx <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">runtime_pollUnblock</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
			<span class="token function">runtime_pollClose</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> syscall<span class="token punctuation">.</span><span class="token function">Errno</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	pd<span class="token punctuation">.</span>runtimeCtx <span class="token operator">=</span> ctx
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// Network poller descriptor.</span>
<span class="token comment">//</span>
<span class="token comment">// No heap pointers.</span>
<span class="token comment">//</span>
<span class="token comment">//go:notinheap</span>
<span class="token keyword">type</span> pollDesc <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	link <span class="token operator">*</span>pollDesc <span class="token comment">// in pollcache, protected by pollcache.lock</span>
 
	<span class="token comment">// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.</span>
	<span class="token comment">// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.</span>
	<span class="token comment">// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)</span>
	<span class="token comment">// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated</span>
	<span class="token comment">// in a lock-free way by all operations.</span>
	<span class="token comment">// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),</span>
	<span class="token comment">// that will blow up when GC starts moving objects.</span>
	lock    mutex <span class="token comment">// protects the following fields</span>
	fd      <span class="token builtin">uintptr</span>
	closing <span class="token builtin">bool</span>
	everr   <span class="token builtin">bool</span>    <span class="token comment">// marks event scanning error happened</span>
	user    <span class="token builtin">uint32</span>  <span class="token comment">// user settable cookie</span>
	rseq    <span class="token builtin">uintptr</span> <span class="token comment">// protects from stale read timers</span>
	rg      <span class="token builtin">uintptr</span> <span class="token comment">// pdReady, pdWait, G waiting for read or nil</span>
	rt      timer   <span class="token comment">// read deadline timer (set if rt.f != nil)</span>
	rd      <span class="token builtin">int64</span>   <span class="token comment">// read deadline</span>
	wseq    <span class="token builtin">uintptr</span> <span class="token comment">// protects from stale write timers</span>
	wg      <span class="token builtin">uintptr</span> <span class="token comment">// pdReady, pdWait, G waiting for write or nil</span>
	wt      timer   <span class="token comment">// write deadline timer</span>
	wd      <span class="token builtin">int64</span>   <span class="token comment">// write deadline</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>这里重点关注里面的 <code>rg</code> 和 <code>wg</code>，这里两个 uintptr &quot;万能指针&quot;类型，取值分别可能是 <code>pdReady</code>、<code>pdWait</code>、等待 file descriptor 就绪的 goroutine 也就是 <code>g</code> 数据结构以及 <code>nil</code>，它们是实现唤醒 goroutine 的关键。</p> <p><code>runtime.pollDesc</code> 包含自身类型的一个指针，用来保存下一个 <code>runtime.pollDesc</code> 的地址，以此来实现链表，可以减少数据结构的大小，所有的 <code>runtime.pollDesc</code> 保存在 <code>runtime.pollCache</code> 结构中，定义如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">type</span> pollCache <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   lock  mutex
   first <span class="token operator">*</span>pollDesc
   <span class="token comment">// PollDesc objects must be type-stable,</span>
   <span class="token comment">// because we can get ready notification from epoll/kqueue</span>
   <span class="token comment">// after the descriptor is closed/reused.</span>
   <span class="token comment">// Stale notifications are detected using seq variable,</span>
   <span class="token comment">// seq is incremented when deadlines are changed or descriptor is reused.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>因为 <code>runtime.pollCache</code> 是一个在 runtime 包里的全局变量，因此需要用一个互斥锁来避免 data race 问题，从它的名字也能看出这是一个用于缓存的数据结构，也就是用来提高性能的，具体如何实现呢？</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">const</span> pollBlockSize <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1024</span>
 
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>pollCache<span class="token punctuation">)</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>pollDesc <span class="token punctuation">{</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token keyword">if</span> c<span class="token punctuation">.</span>first <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">const</span> pdSize <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>pollDesc<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
		n <span class="token operator">:=</span> pollBlockSize <span class="token operator">/</span> pdSize
		<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			n <span class="token operator">=</span> <span class="token number">1</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Must be in non-GC memory because can be referenced</span>
		<span class="token comment">// only from epoll/kqueue internals.</span>
		mem <span class="token operator">:=</span> <span class="token function">persistentalloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span>pdSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>other_sys<span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			pd <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pollDesc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> i<span class="token operator">*</span>pdSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
			pd<span class="token punctuation">.</span>link <span class="token operator">=</span> c<span class="token punctuation">.</span>first
			c<span class="token punctuation">.</span>first <span class="token operator">=</span> pd
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	pd <span class="token operator">:=</span> c<span class="token punctuation">.</span>first
	c<span class="token punctuation">.</span>first <span class="token operator">=</span> pd<span class="token punctuation">.</span>link
	<span class="token function">lockInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pd<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> lockRankPollDesc<span class="token punctuation">)</span>
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	<span class="token keyword">return</span> pd
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>Go runtime 会在调用 <code>poll_runtime_pollOpen</code> 往 epoll 实例注册 fd 之时首次调用 <code>runtime.pollCache.alloc</code>方法时批量初始化大小 4KB 的 <code>runtime.pollDesc</code> 结构体的链表，初始化过程中会调用 <code>runtime.persistentalloc</code> 来为这些数据结构分配不会被 GC 回收的内存，确保这些数据结构只能被 <code>epoll</code>和<code>kqueue</code> 在内核空间去引用。</p> <p>再往后每次调用这个方法则会先判断链表头是否已经分配过值了，若是，则直接返回表头这个 <code>pollDesc</code>，这种批量初始化数据进行缓存而后每次都直接从缓存取数据的方式是一种很常见的性能优化手段，在这里这种方式可以有效地提升 netpoller 的吞吐量。</p> <p>Go runtime 会在关闭 <code>pollDesc</code> 之时调用 <code>runtime.pollCache.free</code> 释放内存：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>pollCache<span class="token punctuation">)</span> <span class="token function">free</span><span class="token punctuation">(</span>pd <span class="token operator">*</span>pollDesc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
	pd<span class="token punctuation">.</span>link <span class="token operator">=</span> c<span class="token punctuation">.</span>first
	c<span class="token punctuation">.</span>first <span class="token operator">=</span> pd
	<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="实现原理"><a href="#实现原理" class="header-anchor">#</a> 实现原理</h2> <p>使用 Go 编写一个典型的 TCP echo server:</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">package</span> main
 
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;log&quot;</span>
	<span class="token string">&quot;net&quot;</span>
<span class="token punctuation">)</span>
 
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">&quot;tcp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;:8888&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;listen error: &quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
 
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;accept error: &quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
 
		<span class="token comment">// start a new goroutine to handle the new connection.</span>
		<span class="token keyword">go</span> <span class="token function">HandleConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token function">HandleConn</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	packet <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token comment">// block here if socket is not available for reading data.</span>
		n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;read socket error: &quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
 
		<span class="token comment">// same as above, block here if socket is not available for writing.</span>
		<span class="token boolean">_</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>packet<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>上面是一个基于 Go 原生网络模型（基于 netpoller）编写的一个 TCP server，模式是 <code>goroutine-per-connection</code> ，在这种模式下，开发者使用的是同步的模式去编写异步的逻辑而且对于开发者来说 I/O 是否阻塞是无感知的，也就是说开发者无需考虑 goroutines 甚至更底层的线程、进程的调度和上下文切换。而 Go netpoller 最底层的事件驱动技术肯定是基于 epoll/kqueue/iocp 这一类的 I/O 事件驱动技术，只不过是把这些调度和上下文切换的工作转移到了 runtime 的 Go scheduler，让它来负责调度 goroutines，从而极大地降低了程序员的心智负担！</p> <p>Go 的这种同步模式的网络服务器的基本架构通常如下：</p> <p><img src="/images/go/netpoll/go-network-server.png" alt="img"></p> <p>上面的示例代码中相关的在源码里的几个数据结构和方法：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// TCPListener is a TCP network listener. Clients should typically</span>
<span class="token comment">// use variables of type Listener instead of assuming TCP.</span>
<span class="token keyword">type</span> TCPListener <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	fd <span class="token operator">*</span>netFD
	lc ListenConfig
<span class="token punctuation">}</span>
 
<span class="token comment">// Accept implements the Accept method in the Listener interface; it</span>
<span class="token comment">// waits for the next call and returns a generic Conn.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>TCPListener<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>l<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>EINVAL
	<span class="token punctuation">}</span>
	c<span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>OpError<span class="token punctuation">{</span>Op<span class="token punctuation">:</span> <span class="token string">&quot;accept&quot;</span><span class="token punctuation">,</span> Net<span class="token punctuation">:</span> l<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>net<span class="token punctuation">,</span> Source<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> Addr<span class="token punctuation">:</span> l<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>laddr<span class="token punctuation">,</span> Err<span class="token punctuation">:</span> err<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token punctuation">(</span>ln <span class="token operator">*</span>TCPListener<span class="token punctuation">)</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>TCPConn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> ln<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	tc <span class="token operator">:=</span> <span class="token function">newTCPConn</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>
	<span class="token keyword">if</span> ln<span class="token punctuation">.</span>lc<span class="token punctuation">.</span>KeepAlive <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">setKeepAlive</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		ka <span class="token operator">:=</span> ln<span class="token punctuation">.</span>lc<span class="token punctuation">.</span>KeepAlive
		<span class="token keyword">if</span> ln<span class="token punctuation">.</span>lc<span class="token punctuation">.</span>KeepAlive <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			ka <span class="token operator">=</span> defaultTCPKeepAlive
		<span class="token punctuation">}</span>
		<span class="token function">setKeepAlivePeriod</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> ka<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> tc<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// TCPConn is an implementation of the Conn interface for TCP network</span>
<span class="token comment">// connections.</span>
<span class="token keyword">type</span> TCPConn <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	conn
<span class="token punctuation">}</span>
 
<span class="token comment">// Conn</span>
<span class="token keyword">type</span> conn <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	fd <span class="token operator">*</span>netFD
<span class="token punctuation">}</span>
 
<span class="token keyword">type</span> conn <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	fd <span class="token operator">*</span>netFD
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span>fd <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">}</span>
 
<span class="token comment">// Implementation of the Conn interface.</span>
 
<span class="token comment">// Read implements the Conn Read method.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>EINVAL
	<span class="token punctuation">}</span>
	n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>
		err <span class="token operator">=</span> <span class="token operator">&amp;</span>OpError<span class="token punctuation">{</span>Op<span class="token punctuation">:</span> <span class="token string">&quot;read&quot;</span><span class="token punctuation">,</span> Net<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>net<span class="token punctuation">,</span> Source<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>laddr<span class="token punctuation">,</span> Addr<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>raddr<span class="token punctuation">,</span> Err<span class="token punctuation">:</span> err<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> n<span class="token punctuation">,</span> err
<span class="token punctuation">}</span>
 
<span class="token comment">// Write implements the Conn Write method.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>EINVAL
	<span class="token punctuation">}</span>
	n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> <span class="token operator">&amp;</span>OpError<span class="token punctuation">{</span>Op<span class="token punctuation">:</span> <span class="token string">&quot;write&quot;</span><span class="token punctuation">,</span> Net<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>net<span class="token punctuation">,</span> Source<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>laddr<span class="token punctuation">,</span> Addr<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>raddr<span class="token punctuation">,</span> Err<span class="token punctuation">:</span> err<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> n<span class="token punctuation">,</span> err
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br></div></div><h3 id="net-listen"><a href="#net-listen" class="header-anchor">#</a> net.Listen</h3> <p>调用 <code>net.Listen</code> 之后，底层会通过 Linux 的系统调用 <code>socket</code> 方法创建一个 fd 分配给 listener，并用以来初始化 listener 的 <code>netFD</code> ，接着调用 netFD 的 <code>listenStream</code> 方法完成对 socket 的 bind&amp;listen 操作以及对 <code>netFD</code> 的初始化（主要是对 netFD 里的 pollDesc 的初始化），调用链是 <code>runtime.runtime_pollServerInit</code> --&gt; <code>runtime.poll_runtime_pollServerInit</code> --&gt; <code>runtime.netpollGenericInit</code>，主要做的事情是：</p> <ol><li>调用 <code>epollcreate1</code> 创建一个 epoll 实例 <code>epfd</code>，作为整个 runtime 的唯一 event-loop 使用；</li> <li>调用 <code>runtime.nonblockingPipe</code> 创建一个用于和 epoll 实例通信的管道，这里为什么不用更新且更轻量的 eventfd 呢？我个人猜测是为了兼容更多以及更老的系统版本；</li> <li>将 <code>netpollBreakRd</code> 通知信号量封装成 <code>epollevent</code> 事件结构体注册进 epoll 实例。</li></ol> <p>相关源码如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// 调用 linux 系统调用 socket 创建 listener fd 并设置为为阻塞 I/O</span>
s<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">socketFunc</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> sotype<span class="token operator">|</span>syscall<span class="token punctuation">.</span>SOCK_NONBLOCK<span class="token operator">|</span>syscall<span class="token punctuation">.</span>SOCK_CLOEXEC<span class="token punctuation">,</span> proto<span class="token punctuation">)</span>
<span class="token comment">// On Linux the SOCK_NONBLOCK and SOCK_CLOEXEC flags were</span>
<span class="token comment">// introduced in 2.6.27 kernel and on FreeBSD both flags were</span>
<span class="token comment">// introduced in 10 kernel. If we get an EINVAL error on Linux</span>
<span class="token comment">// or EPROTONOSUPPORT error on FreeBSD, fall back to using</span>
<span class="token comment">// socket without them.</span>
 
socketFunc        <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>  <span class="token operator">=</span> syscall<span class="token punctuation">.</span>Socket
 
<span class="token comment">// 用上面创建的 listener fd 初始化 listener netFD</span>
<span class="token keyword">if</span> fd<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">newFD</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> family<span class="token punctuation">,</span> sotype<span class="token punctuation">,</span> net<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
	poll<span class="token punctuation">.</span><span class="token function">CloseFunc</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
<span class="token punctuation">}</span>
 
<span class="token comment">// 对 listener fd 进行 bind&amp;listen 操作，并且调用 init 方法完成初始化</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>fd <span class="token operator">*</span>netFD<span class="token punctuation">)</span> <span class="token function">listenStream</span><span class="token punctuation">(</span>laddr sockaddr<span class="token punctuation">,</span> backlog <span class="token builtin">int</span><span class="token punctuation">,</span> ctrlFn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>RawConn<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
  
	<span class="token comment">// 完成绑定操作</span>
	<span class="token keyword">if</span> err <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Bind</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>pfd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">,</span> lsa<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> os<span class="token punctuation">.</span><span class="token function">NewSyscallError</span><span class="token punctuation">(</span><span class="token string">&quot;bind&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
  
	<span class="token comment">// 完成监听操作</span>
	<span class="token keyword">if</span> err <span class="token operator">=</span> <span class="token function">listenFunc</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>pfd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> os<span class="token punctuation">.</span><span class="token function">NewSyscallError</span><span class="token punctuation">(</span><span class="token string">&quot;listen&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
  
	<span class="token comment">// 调用 init，内部会调用 poll.FD.Init，最后调用 pollDesc.init</span>
	<span class="token keyword">if</span> err <span class="token operator">=</span> fd<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	lsa<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> syscall<span class="token punctuation">.</span><span class="token function">Getsockname</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>pfd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">)</span>
	fd<span class="token punctuation">.</span><span class="token function">setAddr</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span><span class="token function">addrFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>lsa<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 使用 sync.Once 来确保一个 listener 只持有一个 epoll 实例</span>
<span class="token keyword">var</span> serverInit sync<span class="token punctuation">.</span>Once
 
<span class="token comment">// netFD.init 会调用 poll.FD.Init 并最终调用到 pollDesc.init，</span>
<span class="token comment">// 它会创建 epoll 实例并把 listener fd 加入监听队列</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>pd <span class="token operator">*</span>pollDesc<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span>fd <span class="token operator">*</span>FD<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	<span class="token comment">// runtime_pollServerInit 通过 `go:linkname` 链接到具体的实现函数 poll_runtime_pollServerInit，</span>
	<span class="token comment">// 接着再调用 netpollGenericInit，然后会根据不同的系统平台去调用特定的 netpollinit 来创建 epoll 实例</span>
	serverInit<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>runtime_pollServerInit<span class="token punctuation">)</span>
  
	<span class="token comment">// runtime_pollOpen 内部调用了 netpollopen 来将 listener fd 注册到 </span>
	<span class="token comment">// epoll 实例中，另外，它会初始化一个 pollDesc 并返回</span>
	ctx<span class="token punctuation">,</span> errno <span class="token operator">:=</span> <span class="token function">runtime_pollOpen</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> errno <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> ctx <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">runtime_pollUnblock</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
			<span class="token function">runtime_pollClose</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> syscall<span class="token punctuation">.</span><span class="token function">Errno</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 把真正初始化完成的 pollDesc 实例赋值给当前的 pollDesc 代表自身的指针，</span>
	<span class="token comment">// 后续使用直接通过该指针操作</span>
	pd<span class="token punctuation">.</span>runtimeCtx <span class="token operator">=</span> ctx
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">var</span> <span class="token punctuation">(</span>
	<span class="token comment">// 全局唯一的 epoll fd，只在 listener fd 初始化之时被指定一次</span>
	epfd <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// epoll descriptor</span>
<span class="token punctuation">)</span>
 
<span class="token comment">// netpollinit 会创建一个 epoll 实例，然后把 epoll fd 赋值给 epfd，</span>
<span class="token comment">// 后续 listener 以及它 accept 的所有 sockets 有关 epoll 的操作都是基于这个全局的 epfd</span>
<span class="token keyword">func</span> <span class="token function">netpollinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	epfd <span class="token operator">=</span> <span class="token function">epollcreate1</span><span class="token punctuation">(</span>_EPOLL_CLOEXEC<span class="token punctuation">)</span>
	<span class="token keyword">if</span> epfd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		epfd <span class="token operator">=</span> <span class="token function">epollcreate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> epfd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: epollcreate failed with&quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span>epfd<span class="token punctuation">)</span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: netpollinit failed&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token function">closeonexec</span><span class="token punctuation">(</span>epfd<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	r<span class="token punctuation">,</span> w<span class="token punctuation">,</span> errno <span class="token operator">:=</span> <span class="token function">nonblockingPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> errno <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: pipe failed with&quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span>errno<span class="token punctuation">)</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: pipe failed&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	ev <span class="token operator">:=</span> epollevent<span class="token punctuation">{</span>
		events<span class="token punctuation">:</span> _EPOLLIN<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>netpollBreakRd
	errno <span class="token operator">=</span> <span class="token function">epollctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> _EPOLL_CTL_ADD<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span>
	<span class="token keyword">if</span> errno <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: epollctl failed with&quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span>errno<span class="token punctuation">)</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: epollctl failed&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	netpollBreakRd <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
	netpollBreakWr <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// netpollopen 会被 runtime_pollOpen 调用，注册 fd 到 epoll 实例，</span>
<span class="token comment">// 注意这里使用的是 epoll 的 ET 模式，同时会利用万能指针把 pollDesc 保存到 epollevent 的一个 8 位的字节数组 data 里</span>
<span class="token keyword">func</span> <span class="token function">netpollopen</span><span class="token punctuation">(</span>fd <span class="token builtin">uintptr</span><span class="token punctuation">,</span> pd <span class="token operator">*</span>pollDesc<span class="token punctuation">)</span> <span class="token builtin">int32</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> ev epollevent
	ev<span class="token punctuation">.</span>events <span class="token operator">=</span> _EPOLLIN <span class="token operator">|</span> _EPOLLOUT <span class="token operator">|</span> _EPOLLRDHUP <span class="token operator">|</span> _EPOLLET
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>pollDesc<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> pd
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token function">epollctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> _EPOLL_CTL_ADD<span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br></div></div><p>我们前面提到的 epoll 的三个基本调用，Go 在源码里实现了对那三个调用的封装：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span>  </span>
<span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// Go 对上面三个调用的封装</span>
func <span class="token function">netpollinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
func <span class="token function">netpollopen</span><span class="token punctuation">(</span>fd uintptr<span class="token punctuation">,</span> pd <span class="token operator">*</span>pollDesc<span class="token punctuation">)</span> int32
func <span class="token function">netpoll</span><span class="token punctuation">(</span>block bool<span class="token punctuation">)</span> gList
 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>netFD 就是通过这三个封装来对 epoll 进行创建实例、注册 fd 和等待事件操作的。</p> <h3 id="listener-accept"><a href="#listener-accept" class="header-anchor">#</a> Listener.Accept()</h3> <p><code>netpoll</code> accept socket 的工作流程如下：</p> <ol><li>服务端的 netFD 在 <code>listen</code> 时会创建 epoll 的实例，并将 listenerFD 加入 epoll 的事件队列</li> <li>netFD 在 <code>accept</code> 时将返回的 connFD 也加入 epoll 的事件队列</li> <li>netFD 在读写时出现 <code>syscall.EAGAIN</code> 错误，通过 pollDesc 的 <code>waitRead</code> 方法将当前的 goroutine park 住，直到 ready，从 pollDesc 的 <code>waitRead</code> 中返回</li></ol> <p><code>Listener.Accept()</code> 接收来自客户端的新连接，具体还是调用 <code>netFD.accept</code> 方法来完成这个功能：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Accept implements the Accept method in the Listener interface; it</span>
<span class="token comment">// waits for the next call and returns a generic Conn.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>TCPListener<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>l<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>EINVAL
	<span class="token punctuation">}</span>
	c<span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>OpError<span class="token punctuation">{</span>Op<span class="token punctuation">:</span> <span class="token string">&quot;accept&quot;</span><span class="token punctuation">,</span> Net<span class="token punctuation">:</span> l<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>net<span class="token punctuation">,</span> Source<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> Addr<span class="token punctuation">:</span> l<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>laddr<span class="token punctuation">,</span> Err<span class="token punctuation">:</span> err<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token punctuation">(</span>ln <span class="token operator">*</span>TCPListener<span class="token punctuation">)</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>TCPConn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fd<span class="token punctuation">,</span> err <span class="token operator">:=</span> ln<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	tc <span class="token operator">:=</span> <span class="token function">newTCPConn</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>
	<span class="token keyword">if</span> ln<span class="token punctuation">.</span>lc<span class="token punctuation">.</span>KeepAlive <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">setKeepAlive</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		ka <span class="token operator">:=</span> ln<span class="token punctuation">.</span>lc<span class="token punctuation">.</span>KeepAlive
		<span class="token keyword">if</span> ln<span class="token punctuation">.</span>lc<span class="token punctuation">.</span>KeepAlive <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			ka <span class="token operator">=</span> defaultTCPKeepAlive
		<span class="token punctuation">}</span>
		<span class="token function">setKeepAlivePeriod</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> ka<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> tc<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token punctuation">(</span>fd <span class="token operator">*</span>netFD<span class="token punctuation">)</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>netfd <span class="token operator">*</span>netFD<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 调用 poll.FD 的 Accept 方法接受新的 socket 连接，返回 socket 的 fd</span>
	d<span class="token punctuation">,</span> rsa<span class="token punctuation">,</span> errcall<span class="token punctuation">,</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span>pfd<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> errcall <span class="token operator">!=</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">{</span>
			err <span class="token operator">=</span> <span class="token function">wrapSyscallError</span><span class="token punctuation">(</span>errcall<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	<span class="token comment">// 以 socket fd 构造一个新的 netFD，代表这个新的 socket</span>
	<span class="token keyword">if</span> netfd<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">newFD</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> fd<span class="token punctuation">.</span>family<span class="token punctuation">,</span> fd<span class="token punctuation">.</span>sotype<span class="token punctuation">,</span> fd<span class="token punctuation">.</span>net<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		poll<span class="token punctuation">.</span><span class="token function">CloseFunc</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	<span class="token comment">// 调用 netFD 的 init 方法完成初始化</span>
	<span class="token keyword">if</span> err <span class="token operator">=</span> netfd<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		fd<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	lsa<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Getsockname</span><span class="token punctuation">(</span>netfd<span class="token punctuation">.</span>pfd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">)</span>
	netfd<span class="token punctuation">.</span><span class="token function">setAddr</span><span class="token punctuation">(</span>netfd<span class="token punctuation">.</span><span class="token function">addrFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>lsa<span class="token punctuation">)</span><span class="token punctuation">,</span> netfd<span class="token punctuation">.</span><span class="token function">addrFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>rsa<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> netfd<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><p><code>netFD.accept</code> 方法里会再调用 <code>poll.FD.Accept</code> ，最后会使用 Linux 的系统调用 <code>accept</code> 来完成新连接的接收，并且会把 accept 的 socket 设置成非阻塞 I/O 模式：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Accept wraps the accept network call.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>fd <span class="token operator">*</span>FD<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>Sockaddr<span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> fd<span class="token punctuation">.</span><span class="token function">readUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">prepareRead</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>isFile<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token comment">// 使用 linux 系统调用 accept 接收新连接，创建对应的 socket</span>
		s<span class="token punctuation">,</span> rsa<span class="token punctuation">,</span> errcall<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">accept</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">)</span>
		<span class="token comment">// 因为 listener fd 在创建的时候已经设置成非阻塞的了，</span>
		<span class="token comment">// 所以 accept 方法会直接返回，不管有没有新连接到来；如果 err == nil 则表示正常建立新连接，直接返回</span>
		<span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> s<span class="token punctuation">,</span> rsa<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> err
		<span class="token punctuation">}</span>
		<span class="token comment">// 如果 err != nil，则判断 err == syscall.EAGAIN，符合条件则进入 pollDesc.waitRead 方法</span>
		<span class="token keyword">switch</span> err <span class="token punctuation">{</span>
		<span class="token keyword">case</span> syscall<span class="token punctuation">.</span>EAGAIN<span class="token punctuation">:</span>
			<span class="token keyword">if</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">pollable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// 如果当前没有发生期待的 I/O 事件，那么 waitRead 会通过 park goroutine 让逻辑 block 在这里</span>
				<span class="token keyword">if</span> err <span class="token operator">=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">waitRead</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>isFile<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
					<span class="token keyword">continue</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token keyword">case</span> syscall<span class="token punctuation">.</span>ECONNABORTED<span class="token punctuation">:</span>
			<span class="token comment">// This means that a socket on the listen</span>
			<span class="token comment">// queue was closed before we Accept()ed it;</span>
			<span class="token comment">// it's a silly error, so try again.</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> errcall<span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 使用 linux 的 accept 系统调用接收新连接并把这个 socket fd 设置成非阻塞 I/O</span>
ns<span class="token punctuation">,</span> sa<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">Accept4Func</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SOCK_NONBLOCK<span class="token operator">|</span>syscall<span class="token punctuation">.</span>SOCK_CLOEXEC<span class="token punctuation">)</span>
<span class="token comment">// On Linux the accept4 system call was introduced in 2.6.28</span>
<span class="token comment">// kernel and on FreeBSD it was introduced in 10 kernel. If we</span>
<span class="token comment">// get an ENOSYS error on both Linux and FreeBSD, or EINVAL</span>
<span class="token comment">// error on Linux, fall back to using accept.</span>
 
<span class="token comment">// Accept4Func is used to hook the accept4 call.</span>
<span class="token keyword">var</span> Accept4Func <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>Sockaddr<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token operator">=</span> syscall<span class="token punctuation">.</span>Accept4
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p><code>pollDesc.waitRead</code> 方法主要负责检测当前这个 pollDesc 的上层 netFD 对应的 fd 是否有『期待的』I/O 事件发生，如果有就直接返回，否则就 park 住当前的 goroutine 并持续等待直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，然后它就会返回到外层的 for 循环，让 goroutine 继续执行逻辑。</p> <p>poll.FD.Accept() 返回之后，会构造一个对应这个新 socket 的 netFD，然后调用 init() 方法完成初始化，这个 init 过程和前面 net.Listen() 是一样的，调用链：netFD.init() --&gt; poll.FD.Init() --&gt; poll.pollDesc.init()，最终又会走到这里：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> serverInit sync<span class="token punctuation">.</span>Once
 
<span class="token keyword">func</span> <span class="token punctuation">(</span>pd <span class="token operator">*</span>pollDesc<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span>fd <span class="token operator">*</span>FD<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	serverInit<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>runtime_pollServerInit<span class="token punctuation">)</span>
	ctx<span class="token punctuation">,</span> errno <span class="token operator">:=</span> <span class="token function">runtime_pollOpen</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> errno <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> ctx <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">runtime_pollUnblock</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
			<span class="token function">runtime_pollClose</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> syscall<span class="token punctuation">.</span><span class="token function">Errno</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	pd<span class="token punctuation">.</span>runtimeCtx <span class="token operator">=</span> ctx
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>然后把这个 socket fd 注册到 listener 的 epoll 实例的事件队列中去，等待 I/O 事件。</p> <h3 id="conn-read-conn-write"><a href="#conn-read-conn-write" class="header-anchor">#</a> Conn.Read/Conn.Write</h3> <p>我们先来看看 <code>Conn.Read</code> 方法是如何实现的，原理其实和 <code>Listener.Accept</code> 是一样的，具体调用链还是首先调用 conn 的 <code>netFD.Read</code> ，然后内部再调用 <code>poll.FD.Read</code> ，最后使用 Linux 的系统调用 read: <code>syscall.Read</code> 完成数据读取：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Implementation of the Conn interface.</span>
 
<span class="token comment">// Read implements the Conn Read method.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>EINVAL
	<span class="token punctuation">}</span>
	n<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>
		err <span class="token operator">=</span> <span class="token operator">&amp;</span>OpError<span class="token punctuation">{</span>Op<span class="token punctuation">:</span> <span class="token string">&quot;read&quot;</span><span class="token punctuation">,</span> Net<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>net<span class="token punctuation">,</span> Source<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>laddr<span class="token punctuation">,</span> Addr<span class="token punctuation">:</span> c<span class="token punctuation">.</span>fd<span class="token punctuation">.</span>raddr<span class="token punctuation">,</span> Err<span class="token punctuation">:</span> err<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> n<span class="token punctuation">,</span> err
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token punctuation">(</span>fd <span class="token operator">*</span>netFD<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	n<span class="token punctuation">,</span> err <span class="token operator">=</span> fd<span class="token punctuation">.</span>pfd<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
	runtime<span class="token punctuation">.</span><span class="token function">KeepAlive</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>
	<span class="token keyword">return</span> n<span class="token punctuation">,</span> <span class="token function">wrapSyscallError</span><span class="token punctuation">(</span><span class="token string">&quot;read&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// Read implements io.Reader.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>fd <span class="token operator">*</span>FD<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> fd<span class="token punctuation">.</span><span class="token function">readUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token comment">// If the caller wanted a zero byte read, return immediately</span>
		<span class="token comment">// without trying (but after acquiring the readLock).</span>
		<span class="token comment">// Otherwise syscall.Read returns 0, nil which looks like</span>
		<span class="token comment">// io.EOF.</span>
		<span class="token comment">// TODO(bradfitz): make it wait for readability? (Issue 15735)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">prepareRead</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>isFile<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> fd<span class="token punctuation">.</span>IsStream <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&gt;</span> maxRW <span class="token punctuation">{</span>
		p <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token punctuation">:</span>maxRW<span class="token punctuation">]</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token comment">// 尝试从该 socket 读取数据，因为 socket 在被 listener accept 的时候设置成</span>
		<span class="token comment">// 了非阻塞 I/O，所以这里同样也是直接返回，不管有没有可读的数据</span>
		n<span class="token punctuation">,</span> err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>Sysfd<span class="token punctuation">,</span> p<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			n <span class="token operator">=</span> <span class="token number">0</span>
			<span class="token comment">// err == syscall.EAGAIN 表示当前没有期待的 I/O 事件发生，也就是 socket 不可读</span>
			<span class="token keyword">if</span> err <span class="token operator">==</span> syscall<span class="token punctuation">.</span>EAGAIN <span class="token operator">&amp;&amp;</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">pollable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// 如果当前没有发生期待的 I/O 事件，那么 waitRead </span>
				<span class="token comment">// 会通过 park goroutine 让逻辑 block 在这里</span>
				<span class="token keyword">if</span> err <span class="token operator">=</span> fd<span class="token punctuation">.</span>pd<span class="token punctuation">.</span><span class="token function">waitRead</span><span class="token punctuation">(</span>fd<span class="token punctuation">.</span>isFile<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
					<span class="token keyword">continue</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
 
			<span class="token comment">// On MacOS we can see EINTR here if the user</span>
			<span class="token comment">// pressed ^Z.  See issue #22838.</span>
			<span class="token keyword">if</span> runtime<span class="token punctuation">.</span>GOOS <span class="token operator">==</span> <span class="token string">&quot;darwin&quot;</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">==</span> syscall<span class="token punctuation">.</span>EINTR <span class="token punctuation">{</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		err <span class="token operator">=</span> fd<span class="token punctuation">.</span><span class="token function">eofError</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span> n<span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br></div></div><p><code>conn.Write</code> 和 <code>conn.Read</code> 的原理是一致的，它也是通过类似 <code>pollDesc.waitRead</code> 的 <code>pollDesc.waitWrite</code> 来 park 住 goroutine 直至期待的 I/O 事件发生才返回恢复执行。</p> <h3 id="polldesc-waitread-polldesc-waitwrite"><a href="#polldesc-waitread-polldesc-waitwrite" class="header-anchor">#</a> pollDesc.waitRead/pollDesc.waitWrite</h3> <p><code>pollDesc.waitRead</code> 内部调用了 <code>poll.runtime_pollWait</code> --&gt; <code>runtime.poll_runtime_pollWait</code> 来达成无 I/O 事件时 park 住 goroutine 的目的：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span>
<span class="token keyword">func</span> <span class="token function">poll_runtime_pollWait</span><span class="token punctuation">(</span>pd <span class="token operator">*</span>pollDesc<span class="token punctuation">,</span> mode <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	err <span class="token operator">:=</span> <span class="token function">netpollcheckerr</span><span class="token punctuation">(</span>pd<span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> pollNoError <span class="token punctuation">{</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	<span class="token comment">// As for now only Solaris, illumos, and AIX use level-triggered IO.</span>
	<span class="token keyword">if</span> GOOS <span class="token operator">==</span> <span class="token string">&quot;solaris&quot;</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">&quot;illumos&quot;</span> <span class="token operator">||</span> GOOS <span class="token operator">==</span> <span class="token string">&quot;aix&quot;</span> <span class="token punctuation">{</span>
		<span class="token function">netpollarm</span><span class="token punctuation">(</span>pd<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 进入 netpollblock 并且判断是否有期待的 I/O 事件发生，</span>
	<span class="token comment">// 这里的 for 循环是为了一直等到 io ready</span>
	<span class="token keyword">for</span> <span class="token operator">!</span><span class="token function">netpollblock</span><span class="token punctuation">(</span>pd<span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		err <span class="token operator">=</span> <span class="token function">netpollcheckerr</span><span class="token punctuation">(</span>pd<span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">}</span>
		<span class="token comment">// Can happen if timeout has fired and unblocked us,</span>
		<span class="token comment">// but before we had a chance to run, timeout has been reset.</span>
		<span class="token comment">// Pretend it has not happened and retry.</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// returns true if IO is ready, or false if timedout or closed</span>
<span class="token comment">// waitio - wait only for completed IO, ignore errors</span>
<span class="token keyword">func</span> <span class="token function">netpollblock</span><span class="token punctuation">(</span>pd <span class="token operator">*</span>pollDesc<span class="token punctuation">,</span> mode <span class="token builtin">int32</span><span class="token punctuation">,</span> waitio <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token comment">// gpp 保存的是 goroutine 的数据结构 g，这里会根据 mode 的值决定是 rg 还是 wg，</span>
  <span class="token comment">// 前面提到过，rg 和 wg 是用来保存等待 I/O 就绪的 gorouine 的，后面调用 gopark 之后，</span>
  <span class="token comment">// 会把当前的 goroutine 的抽象数据结构 g 存入 gpp 这个指针，也就是 rg 或者 wg</span>
	gpp <span class="token operator">:=</span> <span class="token operator">&amp;</span>pd<span class="token punctuation">.</span>rg
	<span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token char">'w'</span> <span class="token punctuation">{</span>
		gpp <span class="token operator">=</span> <span class="token operator">&amp;</span>pd<span class="token punctuation">.</span>wg
	<span class="token punctuation">}</span>
 
	<span class="token comment">// set the gpp semaphore to WAIT</span>
	<span class="token comment">// 这个 for 循环是为了等待 io ready 或者 io wait</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		old <span class="token operator">:=</span> <span class="token operator">*</span>gpp
		<span class="token comment">// gpp == pdReady 表示此时已有期待的 I/O 事件发生，</span>
		<span class="token comment">// 可以直接返回 unblock 当前 goroutine 并执行响应的 I/O 操作</span>
		<span class="token keyword">if</span> old <span class="token operator">==</span> pdReady <span class="token punctuation">{</span>
			<span class="token operator">*</span>gpp <span class="token operator">=</span> <span class="token number">0</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> old <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: double wait&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 如果没有期待的 I/O 事件发生，则通过原子操作把 gpp 的值置为 pdWait 并退出 for 循环</span>
		<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Casuintptr</span><span class="token punctuation">(</span>gpp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pdWait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
 
	<span class="token comment">// need to recheck error states after setting gpp to WAIT</span>
	<span class="token comment">// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl</span>
	<span class="token comment">// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg</span>
  
	<span class="token comment">// waitio 此时是 false，netpollcheckerr 方法会检查当前 pollDesc 对应的 fd 是否是正常的，</span>
	<span class="token comment">// 通常来说  netpollcheckerr(pd, mode) == 0 是成立的，所以这里会执行 gopark </span>
	<span class="token comment">// 把当前 goroutine 给 park 住，直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，</span>
	<span class="token comment">// 然后 unpark 返回，在 gopark 内部会把当前 goroutine 的抽象数据结构 g 存入</span>
	<span class="token comment">// gpp(pollDesc.rg/pollDesc.wg) 指针里，以便在后面的 netpoll 函数取出 pollDesc 之后，</span>
	<span class="token comment">// 把 g 添加到链表里返回，接着重新调度 goroutine</span>
	<span class="token keyword">if</span> waitio <span class="token operator">||</span> <span class="token function">netpollcheckerr</span><span class="token punctuation">(</span>pd<span class="token punctuation">,</span> mode<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token comment">// 注册 netpollblockcommit 回调给 gopark，在 gopark 内部会执行它，保存当前 goroutine 到 gpp</span>
		<span class="token function">gopark</span><span class="token punctuation">(</span>netpollblockcommit<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>gpp<span class="token punctuation">)</span><span class="token punctuation">,</span> waitReasonIOWait<span class="token punctuation">,</span> traceEvGoBlockNet<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// be careful to not lose concurrent READY notification</span>
	old <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xchguintptr</span><span class="token punctuation">(</span>gpp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> old <span class="token operator">&gt;</span> pdWait <span class="token punctuation">{</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: corrupted polldesc&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> old <span class="token operator">==</span> pdReady
<span class="token punctuation">}</span>
 
<span class="token comment">// gopark 会停住当前的 goroutine 并且调用传递进来的回调函数 unlockf，从上面的源码我们可以知道这个函数是</span>
<span class="token comment">// netpollblockcommit</span>
<span class="token keyword">func</span> <span class="token function">gopark</span><span class="token punctuation">(</span>unlockf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> lock unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> reason waitReason<span class="token punctuation">,</span> traceEv <span class="token builtin">byte</span><span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> reason <span class="token operator">!=</span> waitReasonSleep <span class="token punctuation">{</span>
		<span class="token function">checkTimeouts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// timeouts may expire while two goroutines keep the scheduler busy</span>
	<span class="token punctuation">}</span>
	mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	gp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>curg
	status <span class="token operator">:=</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
	<span class="token keyword">if</span> status <span class="token operator">!=</span> _Grunning <span class="token operator">&amp;&amp;</span> status <span class="token operator">!=</span> _Gscanrunning <span class="token punctuation">{</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;gopark: bad g status&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	mp<span class="token punctuation">.</span>waitlock <span class="token operator">=</span> lock
	mp<span class="token punctuation">.</span>waitunlockf <span class="token operator">=</span> unlockf
	gp<span class="token punctuation">.</span>waitreason <span class="token operator">=</span> reason
	mp<span class="token punctuation">.</span>waittraceev <span class="token operator">=</span> traceEv
	mp<span class="token punctuation">.</span>waittraceskip <span class="token operator">=</span> traceskip
	<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
	<span class="token comment">// can't do anything that might move the G between Ms here.</span>
  <span class="token comment">// gopark 最终会调用 park_m，在这个函数内部会调用 unlockf，也就是 netpollblockcommit，</span>
	<span class="token comment">// 然后会把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>park_m<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// park continuation on g0.</span>
<span class="token keyword">func</span> <span class="token function">park_m</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>
		<span class="token function">traceGoPark</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waittraceev<span class="token punctuation">,</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waittraceskip<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
 
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span>
	<span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token keyword">if</span> fn <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitunlockf<span class="token punctuation">;</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token comment">// 调用 netpollblockcommit，把当前的 goroutine，</span>
		<span class="token comment">// 也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</span>
		ok <span class="token operator">:=</span> <span class="token function">fn</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitlock<span class="token punctuation">)</span>
		_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitunlockf <span class="token operator">=</span> <span class="token boolean">nil</span>
		_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitlock <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
			<span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>
				<span class="token function">traceGoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
			<span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// Schedule it back, never returns.</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// netpollblockcommit 在 gopark 函数里被调用</span>
<span class="token keyword">func</span> <span class="token function">netpollblockcommit</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> gpp unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token comment">// 通过原子操作把当前 goroutine 抽象的数据结构 g，也就是这里的参数 gp 存入 gpp 指针，</span>
	<span class="token comment">// 此时 gpp 的值是 pollDesc 的 rg 或者 wg 指针</span>
	r <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Casuintptr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>gpp<span class="token punctuation">)</span><span class="token punctuation">,</span> pdWait<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> r <span class="token punctuation">{</span>
		<span class="token comment">// Bump the count of goroutines waiting for the poller.</span>
		<span class="token comment">// The scheduler uses this to decide whether to block</span>
		<span class="token comment">// waiting for the poller if there is nothing else to do.</span>
		atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netpollWaiters<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> r
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br></div></div><p><code>pollDesc.waitWrite</code> 的内部实现原理和 <code>pollDesc.waitRead</code> 是一样的，都是基于 <code>poll.runtime_pollWait</code> --&gt; <code>runtime.poll_runtime_pollWait</code>，这里就不再赘述。</p> <h3 id="netpoll"><a href="#netpoll" class="header-anchor">#</a> netpoll</h3> <p>前面已经从源码的层面分析完了 netpoll 是如何通过 park goroutine 从而达到阻塞 Accept/Read/Write 的效果，而通过调用 gopark，goroutine 会被放置在某个等待队列中，这里是放到了 epoll 的 &quot;interest list&quot; 里，底层数据结构是由红黑树实现的 <code>eventpoll.rbr</code>，此时 G 的状态由 <code>_Grunning</code>为<code>_Gwaitting</code> ，因此 G 必须被手动唤醒(通过 goready )，否则会丢失任务，应用层阻塞通常使用这种方式。</p> <p>所以我们现在可以来从整体的层面来概括 Go 的网络业务 goroutine 是如何被规划调度的了：</p> <p><img src="/images/go/netpoll/netpoller-goroutines-scheduling.png" alt="img"></p> <blockquote><p>首先，client 连接 server 的时候，listener 通过 accept 调用接收新 connection，每一个新 connection 都启动一个 goroutine 处理，accept 调用会把该 connection 的 fd 连带所在的 goroutine 上下文信息封装注册到 epoll 的监听列表里去，当 goroutine 调用 <code>conn.Read</code> 或者 <code>conn.Write</code> 等需要阻塞等待的函数时，会被 <code>gopark</code> 给封存起来并使之休眠，让 P 去执行本地调度队列里的下一个可执行的 goroutine，往后 Go scheduler 会在循环调度的 <code>runtime.schedule()</code> 函数以及 sysmon 监控线程中调用 <code>runtime.netpoll</code> 以获取可运行的 goroutine 列表并通过调用 injectglist 把剩下的 g 放入全局调度队列或者当前 P 本地调度队列去重新执行。</p> <p>那么当 I/O 事件发生之后，netpoller 是通过什么方式唤醒那些在 I/O wait 的 goroutine 的？答案是通过 <code>runtime.netpoll</code>。</p></blockquote> <p><code>runtime.netpoll</code> 的核心逻辑是：</p> <ol><li>根据调用方的入参 delay，设置对应的调用 <code>epollwait</code> 的 timeout 值；</li> <li>调用 <code>epollwait</code> 等待发生了可读/可写事件的 fd；</li> <li>循环 <code>epollwait</code> 返回的事件列表，处理对应的事件类型， 组装可运行的 goroutine 链表并返回。</li></ol> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// netpoll checks for ready network connections.</span>
<span class="token comment">// Returns list of goroutines that become runnable.</span>
<span class="token comment">// delay &lt; 0: blocks indefinitely</span>
<span class="token comment">// delay == 0: does not block, just polls</span>
<span class="token comment">// delay &gt; 0: block for up to that many nanoseconds</span>
<span class="token keyword">func</span> <span class="token function">netpoll</span><span class="token punctuation">(</span>delay <span class="token builtin">int64</span><span class="token punctuation">)</span> gList <span class="token punctuation">{</span>
	<span class="token keyword">if</span> epfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> gList<span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
 
	<span class="token comment">// 根据特定的规则把 delay 值转换为 epollwait 的 timeout 值</span>
	<span class="token keyword">var</span> waitms <span class="token builtin">int32</span>
	<span class="token keyword">if</span> delay <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		waitms <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> delay <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		waitms <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> delay <span class="token operator">&lt;</span> <span class="token number">1e6</span> <span class="token punctuation">{</span>
		waitms <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> delay <span class="token operator">&lt;</span> <span class="token number">1e15</span> <span class="token punctuation">{</span>
		waitms <span class="token operator">=</span> <span class="token function">int32</span><span class="token punctuation">(</span>delay <span class="token operator">/</span> <span class="token number">1e6</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token comment">// An arbitrary cap on how long to wait for a timer.</span>
		<span class="token comment">// 1e9 ms == ~11.5 days.</span>
		waitms <span class="token operator">=</span> <span class="token number">1e9</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">var</span> events <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span>epollevent
retry<span class="token punctuation">:</span>
	<span class="token comment">// 超时等待就绪的 fd 读写事件</span>
	n <span class="token operator">:=</span> <span class="token function">epollwait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>events<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> waitms<span class="token punctuation">)</span>
	<span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> n <span class="token operator">!=</span> <span class="token operator">-</span>_EINTR <span class="token punctuation">{</span>
			<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: epollwait on fd&quot;</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token string">&quot;failed with&quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span>n<span class="token punctuation">)</span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: netpoll failed&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// If a timed sleep was interrupted, just return to</span>
		<span class="token comment">// recalculate how long we should sleep now.</span>
		<span class="token keyword">if</span> waitms <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> gList<span class="token punctuation">{</span><span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">goto</span> retry
	<span class="token punctuation">}</span>
 
	<span class="token comment">// toRun 是一个 g 的链表，存储要恢复的 goroutines，最后返回给调用方</span>
	<span class="token keyword">var</span> toRun gList
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		ev <span class="token operator">:=</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		<span class="token keyword">if</span> ev<span class="token punctuation">.</span>events <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
 
		<span class="token comment">// Go scheduler 在调用 findrunnable() 寻找 goroutine 去执行的时候，</span>
		<span class="token comment">// 在调用 netpoll 之时会检查当前是否有其他线程同步阻塞在 netpoll，</span>
		<span class="token comment">// 若是，则调用 netpollBreak 来唤醒那个线程，避免它长时间阻塞</span>
		<span class="token keyword">if</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>netpollBreakRd <span class="token punctuation">{</span>
			<span class="token keyword">if</span> ev<span class="token punctuation">.</span>events <span class="token operator">!=</span> _EPOLLIN <span class="token punctuation">{</span>
				<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: netpoll: break fd ready for&quot;</span><span class="token punctuation">,</span> ev<span class="token punctuation">.</span>events<span class="token punctuation">)</span>
				<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: netpoll: break fd ready for something unexpected&quot;</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> delay <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				<span class="token comment">// netpollBreak could be picked up by a</span>
				<span class="token comment">// nonblocking poll. Only read the byte</span>
				<span class="token comment">// if blocking.</span>
				<span class="token keyword">var</span> tmp <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
				<span class="token function">read</span><span class="token punctuation">(</span><span class="token function">int32</span><span class="token punctuation">(</span>netpollBreakRd<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">noescape</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netpollWakeSig<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
 
		<span class="token comment">// 判断发生的事件类型，读类型或者写类型等，然后给 mode 复制相应的值，</span>
    <span class="token comment">// mode 用来决定从 pollDesc 里的 rg 还是 wg 里取出 goroutine</span>
		<span class="token keyword">var</span> mode <span class="token builtin">int32</span>
		<span class="token keyword">if</span> ev<span class="token punctuation">.</span>events<span class="token operator">&amp;</span><span class="token punctuation">(</span>_EPOLLIN<span class="token operator">|</span>_EPOLLRDHUP<span class="token operator">|</span>_EPOLLHUP<span class="token operator">|</span>_EPOLLERR<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			mode <span class="token operator">+=</span> <span class="token char">'r'</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> ev<span class="token punctuation">.</span>events<span class="token operator">&amp;</span><span class="token punctuation">(</span>_EPOLLOUT<span class="token operator">|</span>_EPOLLHUP<span class="token operator">|</span>_EPOLLERR<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			mode <span class="token operator">+=</span> <span class="token char">'w'</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> mode <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token comment">// 取出保存在 epollevent 里的 pollDesc</span>
			pd <span class="token operator">:=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>pollDesc<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
			pd<span class="token punctuation">.</span>everr <span class="token operator">=</span> <span class="token boolean">false</span>
			<span class="token keyword">if</span> ev<span class="token punctuation">.</span>events <span class="token operator">==</span> _EPOLLERR <span class="token punctuation">{</span>
				pd<span class="token punctuation">.</span>everr <span class="token operator">=</span> <span class="token boolean">true</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 调用 netpollready，传入就绪 fd 的 pollDesc，</span>
			<span class="token comment">// 把 fd 对应的 goroutine 添加到链表 toRun 中</span>
			<span class="token function">netpollready</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>toRun<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> toRun
<span class="token punctuation">}</span>
 
<span class="token comment">// netpollready 调用 netpollunblock 返回就绪 fd 对应的 goroutine 的抽象数据结构 g</span>
<span class="token keyword">func</span> <span class="token function">netpollready</span><span class="token punctuation">(</span>toRun <span class="token operator">*</span>gList<span class="token punctuation">,</span> pd <span class="token operator">*</span>pollDesc<span class="token punctuation">,</span> mode <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> rg<span class="token punctuation">,</span> wg <span class="token operator">*</span>g
	<span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token char">'r'</span> <span class="token operator">||</span> mode <span class="token operator">==</span> <span class="token char">'r'</span><span class="token operator">+</span><span class="token char">'w'</span> <span class="token punctuation">{</span>
		rg <span class="token operator">=</span> <span class="token function">netpollunblock</span><span class="token punctuation">(</span>pd<span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token char">'w'</span> <span class="token operator">||</span> mode <span class="token operator">==</span> <span class="token char">'r'</span><span class="token operator">+</span><span class="token char">'w'</span> <span class="token punctuation">{</span>
		wg <span class="token operator">=</span> <span class="token function">netpollunblock</span><span class="token punctuation">(</span>pd<span class="token punctuation">,</span> <span class="token char">'w'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> rg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		toRun<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rg<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> wg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		toRun<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>wg<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// netpollunblock 会依据传入的 mode 决定从 pollDesc 的 rg 或者 wg 取出当时 gopark 之时存入的</span>
<span class="token comment">// goroutine 抽象数据结构 g 并返回</span>
<span class="token keyword">func</span> <span class="token function">netpollunblock</span><span class="token punctuation">(</span>pd <span class="token operator">*</span>pollDesc<span class="token punctuation">,</span> mode <span class="token builtin">int32</span><span class="token punctuation">,</span> ioready <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{</span>
	<span class="token comment">// mode == 'r' 代表当时 gopark 是为了等待读事件，而 mode == 'w' 则代表是等待写事件</span>
	gpp <span class="token operator">:=</span> <span class="token operator">&amp;</span>pd<span class="token punctuation">.</span>rg
	<span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token char">'w'</span> <span class="token punctuation">{</span>
		gpp <span class="token operator">=</span> <span class="token operator">&amp;</span>pd<span class="token punctuation">.</span>wg
	<span class="token punctuation">}</span>
 
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token comment">// 取出 gpp 存储的 g</span>
		old <span class="token operator">:=</span> <span class="token operator">*</span>gpp
		<span class="token keyword">if</span> old <span class="token operator">==</span> pdReady <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> old <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ioready <span class="token punctuation">{</span>
			<span class="token comment">// Only set READY for ioready. runtime_pollWait</span>
			<span class="token comment">// will check for timeout/cancel before waiting.</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">var</span> <span class="token builtin">new</span> <span class="token builtin">uintptr</span>
		<span class="token keyword">if</span> ioready <span class="token punctuation">{</span>
			<span class="token builtin">new</span> <span class="token operator">=</span> pdReady
		<span class="token punctuation">}</span>
		<span class="token comment">// 重置 pollDesc 的 rg 或者 wg</span>
		<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Casuintptr</span><span class="token punctuation">(</span>gpp<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果该 goroutine 还是必须等待，则返回 nil</span>
			<span class="token keyword">if</span> old <span class="token operator">==</span> pdWait <span class="token punctuation">{</span>
				old <span class="token operator">=</span> <span class="token number">0</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 通过万能指针还原成 g 并返回</span>
			<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// netpollBreak 往通信管道里写入信号去唤醒 epollwait</span>
<span class="token keyword">func</span> <span class="token function">netpollBreak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 通过 CAS 避免重复的唤醒信号被写入管道，</span>
	<span class="token comment">// 从而减少系统调用并节省一些系统资源</span>
	<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netpollWakeSig<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">{</span>
			<span class="token keyword">var</span> b <span class="token builtin">byte</span>
			n <span class="token operator">:=</span> <span class="token function">write</span><span class="token punctuation">(</span>netpollBreakWr<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
				<span class="token keyword">break</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token operator">-</span>_EINTR <span class="token punctuation">{</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token operator">-</span>_EAGAIN <span class="token punctuation">{</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
			<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: netpollBreak write failed with&quot;</span><span class="token punctuation">,</span> <span class="token operator">-</span>n<span class="token punctuation">)</span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;runtime: netpollBreak write failed&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br><span class="line-number">146</span><br><span class="line-number">147</span><br><span class="line-number">148</span><br><span class="line-number">149</span><br><span class="line-number">150</span><br><span class="line-number">151</span><br><span class="line-number">152</span><br><span class="line-number">153</span><br><span class="line-number">154</span><br><span class="line-number">155</span><br><span class="line-number">156</span><br><span class="line-number">157</span><br><span class="line-number">158</span><br><span class="line-number">159</span><br><span class="line-number">160</span><br><span class="line-number">161</span><br><span class="line-number">162</span><br><span class="line-number">163</span><br><span class="line-number">164</span><br><span class="line-number">165</span><br><span class="line-number">166</span><br><span class="line-number">167</span><br><span class="line-number">168</span><br></div></div><p>Go 在多种场景下都可能会调用 <code>netpoll</code> 检查文件描述符状态，<code>netpoll</code> 里会调用 <code>epoll_wait</code> 从 epoll 的 <code>eventpoll.rdllist</code> 就绪双向链表返回，从而得到 I/O 就绪的 socket fd 列表，并根据取出最初调用 <code>epoll_ctl</code> 时保存的上下文信息，恢复 <code>g</code>。所以执行完<code>netpoll</code> 之后，会返回一个就绪 fd 列表对应的 goroutine 链表，接下来将就绪的 goroutine 通过调用 <code>injectglist</code> 加入到全局调度队列或者 P 的本地调度队列中，启动 M 绑定 P 去执行。</p> <p>具体调用 <code>netpoll</code> 的地方，首先在 Go runtime scheduler 循环调度 goroutines 之时就有可能会调用 <code>netpoll</code> 获取到已就绪的 fd 对应的 goroutine 来调度执行。</p> <p>首先 Go scheduler 的核心方法 <code>runtime.schedule()</code> 里会调用一个叫 <code>runtime.findrunable()</code> 的方法获取可运行的 goroutine 来执行，而在 <code>runtime.findrunable()</code> 方法里就调用了 <code>runtime.netpoll</code> 获取已就绪的 fd 列表对应的 goroutine 列表：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// One round of scheduler: find a runnable goroutine and execute it.</span>
<span class="token comment">// Never returns.</span>
<span class="token keyword">func</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
  
  <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		gp<span class="token punctuation">,</span> inheritTime <span class="token operator">=</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// blocks until work is available</span>
	<span class="token punctuation">}</span>
  
	<span class="token operator">...</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// Finds a runnable goroutine to execute.</span>
<span class="token comment">// Tries to steal from other P's, get g from global queue, poll network.</span>
<span class="token keyword">func</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  
  <span class="token comment">// Poll network.</span>
	<span class="token keyword">if</span> <span class="token function">netpollinited</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>netpollWaiters<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> pollUntil <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Xchg64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		atomic<span class="token punctuation">.</span><span class="token function">Store64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>pollUntil<span class="token punctuation">,</span> <span class="token function">uint64</span><span class="token punctuation">(</span>pollUntil<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;findrunnable: netpoll with p&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>spinning <span class="token punctuation">{</span>
			<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;findrunnable: netpoll with spinning&quot;</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> faketime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token comment">// When using fake time, just poll.</span>
			delta <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token punctuation">}</span>
		list <span class="token operator">:=</span> <span class="token function">netpoll</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token comment">// 同步阻塞调用 netpoll，直至有可用的 goroutine</span>
		atomic<span class="token punctuation">.</span><span class="token function">Store64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>pollUntil<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
		atomic<span class="token punctuation">.</span><span class="token function">Store64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">,</span> <span class="token function">uint64</span><span class="token punctuation">(</span><span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> faketime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> list<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// Using fake time and nothing is ready; stop M.</span>
			<span class="token comment">// When all M's stop, checkdead will call timejump.</span>
			<span class="token function">stopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token keyword">goto</span> top
		<span class="token punctuation">}</span>
		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		_p_ <span class="token operator">=</span> <span class="token function">pidleget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 查找是否有空闲的 P 可以来就绪的 goroutine</span>
		<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
		<span class="token keyword">if</span> _p_ <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token function">injectglist</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span> <span class="token comment">// 如果当前没有空闲的 P，则把就绪的 goroutine 放入全局调度队列等待被执行</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// 如果当前有空闲的 P，则 pop 出一个 g，返回给调度器去执行，</span>
			<span class="token comment">// 并通过调用 injectglist 把剩下的 g 放入全局调度队列或者当前 P 本地调度队列</span>
			<span class="token function">acquirep</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				gp <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
				<span class="token function">injectglist</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>
				<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
				<span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>
					<span class="token function">traceGoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">return</span> gp<span class="token punctuation">,</span> <span class="token boolean">false</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> wasSpinning <span class="token punctuation">{</span>
				_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>spinning <span class="token operator">=</span> <span class="token boolean">true</span>
				atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">goto</span> top
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> pollUntil <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">netpollinited</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		pollerPollUntil <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>pollUntil<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> pollerPollUntil <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> pollerPollUntil <span class="token operator">&gt;</span> pollUntil <span class="token punctuation">{</span>
			<span class="token function">netpollBreak</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token function">stopm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">goto</span> top
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br></div></div><p>另外， <code>sysmon</code> 监控线程会在循环过程中检查距离上一次 <code>runtime.netpoll</code> 被调用是否超过了 10ms，若是则会去调用它拿到可运行的 goroutine 列表并通过调用 injectglist 把 g 列表放入全局调度队列或者当前 P 本地调度队列等待被执行：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Always runs without a P, so write barriers are not allowed.</span>
<span class="token comment">//</span>
<span class="token comment">//go:nowritebarrierrec</span>
<span class="token keyword">func</span> <span class="token function">sysmon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token operator">...</span>
  
		<span class="token comment">// poll network if not polled for more than 10ms</span>
		lastpoll <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token function">netpollinited</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> lastpoll <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lastpoll<span class="token operator">+</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1000</span> <span class="token operator">&lt;</span> now <span class="token punctuation">{</span>
			atomic<span class="token punctuation">.</span><span class="token function">Cas64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lastpoll<span class="token punctuation">,</span> <span class="token function">uint64</span><span class="token punctuation">(</span>lastpoll<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uint64</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span>
			list <span class="token operator">:=</span> <span class="token function">netpoll</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// non-blocking - returns list of goroutines</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// Need to decrement number of idle locked M's</span>
				<span class="token comment">// (pretending that one more is running) before injectglist.</span>
				<span class="token comment">// Otherwise it can lead to the following situation:</span>
				<span class="token comment">// injectglist grabs all P's but before it starts M's to run the P's,</span>
				<span class="token comment">// another M returns from syscall, finishes running its G,</span>
				<span class="token comment">// observes that there is no work to do and no other running M's</span>
				<span class="token comment">// and reports deadlock.</span>
				<span class="token function">incidlelocked</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
				<span class="token function">injectglist</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>
				<span class="token function">incidlelocked</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
  
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>Go runtime 在程序启动的时候会创建一个独立的 M 作为监控线程，叫 <code>sysmon</code> ，这个线程为系统级的 daemon 线程，无需 P 即可运行， <code>sysmon</code> 每 20us~10ms 运行一次。 <code>sysmon</code> 中以轮询的方式执行以下操作（如上面的代码所示）：</p> <ol><li>以非阻塞的方式调用 <code>runtime.netpoll</code> ，从中找出能从网络 I/O 中唤醒的 g 列表，并通过调用 injectglist 把 g 列表放入全局调度队列或者当前 P 本地调度队列等待被执行，调度触发时，有可能从这个全局 runnable 调度队列获取 g。然后再循环调用 <code>startm</code> ，直到所有 P 都不处于 <code>_Pidle</code> 状态。</li> <li>调用 <code>retake</code> ，抢占长时间处于 <code>_Psyscall</code> 状态的 P。</li></ol> <p>综上，Go 借助于 epoll/kqueue/iocp 和 runtime scheduler 等的帮助，设计出了自己的 I/O 多路复用 netpoller，成功地让 <code>Listener.Accept</code> / <code>conn.Read</code> / <code>conn.Write</code> 等方法从开发者的角度看来是同步模式。</p> <h2 id="go-netpoller-的价值"><a href="#go-netpoller-的价值" class="header-anchor">#</a> Go netpoller 的价值</h2> <p>通过前面对源码的分析，我们现在知道 Go netpoller 依托于 runtime scheduler，为开发者提供了一种强大的同步网络编程模式；然而，Go netpoller 存在的意义却远不止于此，Go netpoller I/O 多路复用搭配 Non-blocking I/O 而打造出来的这个原生网络模型，它最大的价值是把网络 I/O 的控制权牢牢掌握在 Go 自己的 runtime 里，关于这一点我们需要从 Go 的 runtime scheduler 说起，Go 的 G-P-M 调度模型如下：</p> <p><img src="/images/go/netpoll/goroutine-scheduler-model.png" alt="img"></p> <p>G 在运行过程中如果被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P(实质是被 sysmon 抢走了)，与 G 一起进入 sleep 状态。如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，那么就会创建一个新的 M。当阻塞在 system call 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为 <code>_Grunnable</code> 并把它放入全局的 runqueue 中等待调度，之前的那个 sleep 的 M 将再次进入 sleep。</p> <p>现在清楚为什么 netpoll 为什么一定要使用非阻塞 I/O 了吧？就是为了避免让操作网络 I/O 的 goroutine 陷入到系统调用从而进入内核态，因为一旦进入内核态，整个程序的控制权就会发生转移(到内核)，不再属于用户进程了，那么也就无法借助于 Go 强大的 runtime scheduler 来调度业务程序的并发了；而有了 netpoll 之后，借助于非阻塞 I/O ，G 就再也不会因为系统调用的读写而 (长时间) 陷入内核态，当 G 被阻塞在某个 network I/O 操作上时，实际上它不是因为陷入内核态被阻塞住了，而是被 Go runtime 调用 gopark 给 park 住了，此时 G 会被放置到某个 wait queue 中，而 M 会尝试运行下一个 <code>_Grunnable</code> 的 G，如果此时没有 <code>_Grunnable</code> 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available，在 epoll 的 <code>eventpoll.rdr</code> 中等待的 G 会被放到 <code>eventpoll.rdllist</code> 链表里并通过 <code>netpoll</code> 中的 <code>epoll_wait</code> 系统调用返回放置到全局调度队列或者 P 的本地调度队列，标记为 <code>_Grunnable</code> ，等待 P 绑定 M 恢复执行。</p> <h2 id="goroutine-的调度"><a href="#goroutine-的调度" class="header-anchor">#</a> Goroutine 的调度</h2> <p>这一小节主要是讲处理网络 I/O 的 goroutines 阻塞之后，Go scheduler 具体是如何像前面几个章节所说的那样，避免让操作网络 I/O 的 goroutine 陷入到系统调用从而进入内核态的，而是封存 goroutine 然后让出 CPU 的使用权从而令 P 可以去调度本地调度队列里的下一个 goroutine 的。</p> <p><strong>温馨提示</strong>：这一小节属于延伸阅读，涉及到的知识点更偏系统底层，需要有一定的汇编语言基础才能通读，另外，这一节对 Go scheduler 的讲解仅仅涉及核心的一部分，不会把整个调度器都讲一遍（事实上如果真要解析 Go scheduler 的话恐怕重开一篇几万字的文章才能基本讲清楚。。。），所以也要求读者对 Go 的并发调度器有足够的了解，因此这一节可能会稍显深奥。当然这一节也可选择不读，因为通过前面的整个解析，我相信读者应该已经能够基本掌握 Go netpoller 处理网络 I/O 的核心细节了，以及能从宏观层面了解 netpoller 对业务 goroutines 的基本调度了。而这一节主要是通过对 goroutines 调度细节的剖析，能够加深读者对整个 Go netpoller 的彻底理解，接上前面几个章节，形成一个完整的闭环。如果对调度的底层细节没兴趣的话这也可以直接跳过这一节，对理解 Go netpoller 的基本原理影响不大，不过还是建议有条件的读者可以看看。</p> <p>从源码可知，Go scheduler 的调度 goroutine 过程中所调用的核心函数链如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>runtime<span class="token punctuation">.</span>schedule <span class="token operator">--</span><span class="token operator">&gt;</span> runtime<span class="token punctuation">.</span>execute <span class="token operator">--</span><span class="token operator">&gt;</span> runtime<span class="token punctuation">.</span>gogo <span class="token operator">--</span><span class="token operator">&gt;</span> goroutine code <span class="token operator">--</span><span class="token operator">&gt;</span> runtime<span class="token punctuation">.</span>goexit <span class="token operator">--</span><span class="token operator">&gt;</span> runtime<span class="token punctuation">.</span>goexit1 <span class="token operator">--</span><span class="token operator">&gt;</span> runtime<span class="token punctuation">.</span>mcall <span class="token operator">--</span><span class="token operator">&gt;</span> runtime<span class="token punctuation">.</span>goexit0 <span class="token operator">--</span><span class="token operator">&gt;</span> runtime<span class="token punctuation">.</span>schedule
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>Go scheduler 会不断循环调用 <code>runtime.schedule()</code> 去调度 goroutines，而每个 goroutine 执行完成并退出之后，会再次调用 <code>runtime.schedule()</code>，使得调度器回到调度循环去执行其他的 goroutine，不断循环，永不停歇。</p> <p>当我们使用 <code>go</code> 关键字启动一个新 goroutine 时，最终会调用 <code>runtime.newproc</code> --&gt; <code>runtime.newproc1</code>，来得到 g，<code>runtime.newproc1</code> 会先从 P 的 <code>gfree</code> 缓存链表中查找可用的 g，若缓存未生效，则会新创建 g 给当前的业务函数，最后这个 g 会被传给 <code>runtime.gogo</code> 去真正执行。</p></blockquote> <p>这里首先需要了解一个 gobuf 的结构体，它用来保存 goroutine 的调度信息，是 <code>runtime.gogo</code> 的入参：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// gobuf 存储 goroutine 调度上下文信息的结构体</span>
<span class="token keyword">type</span> gobuf <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.</span>
	<span class="token comment">//</span>
	<span class="token comment">// ctxt is unusual with respect to GC: it may be a</span>
	<span class="token comment">// heap-allocated funcval, so GC needs to track it, but it</span>
	<span class="token comment">// needs to be set and cleared from assembly, where it's</span>
	<span class="token comment">// difficult to have write barriers. However, ctxt is really a</span>
	<span class="token comment">// saved, live register, and we only ever exchange it between</span>
	<span class="token comment">// the real register and the gobuf. Hence, we treat it as a</span>
	<span class="token comment">// root during stack scanning, which means assembly that saves</span>
	<span class="token comment">// and restores it doesn't need write barriers. It's still</span>
	<span class="token comment">// typed as a pointer so that any other writes from Go get</span>
	<span class="token comment">// write barriers.</span>
	sp   <span class="token builtin">uintptr</span> <span class="token comment">// Stack Pointer 栈指针</span>
	pc   <span class="token builtin">uintptr</span> <span class="token comment">// Program Counter 程序计数器</span>
	g    guintptr <span class="token comment">// 持有当前 gobuf 的 goroutine</span>
	ctxt unsafe<span class="token punctuation">.</span>Pointer
	ret  sys<span class="token punctuation">.</span>Uintreg
	lr   <span class="token builtin">uintptr</span>
	bp   <span class="token builtin">uintptr</span> <span class="token comment">// for GOEXPERIMENT=framepointer</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>执行 <code>runtime.execute()</code>，进而调用 <code>runtime.gogo</code>：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">execute</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">,</span> inheritTime <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token comment">// Assign gp.m before entering _Grunning so running Gs have an</span>
	<span class="token comment">// M.</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg <span class="token operator">=</span> gp
	gp<span class="token punctuation">.</span>m <span class="token operator">=</span> _g_<span class="token punctuation">.</span>m
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>
	gp<span class="token punctuation">.</span>waitsince <span class="token operator">=</span> <span class="token number">0</span>
	gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>
	gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard
	<span class="token keyword">if</span> <span class="token operator">!</span>inheritTime <span class="token punctuation">{</span>
		_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>schedtick<span class="token operator">++</span>
	<span class="token punctuation">}</span>
 
	<span class="token comment">// Check whether the profiler needs to be turned on or off.</span>
	hz <span class="token operator">:=</span> sched<span class="token punctuation">.</span>profilehz
	<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>profilehz <span class="token operator">!=</span> hz <span class="token punctuation">{</span>
		<span class="token function">setThreadCPUProfiler</span><span class="token punctuation">(</span>hz<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
 
	<span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>
		<span class="token comment">// GoSysExit has to happen when we have a P, but before GoStart.</span>
		<span class="token comment">// So we emit it here.</span>
		<span class="token keyword">if</span> gp<span class="token punctuation">.</span>syscallsp <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> gp<span class="token punctuation">.</span>sysblocktraced <span class="token punctuation">{</span>
			<span class="token function">traceGoSysExit</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>sysexitticks<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token function">traceGoStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// gp.sched 就是 gobuf</span>
	<span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gp<span class="token punctuation">.</span>sched<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>这里还需要了解一个概念：g0，Go G-P-M 调度模型中，g 代表 goroutine，而实际上一共有三种 g：</p> <ol><li>执行用户代码的 g；</li> <li>执行调度器代码的 g，也即是 g0；</li> <li>执行 <code>runtime.main</code> 初始化工作的 main goroutine；</li></ol> <p>第一种 g 就是使用 <code>go</code> 关键字启动的 goroutine，也是我们接触最多的一类 g；第三种 g 是调度器启动之后用来执行的一系列初始化工作的，包括但不限于启动 <code>sysmon</code> 监控线程、内存初始化和启动 GC 等等工作；第二种 g 叫 g0，用来执行调度器代码，g0 在底层和其他 g 是一样的数据结构，但是性质上有很大的区别，首先 g0 的栈大小是固定的，比如在 Linux 或者其他 Unix-like 的系统上一般是固定 8MB，不能动态伸缩，而普通的 g 初始栈大小是 2KB，可按需扩展，g0 其实就是线程栈，我们知道每个线程被创建出来之时都需要操作系统为之分配一个初始固定的线程栈，就是前面说的 8MB 大小的栈，g0 栈就代表了这个线程栈，因此每一个 m 都需要绑定一个 g0 来执行调度器代码，然后跳转到执行用户代码的地方。</p> <p><code>runtime.gogo</code> 是真正去执行 goroutine 代码的函数，这个函数由汇编实现，为什么需要用汇编？因为 <code>gogo</code> 的工作是完成线程 M 上的堆栈切换：从系统堆栈 g0 切换成 goroutine <code>gp</code>，也就是 CPU 使用权和堆栈的切换，这种切换本质上是对 CPU 的 PC、SP 等寄存器和堆栈指针的更新，而这一类精度的底层操作别说是 Go，就算是最贴近底层的 C 也无法做到，这种程度的操作已超出所有高级语言的范畴，因此只能借助于汇编来实现。</p> <p><code>runtime.gogo</code> 在不同的 CPU 架构平台上的实现各不相同，但是核心原理殊途同归，我们这里选用 amd64 架构的汇编实现来分析，我会在关键的地方加上解释：</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code><span class="token comment">// func gogo(buf *gobuf)</span>
<span class="token comment">// restore state from Gobuf; longjmp</span>
TEXT runtime·<span class="token function">gogo</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> NOSPLIT<span class="token punctuation">,</span> <span class="token variable">$16-8</span>
	<span class="token comment">// 将第一个 FP 伪寄存器所指向的 gobuf 的第一个参数存入 BX 寄存器, </span>
	<span class="token comment">// gobuf 的一个参数即是 SP 指针</span>
	MOVQ	buf+<span class="token function">0</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> BX
	MOVQ	gobuf_<span class="token function">g</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> DX  <span class="token comment">// 将 gp.sched.g 保存到 DX 寄存器</span>
	MOVQ	<span class="token function">0</span><span class="token punctuation">(</span>DX<span class="token punctuation">)</span><span class="token punctuation">,</span> CX		<span class="token comment">// make sure g != nil</span>
 
	<span class="token comment">// 将 tls (thread local storage) 保存到 CX 寄存器，然后把 gp.sched.g 放到 tls[0]，</span>
	<span class="token comment">// 这样以后调用 getg() 之时就可以通过 TLS 直接获取到当前 goroutine 的 g 结构体实例，</span>
	<span class="token comment">// 进而可以得到 g 所在的 m 和 p，TLS 里一开始存储的是系统堆栈 g0 的地址</span>
	get_<span class="token function">tls</span><span class="token punctuation">(</span>CX<span class="token punctuation">)</span>
	MOVQ	DX<span class="token punctuation">,</span> <span class="token function">g</span><span class="token punctuation">(</span>CX<span class="token punctuation">)</span>
 
	<span class="token comment">// 下面的指令则是对函数栈的 BP/SP 寄存器(指针)的存取，</span>
	<span class="token comment">// 最后进入到指定的代码区域，执行函数栈帧</span>
	MOVQ	gobuf_<span class="token function">sp</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> SP	<span class="token comment">// restore SP</span>
	MOVQ	gobuf_<span class="token function">ret</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> AX
	MOVQ	gobuf_<span class="token function">ctxt</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> DX
	MOVQ	gobuf_<span class="token function">bp</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> BP
 
	<span class="token comment">// 这里是在清空 gp.sched，因为前面已经把 gobuf 里的字段值都存入了寄存器，</span>
	<span class="token comment">// 所以 gp.sched 就可以提前清空了，不需要等到后面 GC 来回收，减轻 GC 的负担</span>
	MOVQ	<span class="token variable">$0</span><span class="token punctuation">,</span> gobuf_<span class="token function">sp</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span>	<span class="token comment">// clear to help garbage collector</span>
	MOVQ	<span class="token variable">$0</span><span class="token punctuation">,</span> gobuf_<span class="token function">ret</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span>
	MOVQ	<span class="token variable">$0</span><span class="token punctuation">,</span> gobuf_<span class="token function">ctxt</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span>
	MOVQ	<span class="token variable">$0</span><span class="token punctuation">,</span> gobuf_<span class="token function">bp</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span>
 
	<span class="token comment">// 把 gp.sched.pc 值放入 BX 寄存器</span>
	<span class="token comment">// PC 指针指向 gogo 退出时需要执行的函数地址</span>
	MOVQ	gobuf_<span class="token function">pc</span><span class="token punctuation">(</span>BX<span class="token punctuation">)</span><span class="token punctuation">,</span> BX
	<span class="token comment">// 用 BX 寄存器里的值去修改 CPU 的 IP 寄存器，</span>
	<span class="token comment">// 这样就可以根据 CS:IP 寄存器的段地址+偏移量跳转到 BX 寄存器里的地址，也就是 gp.sched.pc</span>
	JMP	BX
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p><code>runtime.gogo</code> 函数接收 <code>gp.sched</code> 这个 <code>gobuf</code> 结构体实例，其中保存了函数栈寄存器 SP/PC/BP，如果熟悉操作系统原理的话可以知道这些寄存器是 CPU 进行函数调用和返回时切换对应的函数栈帧所需的寄存器，而 goroutine 的执行和函数调用的原理是一致的，也是 CPU 寄存器的切换过程，所以这里的几个寄存器当前存的就是 G 的函数执行栈，当 goroutine 在处理网络 I/O 之时，如果恰好处于 I/O 就绪的状态的话，则正常完成 <code>runtime.gogo</code>，并在最后跳转到特定的地址，那么这个地址是哪里呢？</p> <p>我们知道 CPU 执行函数的时候需要知道函数在内存里的代码段地址和偏移量，然后才能去取来函数栈执行，而典型的提供代码段地址和偏移量的寄存器就是 CS 和 IP 寄存器，而 <code>JMP BX</code> 指令则是用 BX 寄存器去更新 IP 寄存器，而 BX 寄存器里的值是 <code>gp.sched.pc</code>，那么这个 PC 指针究竟是指向哪里呢？让我们来看另一处源码。</p> <p>众所周知，启动一个新的 goroutine 是通过 <code>go</code> 关键字来完成的，而 go compiler 会在编译期间利用 <a href="https://github.com/golang/go/blob/1984ee00048b63eacd2155cd6d74a2d13e998272/src/cmd/compile/internal/gc/ssa.go#L1039" target="_blank" rel="noopener noreferrer"><code>cmd/compile/internal/gc.state.stmt</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://github.com/golang/go/blob/1984ee00048b63eacd2155cd6d74a2d13e998272/src/cmd/compile/internal/gc/ssa.go#L4328" target="_blank" rel="noopener noreferrer"><code>cmd/compile/internal/gc.state.call</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这两个函数将 <code>go</code> 关键字翻译成 <a href="https://github.com/golang/go/blob/1984ee00048b63eacd2155cd6d74a2d13e998272/src/runtime/proc.go#L3523" target="_blank" rel="noopener noreferrer"><code>runtime.newproc</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 函数调用，而 <code>runtime.newproc</code> 接收了函数指针和其大小之后，会获取 goroutine 和调用处的程序计数器，接着再调用 <a href="https://github.com/golang/go/blob/1984ee00048b63eacd2155cd6d74a2d13e998272/src/runtime/proc.go#L3548" target="_blank" rel="noopener noreferrer"><code>runtime.newproc1</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Create a new g in state _Grunnable, starting at fn, with narg bytes</span>
<span class="token comment">// of arguments starting at argp. callerpc is the address of the go</span>
<span class="token comment">// statement that created this. The caller is responsible for adding</span>
<span class="token comment">// the new g to the scheduler.</span>
<span class="token comment">//</span>
<span class="token comment">// This must run on the system stack because it's the continuation of</span>
<span class="token comment">// newproc, which cannot split the stack.</span>
<span class="token comment">//</span>
<span class="token comment">//go:systemstack</span>
<span class="token keyword">func</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">,</span> argp unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> narg <span class="token builtin">int32</span><span class="token punctuation">,</span> callergp <span class="token operator">*</span>g<span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  
  <span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">)</span><span class="token punctuation">)</span>
	newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>sp <span class="token operator">=</span> sp
	newg<span class="token punctuation">.</span>stktopsp <span class="token operator">=</span> sp
	<span class="token comment">// 把 goexit 函数地址存入 gobuf 的 PC 指针里</span>
	newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">funcPC</span><span class="token punctuation">(</span>goexit<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>PCQuantum <span class="token comment">// +PCQuantum so that previous instruction is in same function</span>
	newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token function">gostartcallfn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newg<span class="token punctuation">.</span>sched<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
	newg<span class="token punctuation">.</span>gopc <span class="token operator">=</span> callerpc
	newg<span class="token punctuation">.</span>ancestors <span class="token operator">=</span> <span class="token function">saveAncestors</span><span class="token punctuation">(</span>callergp<span class="token punctuation">)</span>
	newg<span class="token punctuation">.</span>startpc <span class="token operator">=</span> fn<span class="token punctuation">.</span>fn
	<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		newg<span class="token punctuation">.</span>labels <span class="token operator">=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg<span class="token punctuation">.</span>labels
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token function">isSystemGoroutine</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>ngsys<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> _Gdead<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
  
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>这里可以看到，<code>newg.sched.pc</code> 被设置了 <code>runtime.goexit</code> 的函数地址，<code>newg</code> 就是后面 <code>runtime.gogo</code> 执行的 goroutine，因此 <code>runtime.gogo</code> 最后的汇编指令 <code>JMP BX</code>是跳转到了 <code>runtime.goexit</code>，让我们来继续看看这个函数做了什么：</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code><span class="token comment">// The top-most function running on a goroutine</span>
<span class="token comment">// returns to goexit+PCQuantum. Defined as ABIInternal</span>
<span class="token comment">// so as to make it identifiable to traceback (this</span>
<span class="token comment">// function it used as a sentinel; traceback wants to</span>
<span class="token comment">// see the func PC, not a wrapper PC).</span>
TEXT runtime·goexit&lt;ABIInternal&gt;<span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span>NOSPLIT<span class="token punctuation">,</span><span class="token variable">$0-0</span>
	BYTE	<span class="token variable">$0x90</span>	<span class="token comment">// NOP</span>
	CALL	runtime·<span class="token function">goexit1</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>	<span class="token comment">// does not return</span>
	<span class="token comment">// traceback from goexit1 must hit code range of goexit</span>
	BYTE	<span class="token variable">$0x90</span>	<span class="token comment">// NOP</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个函数也是汇编实现的，但是非常简单，就是直接调用 <code>runtime·goexit1</code>：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Finishes execution of the current goroutine.</span>
<span class="token keyword">func</span> <span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> raceenabled <span class="token punctuation">{</span>
		<span class="token function">racegoend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>
		<span class="token function">traceGoEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>goexit0<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>调用 <code>runtime.mcall</code>函数：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// func mcall(fn func(*g))</span>
<span class="token comment">// Switch to m-&gt;g0's stack, call fn(g).</span>
<span class="token comment">// Fn must never return. It should gogo(&amp;g-&gt;sched)</span>
<span class="token comment">// to keep running g.</span>
 
<span class="token comment">// 切换回 g0 的系统堆栈，执行 fn(g)</span>
<span class="token constant">TEXT</span> runtime·<span class="token function">mcall</span><span class="token punctuation">(</span><span class="token constant">SB</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NOSPLIT</span><span class="token punctuation">,</span> <span class="token variable">$0</span><span class="token operator">-</span><span class="token number">8</span>
	<span class="token comment">// 取入参 funcval 对象的指针存入 DI 寄存器，此时 fn.fn 是 goexit0 的地址</span>
	<span class="token constant">MOVQ</span>	<span class="token keyword">fn</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">(</span><span class="token constant">FP</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">DI</span>
 
	<span class="token function">get_tls</span><span class="token punctuation">(</span><span class="token constant">CX</span><span class="token punctuation">)</span>
	<span class="token constant">MOVQ</span>	<span class="token function">g</span><span class="token punctuation">(</span><span class="token constant">CX</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">AX</span>	<span class="token comment">// save state in g-&gt;sched</span>
	<span class="token constant">MOVQ</span>	<span class="token number">0</span><span class="token punctuation">(</span><span class="token constant">SP</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">BX</span>	<span class="token comment">// caller's PC</span>
	<span class="token constant">MOVQ</span>	<span class="token constant">BX</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>g_sched<span class="token operator">+</span>gobuf_pc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">AX</span><span class="token punctuation">)</span>
	<span class="token constant">LEAQ</span>	<span class="token keyword">fn</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">(</span><span class="token constant">FP</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">BX</span>	<span class="token comment">// caller's SP</span>
	<span class="token constant">MOVQ</span>	<span class="token constant">BX</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>g_sched<span class="token operator">+</span>gobuf_sp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">AX</span><span class="token punctuation">)</span>
	<span class="token constant">MOVQ</span>	<span class="token constant">AX</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>g_sched<span class="token operator">+</span>gobuf_g<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">AX</span><span class="token punctuation">)</span>
	<span class="token constant">MOVQ</span>	<span class="token constant">BP</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>g_sched<span class="token operator">+</span>gobuf_bp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">AX</span><span class="token punctuation">)</span>
 
	<span class="token comment">// switch to m-&gt;g0 &amp; its stack, call fn</span>
	<span class="token constant">MOVQ</span>	<span class="token function">g</span><span class="token punctuation">(</span><span class="token constant">CX</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">BX</span>
	<span class="token constant">MOVQ</span>	<span class="token function">g_m</span><span class="token punctuation">(</span><span class="token constant">BX</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">BX</span>
 
	<span class="token comment">// 把 g0 的栈指针存入 SI 寄存器，后面需要用到</span>
	<span class="token constant">MOVQ</span>	<span class="token function">m_g0</span><span class="token punctuation">(</span><span class="token constant">BX</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">SI</span>
	<span class="token constant">CMPQ</span>	<span class="token constant">SI</span><span class="token punctuation">,</span> <span class="token constant">AX</span>	<span class="token comment">// if g == m-&gt;g0 call badmcall</span>
	<span class="token constant">JNE</span>	<span class="token number">3</span><span class="token punctuation">(</span><span class="token constant">PC</span><span class="token punctuation">)</span>
	<span class="token constant">MOVQ</span>	<span class="token variable">$runtime</span>·<span class="token function">badmcall</span><span class="token punctuation">(</span><span class="token constant">SB</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">AX</span>
	<span class="token constant">JMP</span>	<span class="token constant">AX</span>
 
	<span class="token comment">// 这两个指令是把 g0 地址存入到 TLS 里，</span>
	<span class="token comment">// 然后从 SI 寄存器取出 g0 的栈指针，</span>
	<span class="token comment">// 替换掉 SP 寄存器里存的当前 g 的栈指针</span>
	<span class="token constant">MOVQ</span>	<span class="token constant">SI</span><span class="token punctuation">,</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token constant">CX</span><span class="token punctuation">)</span>	<span class="token comment">// g = m-&gt;g0</span>
	<span class="token constant">MOVQ</span>	<span class="token punctuation">(</span>g_sched<span class="token operator">+</span>gobuf_sp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">SI</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">SP</span>	<span class="token comment">// sp = m-&gt;g0-&gt;sched.sp</span>
 
	<span class="token constant">PUSHQ</span>	<span class="token constant">AX</span>
	<span class="token constant">MOVQ</span>	<span class="token constant">DI</span><span class="token punctuation">,</span> <span class="token constant">DX</span>
 
	<span class="token comment">// 入口处的第一个指令已经把 funcval 实例对象的指针存入了 DI 寄存器，</span>
	<span class="token comment">// 0(DI) 表示取出 DI 的第一个成员，即 goexit0 函数地址，再存入 DI</span>
	<span class="token constant">MOVQ</span>	<span class="token number">0</span><span class="token punctuation">(</span><span class="token constant">DI</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">DI</span>
	<span class="token constant">CALL</span>	<span class="token constant">DI</span> <span class="token comment">// 调用 DI 寄存器里的地址，即 goexit0</span>
	<span class="token constant">POPQ</span>	<span class="token constant">AX</span>
	<span class="token constant">MOVQ</span>	<span class="token variable">$runtime</span>·<span class="token function">badmcall2</span><span class="token punctuation">(</span><span class="token constant">SB</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">AX</span>
	<span class="token constant">JMP</span>	<span class="token constant">AX</span>
	<span class="token constant">RET</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>可以看到 <code>runtime.mcall</code> 函数的主要逻辑是从当前 goroutine 切换回 g0 的系统堆栈，然后调用 fn(g)，此处的 g 即是当前运行的 goroutine，这个方法会保存当前运行的 G 的 PC/SP 到 g-&gt;sched 里，以便该 G 可以在以后被重新恢复执行，因为也涉及到寄存器和堆栈指针的操作，所以也需要使用汇编实现，该函数最后会在 g0 系统堆栈下执行 <code>runtime.goexit0</code>:</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">goexit0</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token function">isSystemGoroutine</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>ngsys<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	gp<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token boolean">nil</span>
	locked <span class="token operator">:=</span> gp<span class="token punctuation">.</span>lockedm <span class="token operator">!=</span> <span class="token number">0</span>
	gp<span class="token punctuation">.</span>lockedm <span class="token operator">=</span> <span class="token number">0</span>
	_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedg <span class="token operator">=</span> <span class="token number">0</span>
	gp<span class="token punctuation">.</span>preemptStop <span class="token operator">=</span> <span class="token boolean">false</span>
	gp<span class="token punctuation">.</span>paniconfault <span class="token operator">=</span> <span class="token boolean">false</span>
	gp<span class="token punctuation">.</span>_defer <span class="token operator">=</span> <span class="token boolean">nil</span> <span class="token comment">// should be true already but just in case.</span>
	gp<span class="token punctuation">.</span>_panic <span class="token operator">=</span> <span class="token boolean">nil</span> <span class="token comment">// non-nil for Goexit during panic. points at stack-allocated data.</span>
	gp<span class="token punctuation">.</span>writebuf <span class="token operator">=</span> <span class="token boolean">nil</span>
	gp<span class="token punctuation">.</span>waitreason <span class="token operator">=</span> <span class="token number">0</span>
	gp<span class="token punctuation">.</span>param <span class="token operator">=</span> <span class="token boolean">nil</span>
	gp<span class="token punctuation">.</span>labels <span class="token operator">=</span> <span class="token boolean">nil</span>
	gp<span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token boolean">nil</span>
 
	<span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> gp<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token comment">// Flush assist credit to the global pool. This gives</span>
		<span class="token comment">// better information to pacing if the application is</span>
		<span class="token comment">// rapidly creating an exiting goroutines.</span>
		scanCredit <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>gcController<span class="token punctuation">.</span>assistWorkPerByte <span class="token operator">*</span> <span class="token function">float64</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>gcAssistBytes<span class="token punctuation">)</span><span class="token punctuation">)</span>
		atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>bgScanCredit<span class="token punctuation">,</span> scanCredit<span class="token punctuation">)</span>
		gp<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token punctuation">}</span>
 
	<span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token keyword">if</span> GOARCH <span class="token operator">==</span> <span class="token string">&quot;wasm&quot;</span> <span class="token punctuation">{</span> <span class="token comment">// no threads yet on wasm</span>
		<span class="token function">gfput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">)</span>
		<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// never returns</span>
	<span class="token punctuation">}</span>
 
	<span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedInt <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;invalid m-&gt;lockedInt = &quot;</span><span class="token punctuation">,</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedInt<span class="token punctuation">,</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;internal lockOSThread error&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token function">gfput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">)</span>
	<span class="token keyword">if</span> locked <span class="token punctuation">{</span>
		<span class="token comment">// The goroutine may have locked this thread because</span>
		<span class="token comment">// it put it in an unusual kernel state. Kill it</span>
		<span class="token comment">// rather than returning it to the thread pool.</span>
 
		<span class="token comment">// Return to mstart, which will release the P and exit</span>
		<span class="token comment">// the thread.</span>
		<span class="token keyword">if</span> GOOS <span class="token operator">!=</span> <span class="token string">&quot;plan9&quot;</span> <span class="token punctuation">{</span> <span class="token comment">// See golang.org/issue/22227.</span>
			<span class="token function">gogo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>g0<span class="token punctuation">.</span>sched<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// Clear lockedExt on plan9 since we may end up re-using</span>
			<span class="token comment">// this thread.</span>
			_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>lockedExt <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><p><code>runtime.goexit0</code> 的主要工作是就是</p> <ol><li>利用 CAS 操作把 g 的状态从 <code>_Grunning</code> 更新为 <code>_Gdead</code>；</li> <li>对 g 做一些清理操作，把一些字段值置空；</li> <li>调用 <code>runtime.dropg</code> 解绑 g 和 m；</li> <li>把 g 放入 p 存储 g 的 <code>gfree</code> 链表作为缓存，后续如果需要启动新的 goroutine 则可以直接从链表里取而不用重新初始化分配内存。</li> <li>最后，调用 <code>runtime.schedule()</code> 再次进入调度循环去调度新的 goroutines，永不停歇。</li></ol> <p>另一方面，如果 goroutine 处于 I/O 不可用状态，我们前面已经分析过 netpoller 利用非阻塞 I/O + I/O 多路复用避免了陷入系统调用，所以此时会调用 <code>runtime.gopark</code> 并把 goroutine 暂时封存在用户态空间，并休眠当前的 goroutine，因此不会阻塞 <code>runtime.gogo</code> 的汇编执行，而是通过 <code>runtime.mcall</code> 调用 <code>runtime.park_m</code>：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">gopark</span><span class="token punctuation">(</span>unlockf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> lock unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> reason waitReason<span class="token punctuation">,</span> traceEv <span class="token builtin">byte</span><span class="token punctuation">,</span> traceskip <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> reason <span class="token operator">!=</span> waitReasonSleep <span class="token punctuation">{</span>
		<span class="token function">checkTimeouts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// timeouts may expire while two goroutines keep the scheduler busy</span>
	<span class="token punctuation">}</span>
	mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	gp <span class="token operator">:=</span> mp<span class="token punctuation">.</span>curg
	status <span class="token operator">:=</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
	<span class="token keyword">if</span> status <span class="token operator">!=</span> _Grunning <span class="token operator">&amp;&amp;</span> status <span class="token operator">!=</span> _Gscanrunning <span class="token punctuation">{</span>
		<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&quot;gopark: bad g status&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	mp<span class="token punctuation">.</span>waitlock <span class="token operator">=</span> lock
	mp<span class="token punctuation">.</span>waitunlockf <span class="token operator">=</span> unlockf
	gp<span class="token punctuation">.</span>waitreason <span class="token operator">=</span> reason
	mp<span class="token punctuation">.</span>waittraceev <span class="token operator">=</span> traceEv
	mp<span class="token punctuation">.</span>waittraceskip <span class="token operator">=</span> traceskip
	<span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
	<span class="token comment">// can't do anything that might move the G between Ms here.</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>park_m<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token function">park_m</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>
		<span class="token function">traceGoPark</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waittraceev<span class="token punctuation">,</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waittraceskip<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
 
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span>
	<span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
	<span class="token keyword">if</span> fn <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitunlockf<span class="token punctuation">;</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		ok <span class="token operator">:=</span> <span class="token function">fn</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitlock<span class="token punctuation">)</span>
		_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitunlockf <span class="token operator">=</span> <span class="token boolean">nil</span>
		_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>waitlock <span class="token operator">=</span> <span class="token boolean">nil</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
			<span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span>
				<span class="token function">traceGoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
			<span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// Schedule it back, never returns.</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p><code>runtime.mcall</code> 方法我们在前面已经介绍过，它主要的工作就是是从当前 goroutine 切换回 g0 的系统堆栈，然后调用 fn(g)，而此时 <code>runtime.mcall</code> 调用执行的是 <code>runtime.park_m</code>，这个方法里会利用 CAS 把当前运行的 goroutine -- gp 的状态 从 <code>_Grunning</code> 切换到 <code>_Gwaiting</code>，表明该 goroutine 已进入到等待唤醒状态，此时封存和休眠 G 的操作就完成了，只需等待就绪之后被重新唤醒执行即可。最后调用 <code>runtime.schedule()</code> 再次进入调度循环，去执行下一个 goroutine，充分利用 CPU。</p> <p>至此，我们完成了对 Go netpoller 原理剖析的整个闭环。</p> <h2 id="go-netpoller-的问题"><a href="#go-netpoller-的问题" class="header-anchor">#</a> Go netpoller 的问题</h2> <p>Go netpoller 的设计不可谓不精巧、性能也不可谓不高，配合 goroutine 开发网络应用的时候就一个字：爽。因此 Go 的网络编程模式是及其简洁高效的，然而，没有任何一种设计和架构是完美的， <code>goroutine-per-connection</code> 这种模式虽然简单高效，但是在某些极端的场景下也会暴露出问题：goroutine 虽然非常轻量，它的自定义栈内存初始值仅为 2KB，后面按需扩容；海量连接的业务场景下， <code>goroutine-per-connection</code> ，此时 goroutine 数量以及消耗的资源就会呈线性趋势暴涨，虽然 Go scheduler 内部做了 g 的缓存链表，可以一定程度上缓解高频创建销毁 goroutine 的压力，但是对于瞬时性暴涨的长连接场景就无能为力了，大量的 goroutines 会被不断创建出来，从而对 Go runtime scheduler 造成极大的调度压力和侵占系统资源，然后资源被侵占又反过来影响 Go scheduler 的调度，进而导致性能下降。</p> <h2 id="reactor-网络模型"><a href="#reactor-网络模型" class="header-anchor">#</a> Reactor 网络模型</h2> <p>目前 Linux 平台上主流的高性能网络库/框架中，大都采用 Reactor 模式，比如 netty、libevent、libev、ACE，POE(Perl)、Twisted(Python)等。</p> <p>Reactor 模式本质上指的是使用 <code>I/O 多路复用(I/O multiplexing) + 非阻塞 I/O(non-blocking I/O)</code> 的模式。</p> <p>通常设置一个主线程负责做 event-loop 事件循环和 I/O 读写，通过 select/poll/epoll_wait 等系统调用监听 I/O 事件，业务逻辑提交给其他工作线程去做。而所谓『非阻塞 I/O』的核心思想是指避免阻塞在 read() 或者 write() 或者其他的 I/O 系统调用上，这样可以最大限度的复用 event-loop 线程，让一个线程能服务于多个 sockets。在 Reactor 模式中，I/O 线程只能阻塞在 I/O multiplexing 函数上（select/poll/epoll_wait）。</p> <p>Reactor 模式的基本工作流程如下：</p> <ul><li>Server 端完成在 <code>bind&amp;listen</code> 之后，将 listenfd 注册到 epollfd 中，最后进入 event-loop 事件循环。循环过程中会调用 <code>select/poll/epoll_wait</code> 阻塞等待，若有在 listenfd 上的新连接事件则解除阻塞返回，并调用 <code>socket.accept</code> 接收新连接 connfd，并将 connfd 加入到 epollfd 的 I/O 复用（监听）队列。</li> <li>当 connfd 上发生可读/可写事件也会解除 <code>select/poll/epoll_wait</code> 的阻塞等待，然后进行 I/O 读写操作，这里读写 I/O 都是非阻塞 I/O，这样才不会阻塞 event-loop 的下一个循环。然而，这样容易割裂业务逻辑，不易理解和维护。</li> <li>调用 <code>read</code> 读取数据之后进行解码并放入队列中，等待工作线程处理。</li> <li>工作线程处理完数据之后，返回到 event-loop 线程，由这个线程负责调用 <code>write</code> 把数据写回 client。</li></ul> <p>accept 连接以及 conn 上的读写操作若是在主线程完成，则要求是非阻塞 I/O，因为 Reactor 模式一条最重要的原则就是：I/O 操作不能阻塞 event-loop 事件循环。<strong>实际上 event loop 可能也可以是多线程的，只是一个线程里只有一个 select/poll/epoll_wait</strong>。</p> <p>上面提到了 Go netpoller 在某些场景下可能因为创建太多的 goroutine 而过多地消耗系统资源，而在现实世界的网络业务中，服务器持有的海量连接中在极短的时间窗口内只有极少数是 active 而大多数则是 idle，就像这样（非真实数据，仅仅是为了比喻）：</p> <p><img src="/images/go/netpoll/conn-rate.png" alt="img"></p> <p>那么为每一个连接指派一个 goroutine 就显得太过奢侈了，而 Reactor 模式这种利用 I/O 多路复用进而只需要使用少量线程即可管理海量连接的设计就可以在这样网络业务中大显身手了：</p> <p><img src="/images/go/netpoll/multi-reactors.png" alt="MultiReactors.png"></p> <p>在绝大部分应用场景下，我推荐大家还是遵循 Go 的 best practices，使用原生的 Go 网络库来构建自己的网络应用。然而，在某些极度追求性能、压榨系统资源以及技术栈必须是原生 Go （不考虑 C/C++ 写中间层而 Go 写业务层）的业务场景下，我们可以考虑自己构建 Reactor 网络模型。</p> <h2 id="gnet"><a href="#gnet" class="header-anchor">#</a> gnet</h2> <p><a href="https://gnet.host/" target="_blank" rel="noopener noreferrer">gnet<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是一个基于事件驱动的高性能和轻量级网络框架。它直接使用 <a href="https://en.wikipedia.org/wiki/Epoll" target="_blank" rel="noopener noreferrer">epoll<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://en.wikipedia.org/wiki/Kqueue" target="_blank" rel="noopener noreferrer">kqueue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 系统调用而非标准 Go 网络包：<a href="https://golang.org/pkg/net/" target="_blank" rel="noopener noreferrer">net<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来构建网络应用，它的工作原理类似两个开源的网络库：<a href="https://github.com/netty/netty" target="_blank" rel="noopener noreferrer">netty<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://github.com/libuv/libuv" target="_blank" rel="noopener noreferrer">libuv<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，这也使得<code>gnet</code> 达到了一个远超 Go <a href="https://golang.org/pkg/net/" target="_blank" rel="noopener noreferrer">net<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的性能表现。</p> <p><code>gnet</code> 设计开发的初衷不是为了取代 Go 的标准网络库：<a href="https://golang.org/pkg/net/" target="_blank" rel="noopener noreferrer">net<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，而是为了创造出一个类似于 <a href="http://redis.io/" target="_blank" rel="noopener noreferrer">Redis<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="http://www.haproxy.org/" target="_blank" rel="noopener noreferrer">Haproxy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 能高效处理网络包的 Go 语言网络服务器框架。</p> <p><code>gnet</code> 的卖点在于它是一个高性能、轻量级、非阻塞的纯 Go 实现的传输层（TCP/UDP/Unix Domain Socket）网络框架，开发者可以使用 <code>gnet</code> 来实现自己的应用层网络协议(HTTP、RPC、Redis、WebSocket 等等)，从而构建出自己的应用层网络应用：比如在 <code>gnet</code> 上实现 HTTP 协议就可以创建出一个 HTTP 服务器 或者 Web 开发框架，实现 Redis 协议就可以创建出自己的 Redis 服务器等等。</p> <p><a href="https://github.com/panjf2000/gnet" target="_blank" rel="noopener noreferrer">gnet<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，在某些极端的网络业务场景，比如海量连接、高频短连接、网络小包等等场景，<a href="https://github.com/panjf2000/gnet" target="_blank" rel="noopener noreferrer">gnet<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 在性能和资源占用上都远超 Go 原生的 <a href="https://golang.org/pkg/net/" target="_blank" rel="noopener noreferrer">net<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包（基于 netpoller）。</p> <p><code>gnet</code> 已经实现了 <code>Multi-Reactors</code> 和 <code>Multi-Reactors + Goroutine Pool</code> 两种网络模型，也得益于这些网络模型，使得 <code>gnet</code> 成为一个高性能和低损耗的 Go 网络框架：</p> <p><img src="/images/go/netpoll/multi-reactors.png" alt="MultiReactors.png"></p> <p><img src="/images/go/netpoll/multi-reactors-thread-pool.png" alt="multireactorsthreadpool.png"></p></div></div> <div class="page-slot page-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script></br><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="auto"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="7043271566"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Golang" title="标签">#Golang</a><a href="/tags/?tag=GMP" title="标签">#GMP</a><a href="/tags/?tag=epoll" title="标签">#epoll</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/9/2023</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/golang/go-block/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Go什么时候发生阻塞？阻塞时，调度器会怎么做？</div></a> <a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Goroutine 泄露 - 被遗忘的发送者</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/golang/go-block/" class="prev">Go什么时候发生阻塞？阻塞时，调度器会怎么做？</a></span> <span class="next"><a href="/pages/golang/goroutine-leaks-the-forgotten-sender/">Goroutine 泄露 - 被遗忘的发送者</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/mosquito-config-ws/"><div>
            mosquito配置ws协议
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/pip-download-offline/"><div>
            Pip包的离线下载和安装
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/favorites/sd/"><div>
            stable diffusion 相关收藏
            <!----></div></a> <span class="date">02-24</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/moxiaolong" title="Star我" target="_blank" class="iconfont icon-github"></a><a href="http://music.163.com/playlist?id=8444337" title="有品位的歌单" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2024
    <span>Dra-M</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bc3c2a75.js" defer></script><script src="/assets/js/2.472001a0.js" defer></script><script src="/assets/js/30.a93d8117.js" defer></script>
  </body>
</html>
