<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入理解 go reflect - 反射基本原理 | Dra-M</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/logo.webp">
    <link rel="manifest" href="/manifest.json">
    <script data-ad-client="ca-pub-8621788234752924" defer="true" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924" crossorigin="anonymous"></script>
    <meta name="description" content="一些技术(前端、后端、运维)相关的经验、随想、资源收藏，和一些哲学随想。">
    <meta name="keywords" content="开发技术,哲学,DragonMo,Dra-M,莫小龙">
    <meta name="theme-color" content="#7b074b">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    
    <link rel="preload" href="/assets/css/0.styles.8ee39092.css" as="style"><link rel="preload" href="/assets/js/app.bc3c2a75.js" as="script"><link rel="preload" href="/assets/js/2.472001a0.js" as="script"><link rel="preload" href="/assets/js/42.895064c8.js" as="script"><link rel="prefetch" href="/assets/js/10.da818c35.js"><link rel="prefetch" href="/assets/js/100.c9dc513a.js"><link rel="prefetch" href="/assets/js/101.f3685f69.js"><link rel="prefetch" href="/assets/js/102.98577fde.js"><link rel="prefetch" href="/assets/js/103.401885da.js"><link rel="prefetch" href="/assets/js/104.5ca2a2ba.js"><link rel="prefetch" href="/assets/js/105.896bd937.js"><link rel="prefetch" href="/assets/js/106.199efe2c.js"><link rel="prefetch" href="/assets/js/107.206ba497.js"><link rel="prefetch" href="/assets/js/108.c1eb4655.js"><link rel="prefetch" href="/assets/js/109.221866e5.js"><link rel="prefetch" href="/assets/js/11.a6aff4f5.js"><link rel="prefetch" href="/assets/js/110.e3239981.js"><link rel="prefetch" href="/assets/js/111.ef06b5a1.js"><link rel="prefetch" href="/assets/js/112.ccf225d6.js"><link rel="prefetch" href="/assets/js/113.8d8640b2.js"><link rel="prefetch" href="/assets/js/114.056f749a.js"><link rel="prefetch" href="/assets/js/115.ed35567d.js"><link rel="prefetch" href="/assets/js/116.29426a1f.js"><link rel="prefetch" href="/assets/js/117.86847b2b.js"><link rel="prefetch" href="/assets/js/118.885246c5.js"><link rel="prefetch" href="/assets/js/119.6b04ff26.js"><link rel="prefetch" href="/assets/js/12.dd3a474e.js"><link rel="prefetch" href="/assets/js/120.99542ea6.js"><link rel="prefetch" href="/assets/js/121.c89b2199.js"><link rel="prefetch" href="/assets/js/122.b4c96f13.js"><link rel="prefetch" href="/assets/js/123.e74abe64.js"><link rel="prefetch" href="/assets/js/124.5479e5ef.js"><link rel="prefetch" href="/assets/js/125.47f5d91e.js"><link rel="prefetch" href="/assets/js/126.2eda5054.js"><link rel="prefetch" href="/assets/js/127.fbf8b987.js"><link rel="prefetch" href="/assets/js/128.3bb898fe.js"><link rel="prefetch" href="/assets/js/129.59014c61.js"><link rel="prefetch" href="/assets/js/13.2d318d3d.js"><link rel="prefetch" href="/assets/js/130.b5701dcd.js"><link rel="prefetch" href="/assets/js/131.af42802d.js"><link rel="prefetch" href="/assets/js/132.a0a52815.js"><link rel="prefetch" href="/assets/js/133.c7f6fcd9.js"><link rel="prefetch" href="/assets/js/134.1fa00d40.js"><link rel="prefetch" href="/assets/js/135.1c93b5ec.js"><link rel="prefetch" href="/assets/js/136.ce22005d.js"><link rel="prefetch" href="/assets/js/137.d689e32c.js"><link rel="prefetch" href="/assets/js/138.52557618.js"><link rel="prefetch" href="/assets/js/139.5576ce4a.js"><link rel="prefetch" href="/assets/js/14.41100292.js"><link rel="prefetch" href="/assets/js/140.3becc2ed.js"><link rel="prefetch" href="/assets/js/141.60103e1a.js"><link rel="prefetch" href="/assets/js/142.f44d458d.js"><link rel="prefetch" href="/assets/js/143.5a60f54e.js"><link rel="prefetch" href="/assets/js/144.ce362fab.js"><link rel="prefetch" href="/assets/js/145.f4d3209c.js"><link rel="prefetch" href="/assets/js/146.f90aee50.js"><link rel="prefetch" href="/assets/js/15.daabeb64.js"><link rel="prefetch" href="/assets/js/16.a4a3b21c.js"><link rel="prefetch" href="/assets/js/17.8b6cce9b.js"><link rel="prefetch" href="/assets/js/18.60b289d4.js"><link rel="prefetch" href="/assets/js/19.0c18504f.js"><link rel="prefetch" href="/assets/js/20.7a975e23.js"><link rel="prefetch" href="/assets/js/21.3329c224.js"><link rel="prefetch" href="/assets/js/22.5df3725f.js"><link rel="prefetch" href="/assets/js/23.1e2b6c8a.js"><link rel="prefetch" href="/assets/js/24.aac0154b.js"><link rel="prefetch" href="/assets/js/25.b26ee63b.js"><link rel="prefetch" href="/assets/js/26.6b63d3fb.js"><link rel="prefetch" href="/assets/js/27.8b487354.js"><link rel="prefetch" href="/assets/js/28.731619d6.js"><link rel="prefetch" href="/assets/js/29.4fe59357.js"><link rel="prefetch" href="/assets/js/3.6dd7c6e7.js"><link rel="prefetch" href="/assets/js/30.a93d8117.js"><link rel="prefetch" href="/assets/js/31.42cc0c6c.js"><link rel="prefetch" href="/assets/js/32.67d8d455.js"><link rel="prefetch" href="/assets/js/33.da390ef3.js"><link rel="prefetch" href="/assets/js/34.47f5bc34.js"><link rel="prefetch" href="/assets/js/35.bb95ae18.js"><link rel="prefetch" href="/assets/js/36.79ce5ff9.js"><link rel="prefetch" href="/assets/js/37.e48e5b35.js"><link rel="prefetch" href="/assets/js/38.05c111ca.js"><link rel="prefetch" href="/assets/js/39.a9c4a557.js"><link rel="prefetch" href="/assets/js/4.76079b7d.js"><link rel="prefetch" href="/assets/js/40.45a45204.js"><link rel="prefetch" href="/assets/js/41.978ccffc.js"><link rel="prefetch" href="/assets/js/43.c9b2330d.js"><link rel="prefetch" href="/assets/js/44.114f4169.js"><link rel="prefetch" href="/assets/js/45.5a1432cf.js"><link rel="prefetch" href="/assets/js/46.cce4db9a.js"><link rel="prefetch" href="/assets/js/47.b9ba2714.js"><link rel="prefetch" href="/assets/js/48.2e84c7f6.js"><link rel="prefetch" href="/assets/js/49.77f31886.js"><link rel="prefetch" href="/assets/js/5.13679220.js"><link rel="prefetch" href="/assets/js/50.70b8a00f.js"><link rel="prefetch" href="/assets/js/51.8f3d4e26.js"><link rel="prefetch" href="/assets/js/52.a0dff1b5.js"><link rel="prefetch" href="/assets/js/53.1a5d0aa9.js"><link rel="prefetch" href="/assets/js/54.d9b622f7.js"><link rel="prefetch" href="/assets/js/55.a078dc68.js"><link rel="prefetch" href="/assets/js/56.5a331510.js"><link rel="prefetch" href="/assets/js/57.5bec8258.js"><link rel="prefetch" href="/assets/js/58.21fe4b06.js"><link rel="prefetch" href="/assets/js/59.53211a94.js"><link rel="prefetch" href="/assets/js/6.738f6e32.js"><link rel="prefetch" href="/assets/js/60.1d1893dd.js"><link rel="prefetch" href="/assets/js/61.2dd0ba1c.js"><link rel="prefetch" href="/assets/js/62.4df81247.js"><link rel="prefetch" href="/assets/js/63.e7645407.js"><link rel="prefetch" href="/assets/js/64.c1510d68.js"><link rel="prefetch" href="/assets/js/65.e80f3f86.js"><link rel="prefetch" href="/assets/js/66.705d839b.js"><link rel="prefetch" href="/assets/js/67.852e9ce9.js"><link rel="prefetch" href="/assets/js/68.67fbda7f.js"><link rel="prefetch" href="/assets/js/69.7a78efb2.js"><link rel="prefetch" href="/assets/js/7.48b86259.js"><link rel="prefetch" href="/assets/js/70.9fc82048.js"><link rel="prefetch" href="/assets/js/71.ab52b5cf.js"><link rel="prefetch" href="/assets/js/72.e7c7a340.js"><link rel="prefetch" href="/assets/js/73.539e40a1.js"><link rel="prefetch" href="/assets/js/74.598221c8.js"><link rel="prefetch" href="/assets/js/75.876e901b.js"><link rel="prefetch" href="/assets/js/76.42349440.js"><link rel="prefetch" href="/assets/js/77.5834f7c5.js"><link rel="prefetch" href="/assets/js/78.78c797f4.js"><link rel="prefetch" href="/assets/js/79.5d0d35ae.js"><link rel="prefetch" href="/assets/js/8.10c02f71.js"><link rel="prefetch" href="/assets/js/80.e7bc8390.js"><link rel="prefetch" href="/assets/js/81.e4e4f6a8.js"><link rel="prefetch" href="/assets/js/82.98057949.js"><link rel="prefetch" href="/assets/js/83.ad7dd690.js"><link rel="prefetch" href="/assets/js/84.0f7a664d.js"><link rel="prefetch" href="/assets/js/85.378369eb.js"><link rel="prefetch" href="/assets/js/86.01ead6d0.js"><link rel="prefetch" href="/assets/js/87.70598ba5.js"><link rel="prefetch" href="/assets/js/88.600910d8.js"><link rel="prefetch" href="/assets/js/89.c783c1e2.js"><link rel="prefetch" href="/assets/js/9.4b59881c.js"><link rel="prefetch" href="/assets/js/90.85995a12.js"><link rel="prefetch" href="/assets/js/91.21e9dbf9.js"><link rel="prefetch" href="/assets/js/92.8fc80426.js"><link rel="prefetch" href="/assets/js/93.6d7adcc8.js"><link rel="prefetch" href="/assets/js/94.6147d1d9.js"><link rel="prefetch" href="/assets/js/95.61c3d1ab.js"><link rel="prefetch" href="/assets/js/96.1dc4b4c8.js"><link rel="prefetch" href="/assets/js/97.c4c52395.js"><link rel="prefetch" href="/assets/js/98.b78d3e0f.js"><link rel="prefetch" href="/assets/js/99.f1c7ba9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ee39092.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.webp" alt="Dra-M" class="logo"> <span class="site-name can-hide">Dra-M</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://q1.qlogo.cn/g?b=qq&amp;nk=975425198&amp;s=640"> <div class="blogger-info"><h3>莫小龙</h3> <span>保持理智，相信未来。</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/code/" class="nav-link">技术</a></div><div class="nav-item"><a href="/idea/" class="nav-link">冥思</a></div><div class="nav-item"><a href="/philosophia/" class="nav-link">哲学</a></div><div class="nav-item"><a href="/favorites/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/moxiaolong" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Golang</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/golang-gitlab-ssh/" class="sidebar-link">GitLab私服+Go Modules踩坑经验（SSH自定义端口）</a></li><li><a href="/pages/gin/middle/" class="sidebar-link">【代码片段】我使用的Gin中间处理器（自定义异常处理、日志打印、traceId、跨域配置）</a></li><li><a href="/pages/java-to-golang/value-and-reference/" class="sidebar-link">【Java转Go】如何理解Go中的值类型、引用类型、nil</a></li><li><a href="/pages/java-to-golang/oop/" class="sidebar-link">【Java转Go】如何理解面向对象，怎么把Golang用成面向对象的样子</a></li><li><a href="/pages/golang/gmp/" class="sidebar-link">Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="/pages/golang/go-gmp-status/" class="sidebar-link">Go中GMP有哪些状态？</a></li><li><a href="/pages/golang/go-gc/" class="sidebar-link">一文搞懂go gc垃圾回收原理</a></li><li><a href="/pages/golang/go-block/" class="sidebar-link">Go什么时候发生阻塞？阻塞时，调度器会怎么做？</a></li><li><a href="/pages/golang/go-netpoll-io-multiplexing-reactor/" class="sidebar-link">Go netpoller 原生网络模型之源码全面揭秘</a></li><li><a href="/pages/golang/goroutine-leaks-the-forgotten-sender/" class="sidebar-link">Goroutine 泄露 - 被遗忘的发送者</a></li><li><a href="/pages/golang/go-map/" class="sidebar-link">go map 设计与实现</a></li><li><a href="/pages/golang/go-slice/" class="sidebar-link">go slice 设计与实现</a></li><li><a href="/pages/golang/go-context/" class="sidebar-link">小白也能看懂的context包详解：从入门到精通</a></li><li><a href="/pages/golang/go-interface/" class="sidebar-link">go interface 设计与实现</a></li><li><a href="/pages/golang/go-chan/" class="sidebar-link">深入理解 go chan</a></li><li><a href="/pages/golang/go-chan-design-and-implementation/" class="sidebar-link">go chan 设计与实现</a></li><li><a href="/pages/golang/go-mutex/" class="sidebar-link">深入理解 go Mutex</a></li><li><a href="/pages/golang/go-sync-map-1/" class="sidebar-link">深入理解 go sync.Map - 基本原理</a></li><li><a href="/pages/golang/go-sync-map-2/" class="sidebar-link">go sync.Map 设计与实现</a></li><li><a href="/pages/golang/go-sync-once/" class="sidebar-link">深入理解 go sync.Once</a></li><li><a href="/pages/golang/go-reflect-1/" aria-current="page" class="active sidebar-link">深入理解 go reflect - 反射基本原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#反射基础-go-的-interface-是怎么存储的" class="sidebar-link">反射基础 - go 的 interface 是怎么存储的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#反射对象-reflect-type-和-reflect-value" class="sidebar-link">反射对象 - reflect.Type 和 reflect.Value</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#反射定律" class="sidebar-link">反射定律</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#反射可以将-interface-类型变量转换成反射对象。" class="sidebar-link">反射可以将 interface 类型变量转换成反射对象。</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#反射可以将反射对象还原成-interface-对象。" class="sidebar-link">反射可以将反射对象还原成 interface 对象。</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#如果要修改反射对象-那么反射对象必须是可设置的-canset-。" class="sidebar-link">如果要修改反射对象，那么反射对象必须是可设置的（CanSet）。</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#elem-方法" class="sidebar-link">Elem 方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#reflect-value-的-elem-方法" class="sidebar-link">reflect.Value 的 Elem 方法</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#reflect-type-的-elem-方法" class="sidebar-link">reflect.Type 的 Elem 方法</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#interface-方法" class="sidebar-link">Interface 方法</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#kind" class="sidebar-link">Kind</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#addressable" class="sidebar-link">addressable</a></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#获取类型信息-reflect-type" class="sidebar-link">获取类型信息 - reflect.Type</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#通用的-type-方法" class="sidebar-link">通用的 Type 方法</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#某些类型特定的-type-方法" class="sidebar-link">某些类型特定的 Type 方法</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#创建-reflect-type-的方式" class="sidebar-link">创建 reflect.Type 的方式</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#获取值信息-reflect-value" class="sidebar-link">获取值信息 - reflect.Value</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#概述-2" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#reflect-value-的方法" class="sidebar-link">reflect.Value 的方法</a></li><li class="sidebar-sub-header level3"><a href="/pages/golang/go-reflect-1/#创建-reflect-value-的方式" class="sidebar-link">创建 reflect.Value 的方式</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/golang/go-reflect-1/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/pages/golang/go-reflect-2/" class="sidebar-link">深入理解 go reflect - 要不要传指针</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程思想</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运维</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script><ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="8498052873"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/code/#技术" data-v-06225672>技术</a></li><li data-v-06225672><a href="/code/#Golang" data-v-06225672>Golang</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://juejin.cn/post/7183132625580605498" target="_blank" title="作者" class="beLink" data-v-06225672>eleven26</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-08-09</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="/img/dragon/4.webp">深入理解 go reflect - 反射基本原理<!----></h1>  <div class="theme-vdoing-content content__default"><p><strong>反射</strong>是这样一种机制，它是可以让我们在程序运行时（runtime）访问、检测和修改对象本身状态或行为的一种能力。 比如，从一个变量推断出其类型信息、以及存储的数据的一些信息，又或者获取一个对象有什么方法可以调用等。 反射经常用在一些需要同时处理不同类型变量的地方，比如序列化、反序列化、<code>ORM</code> 等等，如标准库里面的 <code>json.Marshal</code>。
</p> <h2 id="反射基础-go-的-interface-是怎么存储的"><a href="#反射基础-go-的-interface-是怎么存储的" class="header-anchor">#</a> 反射基础 - go 的 interface 是怎么存储的？</h2> <p>在正式开始讲解反射之前，我们有必要了解一下 go 里的接口（<code>interface</code>）是怎么存储的。 关于这个问题，在我的另外一篇文章中已经做了很详细的讲解 <a href="/pages/golang/go-interface">go interface 设计与实现</a>， 这里不再赘述。但还是简单说一下，go 的接口是由两部分组成的，一部分是类型信息，另一部分是数据信息，如：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">var</span> b <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> a
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对于这个例子，<code>b</code> 的类型信息是 <code>int</code>，数据信息是 <code>1</code>，这两部分信息都是存储在 <code>b</code> 里面的。<code>b</code> 的内存结构如下：</p> <p><img src="/images/go/reflect1/1.webp" alt="reflect_1.png"></p> <p>在上图中，<code>b</code> 的类型实际上是 <code>eface</code>，它是一个空接口，它的定义如下：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">type</span> eface <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    _type <span class="token operator">*</span>_type
    data  unsafe<span class="token punctuation">.</span>Pointer
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>也就是说，<strong>一个 interface{} 中实际上既包含了变量的类型信息，也包含了类型的数据。</strong> 正因为如此，我们才可以通过反射来获取到变量的类型信息，以及变量的数据信息。</p> <h2 id="反射对象-reflect-type-和-reflect-value"><a href="#反射对象-reflect-type-和-reflect-value" class="header-anchor">#</a> 反射对象 - reflect.Type 和 reflect.Value</h2> <p>知道了 <code>interface{}</code> 的内存结构之后，我们就可以开始讲解反射了。反射的核心是两个对象，分别是 <code>reflect.Type</code> 和 <code>reflect.Value</code>。 它们分别代表了 go 语言中的类型和值。我们可以通过 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 来获取到一个变量的类型和值。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
t <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span>
t1 <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们去看一下 <code>TypeOf</code> 和 <code>ValueOf</code> 的源码会发现，这两个方法都接收一个 <code>interface{}</code> 类型的参数，然后返回一个 <code>reflect.Type</code> 和 <code>reflect.Value</code> 类型的值。这也就是为什么我们可以通过 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 来获取到一个变量的类型和值的原因。</p> <p><img src="/images/go/reflect1/2.webp" alt="reflect_2.png"></p> <h2 id="反射定律"><a href="#反射定律" class="header-anchor">#</a> 反射定律</h2> <p>在 go 官方博客中关于反射的文章 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.dev%2Fblog%2Flaws-of-reflection" target="_blank" rel="noopener noreferrer">laws-of-reflection<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中，提到了三条反射定律：</p> <ol><li>反射可以将 <code>interface</code> 类型变量转换成反射对象。</li> <li>反射可以将反射对象还原成 <code>interface</code> 对象。</li> <li>如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</li></ol> <p>关于这三条定律，官方博客已经有了比较完整的阐述，感兴趣的可以去看一下官方博客的文章。这里简单阐述一下：</p> <h3 id="反射可以将-interface-类型变量转换成反射对象。"><a href="#反射可以将-interface-类型变量转换成反射对象。" class="header-anchor">#</a> 反射可以将 <code>interface</code> 类型变量转换成反射对象。</h3> <p>其实也就是上面的 <code>reflect.Type</code> 和 <code>reflect.Value</code>，我们可以通过 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 来获取到一个变量的反射类型和反射值。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
typeOfA <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
valueOfA <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="反射可以将反射对象还原成-interface-对象。"><a href="#反射可以将反射对象还原成-interface-对象。" class="header-anchor">#</a> 反射可以将反射对象还原成 <code>interface</code> 对象。</h3> <p>我们可以通过 <code>reflect.Value.Interface</code> 来获取到反射对象的 <code>interface</code> 对象，也就是传递给 <code>reflect.ValueOf</code> 的那个变量本身。 不过返回值类型是 <code>interface{}</code>，所以我们需要进行类型断言。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>i <span class="token operator">:=</span> valueOfA<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="如果要修改反射对象-那么反射对象必须是可设置的-canset-。"><a href="#如果要修改反射对象-那么反射对象必须是可设置的-canset-。" class="header-anchor">#</a> 如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</h3> <p>我们可以通过 <code>reflect.Value.CanSet</code> 来判断一个反射对象是否是可设置的。如果是可设置的，我们就可以通过 <code>reflect.Value.Set</code> 来修改反射对象的值。 这其实也是非常场景的使用反射的一个场景，通过反射来修改变量的值。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> x <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">3.4</span>
v <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;settability of v:&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">CanSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;settability of v:&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CanSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>那什么情况下一个反射对象是可设置的呢？前提是这个反射对象是一个指针，然后这个指针指向的是一个可设置的变量。 在我们传递一个值给 <code>reflect.ValueOf</code> 的时候，如果这个值只是一个普通的变量，那么 <code>reflect.ValueOf</code> 会返回一个不可设置的反射对象。 因为这个值实际上被拷贝了一份，我们如果通过反射修改这个值，那么实际上是修改的这个拷贝的值，而不是原来的值。 所以 go 语言在这里做了一个限制，如果我们传递进 <code>reflect.ValueOf</code> 的变量是一个普通的变量，那么在我们设置反射对象的值的时候，会报错。 所以在上面这个例子中，我们传递了 <code>x</code> 的指针变量作为参数。这样，运行时就可以找到 <code>x</code> 本身，而不是 <code>x</code> 的拷贝，所以就可以修改 <code>x</code> 的值了。</p> <p>但同时我们也注意到了，在上面这个例子中，<code>v.CanSet()</code> 返回的是 <code>false</code>，而 <code>v.Elem().CanSet()</code> 返回的是 <code>true</code>。 这是因为，<code>v</code> 是一个指针，而 <code>v.Elem()</code> 是指针指向的值，对于这个指针本身，我们修改它是没有意义的，我们可以设想一下， 如果我们修改了指针变量（也就是修改了指针变量指向的地址），那会发生什么呢？那样我们的指针变量就不是指向 <code>x</code> 了， 而是指向了其他的变量，这样就不符合我们的预期了。所以 <code>v.CanSet()</code> 返回的是 <code>false</code>。</p> <p>而 <code>v.Elem().CanSet()</code> 返回的是 <code>true</code>。这是因为 <code>v.Elem()</code> 才是 <code>x</code> 本身，通过 <code>v.Elem()</code> 修改 <code>x</code> 的值是没有问题的。</p> <p><img src="/images/go/reflect1/3.webp" alt="reflect_3.png"></p> <h2 id="elem-方法"><a href="#elem-方法" class="header-anchor">#</a> Elem 方法</h2> <p>不知道有多少读者和我一样，在初次使用 go 的反射的时候，被 <code>Elem</code> 这个方法搞得一头雾水。 <code>Elem</code> 方法的作用是什么呢？在回答这个问题之前，我们需要明确一点：<code>reflect.Value</code> 和 <code>reflect.Type</code> 这两个反射对象都有 <code>Elem</code> 方法，既然是不同的对象，那么它们的作用自然是不一样的。</p> <h3 id="reflect-value-的-elem-方法"><a href="#reflect-value-的-elem-方法" class="header-anchor">#</a> reflect.Value 的 Elem 方法</h3> <p><code>reflect.Value</code> 的 <code>Elem</code> 方法的作用是<strong>获取指针指向的值，或者获取接口的动态值</strong>。也就是说，能调用 <code>Elem</code> 方法的反射对象，必须是一个指针或者一个接口。 在使用其他类型的 <code>reflect.Value</code> 来调用 <code>Elem</code> 方法的时候，会 <code>panic</code>:</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// panic: reflect: call of reflect.Value.Elem on int Value</span>
reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 不报错</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>a
reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>对于指针很好理解，其实作用类似解引用。而对于接口，还是要回到 <code>interface</code> 的结构本身，因为接口里包含了类型和数据本身，所以 <code>Elem</code> 方法就是获取接口的数据部分（也就是 <code>iface</code> 或 <code>eface</code> 中的 <code>data</code> 字段）。</p> <p>指针类型：</p> <p><img src="/images/go/reflect1/4.webp" alt="reflect_4.png"></p> <p>接口类型：</p> <p><img src="/images/go/reflect1/5.webp" alt="reflect_5.png"></p> <h3 id="reflect-type-的-elem-方法"><a href="#reflect-type-的-elem-方法" class="header-anchor">#</a> reflect.Type 的 Elem 方法</h3> <p><code>reflect.Type</code> 的 <code>Elem</code> 方法的作用是<strong>获取数组、chan、map、指针、切片关联元素的类型信息</strong>，也就是说，对于 <code>reflect.Type</code> 来说， 能调用 <code>Elem</code> 方法的反射对象，必须是<strong>数组、chan、map、指针、切片中的一种</strong>，其他类型的 <code>reflect.Type</code> 调用 <code>Elem</code> 方法会 <code>panic</code>。</p> <p>示例：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>t1 <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 数组 [3]int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [3]int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// int</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>需要注意的是，如果我们要获取 map 类型 key 的类型信息，需要使用 <code>Key</code> 方法，而不是 <code>Elem</code> 方法。</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
t1 <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// string</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="interface-方法"><a href="#interface-方法" class="header-anchor">#</a> Interface 方法</h2> <p>这也是非常常用的一个方法，<code>reflect.Value</code> 的 <code>Interface</code> 方法的作用是<strong>获取反射对象的动态值</strong>。 也就是说，如果反射对象是一个指针，那么 <code>Interface</code> 方法会返回指针指向的值。</p> <p>简单来说，如果 <code>var i interface{} = x</code>，那么 <code>reflect.ValueOf(x).Interface()</code> 就是 <code>i</code> 本身，只不过其类型是 <code>interface{}</code> 类型。</p> <h2 id="kind"><a href="#kind" class="header-anchor">#</a> Kind</h2> <p>说到反射，不得不提的另外一个话题就是 go 的类型系统，对于开发者来说，我们可以基于基本类型来定义各种新的类型，如：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Kind 是 int</span>
<span class="token keyword">type</span> myIny <span class="token builtin">int</span>
<span class="token comment">// Kind 是 Struct</span>
<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Name <span class="token builtin">string</span>
    Age <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>但是不管我们定义了多少种类型，在 go 看来都是下面的基本类型中的一个：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">type</span> Kind <span class="token builtin">uint</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
   Invalid Kind <span class="token operator">=</span> <span class="token boolean">iota</span>
   Bool
   Int
   Int8
   Int16
   Int32
   Int64
   Uint
   Uint8
   Uint16
   Uint32
   Uint64
   Uintptr
   Float32
   Float64
   Complex64
   Complex128
   Array
   Chan
   Func
   Interface
   Map
   Pointer
   Slice
   String
   Struct
   UnsafePointer
<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>也就是说，我们定义的类型在 go 的类型系统中都是基本类型的一种，这个基本类型就是 <code>Kind</code>。 也正因为如此，我们可以通过<strong>有限的</strong> <code>reflect.Type</code> 的 <code>Kind</code> 来进行类型判断。 也就是说，我们在通过反射来判断变量的类型的时候，只需要枚举 <code>Kind</code> 中的类型，然后通过 <code>reflect.Type</code> 的 <code>Kind</code> 方法来判断即可。</p> <blockquote><p>Type 表示的是反射对象（Type 对象是某一个 Kind，通过 Kind() 方法可以获取 Type 的 Kind），Kind 表示的是 go 底层类型系统中的类型。</p></blockquote> <p>比如下面的例子：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">display</span><span class="token punctuation">(</span>path <span class="token builtin">string</span><span class="token punctuation">,</span> v reflect<span class="token punctuation">.</span>Value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">switch</span> v<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Invalid<span class="token punctuation">:</span>
      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s = invalid\n&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
   <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Slice<span class="token punctuation">,</span> reflect<span class="token punctuation">.</span>Array<span class="token punctuation">:</span>
      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
         <span class="token function">display</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">&quot;%s[%d]&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Struct<span class="token punctuation">:</span>
      <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
         fieldPath <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">&quot;%s.%s&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
         <span class="token function">display</span><span class="token punctuation">(</span>fieldPath<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Map<span class="token punctuation">:</span>
      <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> v<span class="token punctuation">.</span><span class="token function">MapKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">display</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">&quot;%s[%s]&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token function">formatAny</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">MapIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Pointer<span class="token punctuation">:</span>
      <span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">IsNil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s = nil\n&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token function">display</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">&quot;(*%s)&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Interface<span class="token punctuation">:</span>
      <span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">IsNil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s = nil\n&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s.type = %s\n&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token function">display</span><span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token string">&quot;.value&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
   <span class="token keyword">default</span><span class="token punctuation">:</span>
      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s = %s\n&quot;</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token function">formatAny</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><blockquote><p>我们在开发的时候非常常用的结构体，在 go 的类型系统中，通通都是 <code>Struct</code> 这种类型的。</p></blockquote> <h2 id="addressable"><a href="#addressable" class="header-anchor">#</a> addressable</h2> <p>go 反射中最后一个很重要的话题是 <code>addressable</code>。在 go 的反射系统中有两个关于寻址的方法：<code>CanAddr</code> 和 <code>CanSet</code>。</p> <p><code>CanAddr</code> 方法的作用是判断反射对象是否可以寻址，也就是说，如果 <code>CanAddr</code> 返回 <code>true</code>，那么我们就可以通过 <code>Addr</code> 方法来获取反射对象的地址。 如果 <code>CanAddr</code> 返回 <code>false</code>，那么我们就不能通过 <code>Addr</code> 方法来获取反射对象的地址。对于这种情况，我们就无法通过反射对象来修改变量的值。</p> <p>但是，<code>CanAddr</code> 是 <code>true</code> 并不是说 <code>reflect.Value</code> 一定就能修改变量的值了。 <code>reflect.Value</code> 还有一个方法 <code>CanSet</code>，只有 <code>CanSet</code> 返回 <code>true</code>，我们才能通过反射对象来修改变量的值。</p> <p>那么 <code>CanAddr</code> 背后的含义是什么呢？它意味着我们传递给 <code>reflect.ValueOf</code> 的变量是不是可以寻址的。 <strong>也就是说，我们的反射值对象拿到的是不是变量本身，而不是变量的副本。</strong> 如果我们是通过 <code>&amp;v</code> 这种方式来创建反射对象的，那么 <code>CanAddr</code> 就会返回 <code>true</code>， 反之，如果我们是通过 <code>v</code> 这种方式来创建反射对象的，那么 <code>CanAddr</code> 就会返回 <code>false</code>。</p> <p>如果想更详细的了解可以参考一下鸟窝的这篇文章 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcolobu.com%2F2018%2F02%2F27%2Fgo-addressable%2F" target="_blank" rel="noopener noreferrer">go addressable 详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="获取类型信息-reflect-type"><a href="#获取类型信息-reflect-type" class="header-anchor">#</a> 获取类型信息 - reflect.Type</h2> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <p><code>reflect.Type</code> 是一个接口，它代表了一个类型。我们可以通过 <code>reflect.TypeOf</code> 来获取一个类型的 <code>reflect.Type</code> 对象。 我们使用 <code>reflect.Type</code> 的目的通常是为了获取类型的信息，比如类型是什么、类型的名称、类型的字段、类型的方法等等。 又或者最常见的场景：结构体中的 <code>json</code> 的 <code>tag</code>，它是没有语义的，它的作用就是为了在序列化的时候，生成我们想要的字段名。 而这个 <code>tag</code> 就是需要通过反射来获取的。</p> <h3 id="通用的-type-方法"><a href="#通用的-type-方法" class="header-anchor">#</a> 通用的 Type 方法</h3> <p>在 go 的反射系统中，是使用 <code>reflect.Type</code> 这个接口来获取类型信息的。<code>reflect.Type</code> 这个接口有很多方法，下面这些方法是所有的类型通用的方法：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token comment">// Type 是 Go 类型的表示。</span>
<span class="token comment">//</span>
<span class="token comment">// 并非所有方法都适用于所有类型。</span>
<span class="token comment">// 在调用 kind 具体方法之前，先使用 Kind 方法找出类型的种类。因为调用一个方法如果类型不匹配会导致 panic</span>
<span class="token comment">//</span>
<span class="token comment">// Type 类型值是可以比较的，比如用 == 操作符。所以它可以用做 map 的 key</span>
<span class="token comment">// 如果两个 Type 值代表相同的类型，那么它们一定是相等的。</span>
<span class="token keyword">type</span> Type <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token comment">// Align 返回该类型在内存中分配时，以字节数为单位的字节数</span>
   <span class="token function">Align</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
   
   <span class="token comment">// FieldAlign 返回该类型在结构中作为字段使用时，以字节数为单位的字节数</span>
   <span class="token function">FieldAlign</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
   
   <span class="token comment">// Method 这个方法返回类型方法集中的第 i 个方法。</span>
   <span class="token comment">// 如果 i 不在[0, NumMethod()]范围内，就会 panic。</span>
   <span class="token comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span>
   <span class="token comment">// 其第一个参数是接收者，并且只能访问导出的方法。</span>
   <span class="token comment">// 对于一个接口类型，返回的 Method 的 Type 字段给出的是方法签名，没有接收者，Func字段为nil。</span>
   <span class="token comment">// 方法是按字典序顺序排列的。</span>
   <span class="token function">Method</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> Method

   <span class="token comment">// MethodByName 返回类型的方法集中具有该名称的方法和一个指示是否找到该方法的布尔值。</span>
   <span class="token comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span>
   <span class="token comment">// 其第一个参数是接收者。</span>
   <span class="token comment">// 对于一个接口类型，返回的 Method 的 Type 字段给出的是方法签名，没有接收者，Func字段为nil。</span>
   <span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Method<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>

   <span class="token comment">// NumMethod 返回使用 Method 可以访问的方法数量。</span>
   <span class="token comment">// 对于非接口类型，它返回导出方法的数量。</span>
   <span class="token comment">// 对于接口类型，它返回导出和未导出方法的数量。</span>
   <span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

   <span class="token comment">// Name 返回定义类型在其包中的类型名称。</span>
   <span class="token comment">// 对于其他（未定义的）类型，它返回空字符串。</span>
   <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

   <span class="token comment">// PkgPath 返回一个定义类型的包的路径，也就是导入路径，导入路径是唯一标识包的类型，如 &quot;encoding/base64&quot;。</span>
   <span class="token comment">// 如果类型是预先声明的(string, error)或者没有定义(*T, struct{}, []int，或 A，其中 A 是一个非定义类型的别名），包的路径将是空字符串。</span>
   <span class="token function">PkgPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

   <span class="token comment">// Size 返回存储给定类型的值所需的字节数。它类似于 unsafe.Sizeof.</span>
   <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uintptr</span>

   <span class="token comment">// String 返回该类型的字符串表示。</span>
   <span class="token comment">// 字符串表示法可以使用缩短的包名。</span>
   <span class="token comment">// (例如，使用 base64 而不是 &quot;encoding/base64&quot;)并且它并不能保证类型之间是唯一的。如果是为了测试类型标识，应该直接比较类型 Type。</span>
   <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

   <span class="token comment">// Kind 返回该类型的具体种类。</span>
   <span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Kind

   <span class="token comment">// Implements 表示该类型是否实现了接口类型 u。</span>
   <span class="token function">Implements</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span>

   <span class="token comment">// AssignableTo 表示该类型的值是否可以分配给类型 u。</span>
   <span class="token function">AssignableTo</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span>

   <span class="token comment">// ConvertibleTo 表示该类型的值是否可转换为 u 类型。</span>
   <span class="token function">ConvertibleTo</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span>

   <span class="token comment">// Comparable 表示该类型的值是否具有可比性。</span>
   <span class="token function">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br></div></div><h3 id="某些类型特定的-type-方法"><a href="#某些类型特定的-type-方法" class="header-anchor">#</a> 某些类型特定的 Type 方法</h3> <p>下面是某些类型特定的方法，对于这些方法，如果我们使用的类型不对，则会 <code>panic</code>：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">type</span> Type <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token comment">// Bits 以 bits 为单位返回类型的大小。</span>
   <span class="token comment">// 如果类型的 Kind 不属于：sized 或者 unsized Int, Uint, Float, 或者 Complex，会 panic。</span>
   <span class="token function">Bits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

   <span class="token comment">// ChanDir 返回一个通道类型的方向。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Chan，会 panic。</span>
   <span class="token function">ChanDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ChanDir

   <span class="token comment">// IsVariadic 表示一个函数类型的最终输入参数是否为一个 &quot;...&quot; 可变参数。如果是，t.In(t.NumIn() - 1) 返回参数的隐式实际类型 []T.</span>
   <span class="token comment">// 更具体的，如果 t 代表 func(x int, y ... float64)，那么：</span>
   <span class="token comment">// t.NumIn() == 2</span>
   <span class="token comment">// t.In(0)是 &quot;int&quot; 的 reflect.Type 反射类型。</span>
   <span class="token comment">// t.In(1)是 &quot;[]float64&quot; 的 reflect.Type 反射类型。</span>
   <span class="token comment">// t.IsVariadic() == true</span>
   <span class="token comment">// 如果类型的 Kind 不是 Func，IsVariadic 会 panic</span>
   <span class="token function">IsVariadic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>

   <span class="token comment">// Elem 返回一个 type 的元素类型。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Array、Chan、Map、Ptr 或 Slice，就会 panic</span>
   <span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Type

   <span class="token comment">// Field 返回一个结构类型的第 i 个字段。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Struct，就会 panic。</span>
   <span class="token comment">// 如果 i 不在 [0, NumField()) 范围内也会 panic。</span>
   <span class="token function">Field</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> StructField

   <span class="token comment">// FieldByIndex 返回索引序列对应的嵌套字段。它相当于对每一个 index 调用 Field。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Struct，就会 panic。</span>
   <span class="token function">FieldByIndex</span><span class="token punctuation">(</span>index <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> StructField

   <span class="token comment">// FieldByName 返回给定名称的结构字段和一个表示是否找到该字段的布尔值。</span>
   <span class="token function">FieldByName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>StructField<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>

   <span class="token comment">// FieldByNameFunc 返回一个能满足 match 函数的带有名称的 field 字段。布尔值表示是否找到。</span>
   <span class="token function">FieldByNameFunc</span><span class="token punctuation">(</span>match <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>StructField<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>

   <span class="token comment">// In 返回函数类型的第 i 个输入参数的类型。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Func 类型会 panic。</span>
   <span class="token comment">// 如果 i 不在 [0, NumIn()) 的范围内，会 panic。</span>
   <span class="token function">In</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> Type

   <span class="token comment">// Key 返回一个 map 类型的 key 类型。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Map，会 panic。</span>
   <span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Type

   <span class="token comment">// Len 返回一个数组类型的长度。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Array，会 panic。</span>
   <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

   <span class="token comment">// NumField 返回一个结构类型的字段数目。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Struct，会 panic。</span>
   <span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

   <span class="token comment">// NumIn 返回一个函数类型的输入参数数。</span>
   <span class="token comment">// 如果类型的 Kind 不是Func.NumIn()，会 panic。</span>
   <span class="token function">NumIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

   <span class="token comment">// NumOut 返回一个函数类型的输出参数数。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Func.NumOut()，会 panic。</span>
   <span class="token function">NumOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

   <span class="token comment">// Out 返回一个函数类型的第 i 个输出参数的类型。</span>
   <span class="token comment">// 如果类型的 Kind 不是 Func，会 panic。</span>
   <span class="token comment">// 如果 i 不在 [0, NumOut()) 的范围内，会 panic。</span>
   <span class="token function">Out</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> Type
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div><h3 id="创建-reflect-type-的方式"><a href="#创建-reflect-type-的方式" class="header-anchor">#</a> 创建 reflect.Type 的方式</h3> <p>我们可以通过下面的方式来获取变量的类型信息（创建 <code>reflect.Type</code> 的方式）：</p> <p><img src="/images/go/reflect1/6.webp" alt="reflect_6.png"></p> <h2 id="获取值信息-reflect-value"><a href="#获取值信息-reflect-value" class="header-anchor">#</a> 获取值信息 - reflect.Value</h2> <h3 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h3> <p><code>reflect.Value</code> 是一个结构体，它代表了一个值。 我们使用 <code>reflect.Value</code> 可以实现一些接收多种类型参数的函数，又或者可以让我们在运行时针对值的一些信息来进行修改。 常常用在接收 <code>interface{}</code> 类型参数的方法中，因为参数是接口类型，所以我们可以通过 <code>reflect.ValueOf</code> 来获取到参数的值信息。 比如类型、大小、结构体字段、方法等等。</p> <p>同时，我们可以对这些获取到的反射值进行修改。这也是反射的一个重要用途。</p> <h3 id="reflect-value-的方法"><a href="#reflect-value-的方法" class="header-anchor">#</a> reflect.Value 的方法</h3> <p><code>reflect.Value</code> 这个 <code>Sreuct</code> 同样有很多方法：具体可以分为以下几类：</p> <ol><li>设置值的方法：<code>Set*</code>：<code>Set</code>、<code>SetBool</code>、<code>SetBytes</code>、<code>SetCap</code>、<code>SetComplex</code>、<code>SetFloat</code>、<code>SetInt</code>、<code>SetLen</code>、<code>SetMapIndex</code>、<code>SetPointer</code>、<code>SetString</code>、<code>SetUint</code>。通过这类方法，我们可以修改反射值的内容，前提是这个反射值得是合适的类型。<strong>CanSet 返回 true 才能调用这类方法</strong></li> <li>获取值的方法：<code>Interface</code>、<code>InterfaceData</code>、<code>Bool</code>、<code>Bytes</code>、<code>Complex</code>、<code>Float</code>、<code>Int</code>、<code>String</code>、<code>Uint</code>。通过这类方法，我们可以获取反射值的内容。前提是这个反射值是合适的类型，比如我们不能通过 <code>complex</code> 反射值来调用 <code>Int</code> 方法（我们可以通过 <code>Kind</code> 来判断类型）。</li> <li>map 类型的方法：<code>MapIndex</code>、<code>MapKeys</code>、<code>MapRange</code>、<code>MapSet</code>。</li> <li>chan 类型的方法：<code>Close</code>、<code>Recv</code>、<code>Send</code>、<code>TryRecv</code>、<code>TrySend</code>。</li> <li>slice 类型的方法：<code>Len</code>、<code>Cap</code>、<code>Index</code>、<code>Slice</code>、<code>Slice3</code>。</li> <li>struct 类型的方法：<code>NumField</code>、<code>NumMethod</code>、<code>Field</code>、<code>FieldByIndex</code>、<code>FieldByName</code>、<code>FieldByNameFunc</code>。</li> <li>判断是否可以设置为某一类型：<code>CanConvert</code>、<code>CanComplex</code>、<code>CanFloat</code>、<code>CanInt</code>、<code>CanInterface</code>、<code>CanUint</code>。</li> <li>方法类型的方法：<code>Method</code>、<code>MethodByName</code>、<code>Call</code>、<code>CallSlice</code>。</li> <li>判断值是否有效：<code>IsValid</code>。</li> <li>判断值是否是 <code>nil</code>：<code>IsNil</code>。</li> <li>判断值是否是零值：<code>IsZero</code>。</li> <li>判断值能否容纳下某一类型的值：<code>Overflow</code>、<code>OverflowComplex</code>、<code>OverflowFloat</code>、<code>OverflowInt</code>、<code>OverflowUint</code>。</li> <li>反射值指针相关的方法：<code>Addr</code>（<code>CanAddr</code> 为 <code>true</code> 才能调用）、<code>UnsafeAddr</code>、<code>Pointer</code>、<code>UnsafePointer</code>。</li> <li>获取类型信息：<code>Type</code>、<code>Kind</code>。</li> <li>获取指向元素的值：<code>Elem</code>。</li> <li>类型转换：<code>Convert</code>。</li></ol> <blockquote><p><code>Len</code> 也适用于 <code>slice</code>、<code>array</code>、<code>chan</code>、<code>map</code>、<code>string</code> 类型的反射值。</p></blockquote> <h3 id="创建-reflect-value-的方式"><a href="#创建-reflect-value-的方式" class="header-anchor">#</a> 创建 reflect.Value 的方式</h3> <p>我们可以通过下面的方式来获取变量的值信息（创建 <code>reflect.Value</code> 的方式）：</p> <p><img src="/images/go/reflect1/7.webp" alt="reflect_7.png"></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li><p><code>reflect</code> 包提供了反射机制，可以在运行时获取变量的类型信息、值信息、方法信息等等。</p></li> <li><p>go 中的 <code>interface{}</code> 实际上包含了两个指针，一个指向类型信息，一个指向值信息。正因如此，我们可以在运行时通过 <code>interface{}</code> 来获取变量的类型信息、值信息。</p></li> <li><p><code>reflect.Type</code> 代表一个类型，<code>reflect.Value</code> 代表一个值。通过 <code>reflect.Type</code> 可以获取类型信息，通过 <code>reflect.Value</code> 可以获取值信息。</p></li> <li><p>反射三定律：</p> <ul><li>反射可以将 <code>interface</code> 类型变量转换成反射对象。</li> <li>反射可以将反射对象还原成 <code>interface</code> 对象。</li> <li>如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</li></ul></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>reflect.Value
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>和</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>reflect.Type
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>里面都有</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Elem
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>方法，但是它们的作用不一样：</p> <ul><li><code>reflect.Type</code> 的 <code>Elem</code> 方法返回的是元素类型，只适用于 array、chan、map、pointer 和 slice 类型的 <code>reflect.Type</code>。</li> <li><code>reflect.Value</code> 的 <code>Elem</code> 方法返回的是值，只适用于接口或指针类型的 <code>reflect.Value</code>。</li></ul></li> <li><p>通过 <code>reflect.Value</code> 的 <code>Interface</code> 方法可以获取到反射对象的原始变量，但是是 <code>interface{}</code> 类型的。</p></li> <li><p><code>Type</code> 和 <code>Kind</code> 都表示类型，但是 <code>Type</code> 是类型的反射对象，<code>Kind</code> 是 go 类型系统中最基本的一些类型，比如 <code>int</code>、<code>string</code>、<code>struct</code> 等等。</p></li> <li><p>如果我们想通过 <code>reflect.Value</code> 来修改变量的值，那么 <code>reflect.Value</code> 必须是可设置的（<code>CanSet</code>）。同时如果想要 <code>CanSet</code> 为 true，那么我们的变量必须是可寻址的。</p></li> <li><p>我们有很多方法可以创建 <code>reflect.Type</code> 和 <code>reflect.Value</code>，我们需要根据具体的场景来选择合适的方法。</p></li> <li><p><code>reflect.Type</code> 和 <code>reflect.Value</code> 里面，都有一部分方法是通用的，也有一部分只适用于特定的类型。如果我们想要调用那些适用于特定类型的方法，那么我们必须先判断 <code>reflect.Type</code> 或 <code>reflect.Value</code> 的类型（这里说的是 <code>Kind</code>），然后再调用。</p></li></ul></div></div> <div class="page-slot page-slot-bottom"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8621788234752924"
     crossorigin="anonymous"></script></br><ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="auto"
     data-ad-client="ca-pub-8621788234752924"
     data-ad-slot="7043271566"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script></div> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Golang" title="标签">#Golang</a><a href="/tags/?tag=reflect" title="标签">#reflect</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/9/2023</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/golang/go-sync-once/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">深入理解 go sync.Once</div></a> <a href="/pages/golang/go-reflect-2/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">深入理解 go reflect - 要不要传指针</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/golang/go-sync-once/" class="prev">深入理解 go sync.Once</a></span> <span class="next"><a href="/pages/golang/go-reflect-2/">深入理解 go reflect - 要不要传指针</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/mosquito-config-ws/"><div>
            mosquito配置ws协议
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/pip-download-offline/"><div>
            Pip包的离线下载和安装
            <!----></div></a> <span class="date">10-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/favorites/sd/"><div>
            stable diffusion 相关收藏
            <!----></div></a> <span class="date">02-24</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/moxiaolong" title="Star我" target="_blank" class="iconfont icon-github"></a><a href="http://music.163.com/playlist?id=8444337" title="有品位的歌单" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2024
    <span>Dra-M</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bc3c2a75.js" defer></script><script src="/assets/js/2.472001a0.js" defer></script><script src="/assets/js/42.895064c8.js" defer></script>
  </body>
</html>
